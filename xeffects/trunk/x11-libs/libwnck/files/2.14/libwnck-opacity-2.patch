--- libwnck/window-action-menu.c	18 Feb 2006 16:29:29 -0000	1.20
+++ libwnck/window-action-menu.c	19 Apr 2006 17:02:49 -0000
@@ -36,6 +36,7 @@
   ABOVE,
   MOVE,
   RESIZE,
+  CHANGE_OPACITY,
   PIN,
   LEFT,
   RIGHT,
@@ -55,6 +56,7 @@
   GtkWidget *above_item;
   GtkWidget *move_item;
   GtkWidget *resize_item;
+  GtkWidget *opacity_item;
   GtkWidget *close_item;
   GtkWidget *workspace_separator;
   GtkWidget *pin_item;
@@ -115,7 +117,7 @@
 {
   ActionMenuData *amd = get_data (G_OBJECT (menu_item));
   WindowAction action = GPOINTER_TO_INT (data);
-  
+
   if (amd == NULL)
     return;
 
@@ -151,6 +153,15 @@
     case RESIZE:
       wnck_window_keyboard_size (amd->window);
       break;
+    case CHANGE_OPACITY: {
+	int opacity_value;
+
+	opacity_value =
+	    GPOINTER_TO_INT (g_object_get_data (G_OBJECT (menu_item),
+						"opacity"));
+	
+	wnck_window_set_opacity (amd->window, opacity_value);
+    } break;
     case PIN:
       if (wnck_window_is_pinned (amd->window))
         wnck_window_unpin (amd->window);
@@ -578,6 +589,47 @@
 
   set_item_text (amd->resize_item, _("_Resize"));
   set_item_stock (amd->move_item, NULL);
+
+  if (wnck_screen_net_wm_supports (wnck_window_get_screen (amd->window),
+				   "_NET_WM_WINDOW_OPACITY"))
+  {
+      guint present_opacity;
+      gint  j;
+
+      amd->opacity_item = gtk_menu_item_new_with_mnemonic (_("_Opacity"));
+      gtk_widget_show (amd->opacity_item);
+
+      submenu = gtk_menu_new ();
+      gtk_menu_item_set_submenu (GTK_MENU_ITEM (amd->opacity_item),
+				 submenu);
+
+      gtk_menu_shell_append (GTK_MENU_SHELL (menu), amd->opacity_item);
+
+      present_opacity = wnck_window_get_opacity (window);
+      for (j = 0; j < 4; j++)
+      {
+	  GtkWidget *item;
+	  gchar	    *label;
+	  guint	    o;
+
+	  label = g_strdup_printf ("%d%%", (j + 1) * 25);
+
+	  item = make_menu_item (amd, CHANGE_OPACITY);
+
+	  o = (j + 1) * 25;
+	  g_object_set_data (G_OBJECT (item), "opacity", GINT_TO_POINTER (o));
+
+	  if (o == present_opacity)
+	      gtk_widget_set_sensitive (item, FALSE);
+
+	  gtk_menu_shell_append (GTK_MENU_SHELL (submenu), item);
+
+	  set_item_text (item, label);
+	  set_item_stock (item, NULL);
+
+	  g_free (label);
+      }
+  }
 
   separator = gtk_separator_menu_item_new ();
   gtk_widget_show (separator);
--- libwnck/window.c	28 Mar 2006 21:49:20 -0000	1.64
+++ libwnck/window.c	19 Apr 2006 17:02:50 -0000
@@ -88,6 +88,8 @@
 
   char *res_class;
   char *res_name;
+
+  guint32 opacity;
   
   /* true if transient_for points to root window,
    * not another app window
@@ -133,6 +135,7 @@
   guint need_update_startup_id : 1;
   guint need_update_wmclass : 1;
   guint need_update_wmhints : 1;
+  guint need_update_opacity : 1;
 };
 
 enum {
@@ -142,6 +145,7 @@
   ICON_CHANGED,
   ACTIONS_CHANGED,
   GEOMETRY_CHANGED,
+  OPACITY_CHANGED,
   LAST_SIGNAL
 };
 
@@ -170,6 +174,7 @@
 static void update_transient_for (WnckWindow *window);
 static void update_startup_id (WnckWindow *window);
 static void update_wmclass    (WnckWindow *window);
+static void update_opacity   (WnckWindow *window);
 static void unqueue_update   (WnckWindow *window);
 static void queue_update     (WnckWindow *window);
 static void force_update_now (WnckWindow *window);
@@ -288,6 +293,15 @@
                   NULL, NULL,
                   g_cclosure_marshal_VOID__VOID,
                   G_TYPE_NONE, 0);  
+
+  signals[OPACITY_CHANGED] =
+    g_signal_new ("opacity_changed",
+                  G_OBJECT_CLASS_TYPE (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (WnckWindowClass, opacity_changed),
+                  NULL, NULL,
+                  g_cclosure_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);  
 }
 
 static void
@@ -416,6 +430,7 @@
   window->priv->need_update_startup_id = TRUE;
   window->priv->need_update_wmclass = TRUE;
   window->priv->need_update_wmhints = TRUE;
+  window->priv->need_update_opacity = TRUE;
   force_update_now (window);
 
   return window;
@@ -1520,6 +1535,29 @@
     *heightp = window->priv->height;
 }
 
+guint
+wnck_window_get_opacity (WnckWindow *window)
+{
+  guint64 o;
+
+  g_return_val_if_fail (WNCK_IS_WINDOW (window), 0);
+
+  o = ((guint64) window->priv->opacity * 1005) / G_MAXUINT32;
+
+  return o / 10;
+}
+
+void
+wnck_window_set_opacity (WnckWindow *window,
+			 guint      opacity)
+{
+  g_return_if_fail (WNCK_IS_WINDOW (window));
+
+  _wnck_change_opacity (WNCK_SCREEN_XSCREEN (window->priv->screen),
+			wnck_window_get_xid (window),
+			(((guint64) opacity * G_MAXUINT32) / 100));
+}
+
 /**
  * wnck_window_is_visible_on_workspace:
  * @window: a #WnckWindow
@@ -1742,6 +1780,13 @@
       window->priv->need_update_wmhints = TRUE;
       queue_update (window);
     }
+  else if (xevent->xproperty.atom ==
+           _wnck_atom_get ("_NET_WM_WINDOW_OPACITY"))
+    {
+      window->priv->need_update_opacity = TRUE;
+      queue_update (window);
+    }
+
 }
 
 void
@@ -2249,6 +2294,17 @@
 }
 
 static void
+update_opacity (WnckWindow *window)
+{
+  if (!window->priv->need_update_opacity)
+    return;
+
+  window->priv->need_update_opacity = FALSE;
+
+  window->priv->opacity = _wnck_get_opacity (window->priv->xwindow);
+}
+
+static void
 force_update_now (WnckWindow *window)
 {
   WnckWindowState old_state;
@@ -2312,6 +2368,7 @@
                               */
   update_workspace (window); /* emits signals */
   update_actions (window);
+  update_opacity (window);
 
   get_icons (window);
   
--- libwnck/window.h	21 Jan 2006 19:52:50 -0000	1.36
+++ libwnck/window.h	19 Apr 2006 17:02:50 -0000
@@ -127,6 +127,9 @@
 
   /* Changed size/position */
   void (* geometry_changed)      (WnckWindow       *window);
+
+  /* Changed opacity */
+  void (* opacity_changed)      (WnckWindow       *window);
 };
 
 GType wnck_window_get_type (void) G_GNUC_CONST;
@@ -230,6 +233,9 @@
                                int        *yp,
                                int        *widthp,
                                int        *heightp);
+
+guint wnck_window_get_opacity (WnckWindow *window);
+void  wnck_window_set_opacity (WnckWindow *window, guint opacity);
 
 gboolean wnck_window_is_visible_on_workspace (WnckWindow    *window,
                                               WnckWorkspace *workspace);
--- libwnck/xutils.c	25 Mar 2006 08:59:28 -0000	1.55
+++ libwnck/xutils.c	19 Apr 2006 17:02:50 -0000
@@ -1089,6 +1089,33 @@
 	      &xev);
 }
 
+void
+_wnck_change_opacity (Screen  *screen,
+		      Window  xwindow,
+		      guint32 opacity)
+{
+  XEvent xev;
+
+  xev.xclient.type = ClientMessage;
+  xev.xclient.serial = 0;
+  xev.xclient.send_event = True;
+  xev.xclient.display = gdk_display;
+  xev.xclient.window = xwindow;
+  xev.xclient.message_type = _wnck_atom_get ("_NET_WM_WINDOW_OPACITY");
+  xev.xclient.format = 32;
+  xev.xclient.data.l[0] = opacity;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = 0;
+
+  XSendEvent (gdk_display,
+	      RootWindowOfScreen (screen),
+	      False,
+	      SubstructureRedirectMask | SubstructureNotifyMask,
+	      &xev);
+}
+
 char*
 _wnck_get_session_id (Window xwindow)
 {
@@ -1207,6 +1234,19 @@
       
       XFree (ch.res_class);
     }
+}
+
+guint32
+_wnck_get_opacity (Window xwindow)
+{
+  int val;
+
+  if (_wnck_get_cardinal (xwindow,
+			  _wnck_atom_get ("_NET_WM_WINDOW_OPACITY"),
+			  &val))
+      return val;
+
+  return G_MAXUINT32;
 }
 
 void
--- libwnck/xutils.h	16 Jun 2005 17:32:36 -0000	1.26
+++ libwnck/xutils.h	19 Apr 2006 17:02:50 -0000
@@ -108,6 +108,9 @@
 void _wnck_change_viewport (Screen *screen,
 			    int     x,
 			    int     y);
+void _wnck_change_opacity (Screen  *screen,
+			   Window  xwindow,
+			   guint32 opacity);
 
 char*  _wnck_get_session_id     (Window xwindow);
 int    _wnck_get_pid            (Window xwindow);
@@ -116,6 +119,9 @@
 void   _wnck_get_wmclass        (Window xwindow,
                                  char **res_class,
                                  char **res_name);
+
+guint32 _wnck_get_opacity (Window xwindow);
+
 
 void   _wnck_select_input     (Window xwindow,
                                int    mask);
