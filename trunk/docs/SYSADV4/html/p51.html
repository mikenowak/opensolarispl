<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- GenHTML@17046-->
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Large Files - System Administration Guide: Network Services</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2007-02-01">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/ipg.css">
</head>

<body leftmargin="0" topmargin="0" marginheight="0" marginwidth="0" bgcolor="#ffffff"  class="a0v0">
<!--stopindex-->

<a name="top"></a>

<!-- BEGIN A1 COMPONENT V.0 -->
<div class="a1">
<div class="a1v0">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com">sun.com</a>
<a href="http://docs.sun.com/" class="dividelink">docs.sun.com</a>
</span>
</td><td align="right" nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com/MySun/">My Sun</a>
<a href="http://www.sun.com/worldwide/" class="dividelink">Worldwide Sites</a>
</span>
</td></tr>
</table>
</div>
</div>
<!-- END A1 COMPONENT V.0 -->

<!-- BEGIN A2 COMPONENT V.0 -->
<div class="a2" id="a2v0">
<div class="cornerTL">
<div class="cornerTR">
<div class="cornerBL">
<div class="cornerBR">
<div class="a2topiclinks">
<table cellpadding="1" cellspacing="0" border="0">
<tr valign="bottom">
<td><a href="http://www.sun.com/" title="Home Page"><img src="css/a.gif" alt="Home Page" width="104" height="58" border="0" class="sunlogo"></a></td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip1"></td>
<td class="navlinks" id="navlink1">
<div>
<a id="glink1" href="http://www.sun.com/products/">Products</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip2"></td>
<td class="navlinks" id="navlink2">
<div>
<a id="glink2" href="http://www.sun.com/downloads/">Downloads</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip3"></td><td class="navlinks" id="navlink3">
<div>
<a id="glink3" href="http://www.sun.com/service/">Service &amp; Solutions</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip4"></td><td class="navlinks" id="navlink4">
<div>
<a id="glink4" href="http://www.sun.com/support/">Support</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip5"></td><td class="navlinks" id="navlink5">
<div>
<a id="glink5" href="http://www.sun.com/training/">Training</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip6"></td><td class="navlinks" id="navlink6">
<div>
<a id="glink6" href="http://research.sun.com/">Research</a>
</div>
</td>
</tr>
</table>
</div>

</div></div></div></div>
</div>
<!-- END A2 COMPONENT V.0 -->

<!-- BEGIN BREADCRUMB -->
<div id="breadcrumb">
<?GenHTML ReferencePage >System Administration Guide: Network Services<?GenHTML /ReferencePage> > <a href="p31.html">6.&nbsp;&nbsp;Accessing Network File Systems (Reference)</a> > <a href="p47.html#rfsrefer-45">How the NFS Service Works</a>
</div><br />
<!-- END BREADCRUMB -->

<!-- BEGIN WRAPPER TABLE, 1 COLUMN, MAIN -->
<table border="0" cellpadding="0" cellspacing="10" width="100%">
<tr valign="bottom"><td width="100%" valign="top">
<!-- BEGIN CENTRAL COLUMN COMPONENTS -->

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr><td colspan="5"></td></tr>
<tr>
<td></td>
<td style="width: 60%">&nbsp;</td>
<td><a href="p50.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p52.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->

</td></tr>
<tr><td width="100%" valign="top">
<a name="skip2content"> </a>

<!--startindex-->
<div class="maincontent">
<a name="rfsrefer-55"></a><h4>Large Files</h4>
<a name="indexterm-710"></a><p>Starting with the Solaris 2.6 release, the Solaris OS supports files
that are over 2 Gbytes. By default, UFS file systems are mounted with the <tt>-largefiles</tt> option to support the new capability. Previous releases
cannot handle files of this size. See <a href="p17.html#rfsadmin-75">How to Disable Large Files on an NFS Server</a> for instructions.</p>
<p>If the server's file system is mounted with the <tt>-largefiles</tt> option,
a Solaris 2.6 NFS client can access large files without the need for changes.
However, not all Solaris 2.6 commands can handle these large files. See <tt>largefile</tt>(5) for a list
of the commands that can handle the large files. Clients that cannot support
the NFS version 3 protocol with the large file extensions cannot access any
large files. Although clients that run the Solaris 2.5 release can use the
NFS version 3 protocol, large file support was not included in that release.</p>
<a name="rfsrefer-105"></a><h4>How NFS Server Logging Works</h4>
<p>NFS server logging provides records of NFS reads and writes, as well
as operations that modify the file system. This data can be used to track
access to information. In addition, the records can provide a quantitative
way to measure interest in the information.</p>
<p>When a file system with logging enabled is accessed, the kernel writes
raw data into a buffer file. This data includes the following:</p>
<ul><li><p>A timestamp</p>
</li>
<li><p>The client IP address</p>
</li>
<li><p>The UID of the requester</p>
</li>
<li><p>The file handle of the file or directory object that is being
accessed</p>
</li>
<li><p>The type of operation that occurred</p>
</li>
</ul>
<p>The <tt>nfslogd</tt> daemon converts this raw data into ASCII
records that are stored in log files. During the conversion, the IP addresses
are modified to host names and the UIDs are modified to logins if the name
service that is enabled can find matches. The file handles are also converted
into path names. To accomplish the conversion, the daemon tracks the file
handles and stores information in a separate file handle-to-path table. That
way, the path does not have to be identified again each time a file handle
is accessed. Because no changes to the mappings are made in the file handle-to-path
table if <tt>nfslogd</tt> is turned off, you must keep the daemon
running.</p>
<hr>
<p><b>Note - </b>Server logging is not supported in NFS version 4.</p>
<hr>
<a name="rfsrefer-56"></a><h4>How the WebNFS Service Works</h4>
<a name="indexterm-711"></a><p>The WebNFS service makes files in a directory available to clients by
using a public file handle. A file handle is an address that is generated
by the kernel that identifies a file for NFS clients. The <b>public
file handle</b> has a predefined value, so the server does not need
to generate a file handle for the client. The ability to use this predefined
file handle reduces network traffic by eliminating the <tt>MOUNT</tt> protocol.
This ability should also accelerate processes for the clients.</p>
<p>By default, the public file handle on an NFS server is established on
the root file system. This default provides WebNFS access to any clients that
already have mount privileges on the server. You can change the public file
handle to point to any file system by using the <tt>share</tt> command.</p>
<p>When the client has the file handle for the file system, a <tt>LOOKUP</tt> is
run to determine the file handle for the file to be accessed. The NFS protocol
allows the evaluation of only one path name component at a time. Each additional
level of directory hierarchy requires another <tt>LOOKUP</tt>. A
WebNFS server can evaluate an entire path name with a single multi-component
lookup transaction when the <tt>LOOKUP</tt> is relative to the public
file handle. Multi-component lookup enables the WebNFS server to deliver the
file handle to the desired file without exchanging the file handles for each
directory level in the path name.</p>
<p>In addition, an NFS client can initiate concurrent downloads over a
single TCP connection. This connection provides quick access without the additional
load on the server that is caused by setting up multiple connections. Although
web browser applications support concurrent downloading of multiple files,
each file has its own connection. By using one connection, the WebNFS software
reduces the overhead on the server.</p>
<p>If the final component in the path name is a symbolic link to another
file system, the client can access the file if the client already has access
through normal NFS activities.</p>
<p>Normally, an NFS URL is evaluated relative to the public file handle.
The evaluation can be changed to be relative to the server's root file system
by adding an additional slash to the beginning of the path. In this example,
these two NFS URLs are equivalent if the public file handle has been established
on the <tt>/export/ftp</tt> file system.</p>
<pre>nfs://server/junk
nfs://server//export/ftp/junk</pre><hr>
<p><b>Note - </b>The NFS version 4 protocol is preferred over the WebNFS service.
NFS version 4 fully integrates all the security negotiation that was added
to the MOUNT protocol and the WebNFS service.</p>
<hr>
<a name="egcod"></a><h4>How WebNFS Security Negotiation Works</h4>
<p>The Solaris 8 release includes a new protocol that enables a WebNFS
client to negotiate a selected security mechanism with a WebNFS server.  The
new protocol uses security negotiation multi-component lookup, which is an
extension to the multi-component lookup that was used in earlier versions
of the WebNFS protocol.</p>
<p>The WebNFS client initiates the process by making a regular multi&ndash;component
lookup request by using the public file handle. Because the client has no
knowledge of how the path is protected by the server, the default security
mechanism is used. If the default security mechanism is not sufficient, the
server replies with an <tt>AUTH_TOOWEAK</tt> error. This reply indicates
that the default mechanism is not valid. The client needs to use a stronger
default mechanism.</p>
<p>When the client receives the <tt>AUTH_TOOWEAK</tt> error,
the client sends a request to the server to determine which security mechanisms
are required. If the request succeeds, the server responds with an array of
security mechanisms that are required for the specified path. Depending on
the size of the array of security mechanisms, the client might have to make
more requests to obtain the complete array. If the server does not support
WebNFS security negotiation, the request fails.</p>
<p>After a successful request, the WebNFS client selects the first security
mechanism from the array that the client supports. The client then issues
a regular multi-component lookup request by using the selected security mechanism
to acquire the file handle. All subsequent NFS requests are made by using
the selected security mechanism and the file handle.</p>
<hr>
<p><b>Note - </b>The NFS version 4 protocol is preferred over the WebNFS service.
NFS version 4 fully integrates all the security negotiation that was added
to the MOUNT protocol and the WebNFS service.</p>
<hr>
<a name="rfsrefer-57"></a><h4>WebNFS Limitations With Web Browser Use</h4>
<p>Several functions that a web site that uses HTTP can provide are not
supported by the WebNFS software. These differences stem from the fact that
the NFS server only sends the file, so any special processing must be done
on the client. If you need to have one web site configured for both WebNFS
and HTTP access, consider the following issues:</p>
<ul><li><p>NFS browsing does not run CGI scripts. So, a file system with
an active web site that uses many CGI scripts might not be appropriate for
NFS browsing.</p>
</li>
<li><p>The browser might start different viewers to handle files
in different file formats. Accessing these files through an NFS URL starts
an external viewer if the file type can be determined by the file name. The
browser should recognize any file name extension for a standard MIME type
when an NFS URL is used. The WebNFS software does not check inside the file
to determine the file type. So, the only way to determine a file type is by
the file name extension.</p>
</li>
<li><p>NFS browsing cannot utilize server-side image maps (clickable
images). However, NFS browsing can utilize client-side image maps (clickable
images) because the URLs are defined with the location. No additional response
is required from the document server.</p>
</li>
</ul>
<a name="rfsrefer-58"></a><h4>Secure NFS System</h4>
<p><a name="indexterm-712"></a><a name="indexterm-713"></a><a name="indexterm-714"></a><a name="indexterm-715"></a><a name="indexterm-716"></a><a name="indexterm-717"></a><a name="indexterm-718"></a><a name="indexterm-719"></a><a name="indexterm-720"></a>The NFS environment is a powerful way and convenient way to share
file systems on a network of different computer architectures and operating
systems. However, the same features that make sharing file systems through
NFS operation convenient also pose some security problems. Historically, most
NFS implementations have used UNIX (or AUTH_SYS) authentication, but stronger
authentication methods such as AUTH_DH have also been available. When using
UNIX authentication, an NFS server authenticates a file request by authenticating
the computer that makes the request, but not the user. Therefore, a client
user can run <tt>su</tt> and impersonate the owner of a file. If
DH authentication is used, the NFS server authenticates the user, making this
sort of impersonation much harder.</p>
<p>With root access and knowledge of network programming, anyone can introduce
arbitrary data into the network and extract any data from the network. The
most dangerous attacks are those attacks that involve the introduction of
data. An example is the impersonation of a user by generating the right packets
or by recording &ldquo;conversations&rdquo; and replaying them later. These
attacks affect data integrity. Attacks that involve passive eavesdropping,
which is merely listening to network traffic without impersonating anybody,
are not as dangerous, because data integrity is not compromised. Users can
protect the privacy of sensitive information by encrypting data that is sent
over the network. </p>
<p>A common approach to network security problems is to leave the solution
to each application. A better approach is to implement a standard authentication
system at a level that covers all applications. </p>
<p>The Solaris operating system includes an authentication system at the
level of the remote procedure call (RPC), which is the mechanism on which
the NFS operation is built. This system, known as Secure RPC, greatly improves
the security of network environments and provides additional security to services
such as the NFS system. When the NFS system uses the facilities that are provided
by Secure RPC, it is known as a Secure NFS system. </p>
<a name="rfsrefer-59"></a><h4>Secure RPC</h4>
<p><a name="indexterm-721"></a><a name="indexterm-722"></a><a name="indexterm-723"></a><a name="indexterm-724"></a><a name="indexterm-725"></a><a name="indexterm-726"></a><a name="indexterm-727"></a>Secure RPC is fundamental to the Secure NFS system.  The goal
of Secure RPC is to build a system that is at minimum as secure as a time-sharing
system.  In a time-sharing system all users share a single computer. A time-sharing
system authenticates a user through a login password. With Data Encryption
Standard (DES) authentication, the same authentication process is completed.
Users can log in on any remote computer just as users can log in on a local
terminal. The users' login passwords are their assurance of network security.
In a time-sharing environment, the system administrator has an ethical obligation
not to change a password to impersonate someone. In Secure RPC, the network
administrator is trusted not to alter entries in a database that stores <b>public keys</b>.</p>
<p><a name="indexterm-728"></a><a name="indexterm-729"></a>You need to be familiar with two terms to understand an RPC authentication
system: credentials and verifiers. Using ID badges as an example, the credential
is what identifies a person: a name, address, and birthday. The verifier is
the photo that is attached to the badge. You can be sure that the badge has
not been stolen by checking the photo on the badge against the person who
is carrying the badge. In RPC, the client process sends both a credential
and a verifier to the server with each RPC request. The server sends back
only a verifier because the client already &ldquo;knows&rdquo; the server's
credentials. </p>
<p><a name="indexterm-730"></a><a name="indexterm-731"></a>RPC's authentication is open ended, which means that a variety
of authentication systems can be plugged into it, such as UNIX, DH, and KERB. </p>
<p><a name="indexterm-732"></a><a name="indexterm-733"></a><a name="indexterm-734"></a><a name="indexterm-735"></a>When UNIX authentication is used by a network service, the credentials
contain the client's host name, UID, GID, and group-access list. However,
the verifier contains nothing. Because no verifier exists, a superuser could
falsify appropriate credentials by using commands such as <tt>su</tt>.
Another problem with UNIX authentication is that UNIX authentication assumes
all computers on a network are UNIX computers. UNIX authentication breaks
down when applied to other operating systems in a heterogeneous network. </p>
<p><a name="indexterm-736"></a><a name="indexterm-737"></a><a name="indexterm-738"></a><a name="indexterm-739"></a><a name="indexterm-740"></a>To overcome the problems of UNIX authentication, Secure RPC uses
DH authentication.     </p>
<a name="rfsrefer-60"></a><h5>DH Authentication</h5>
<p><a name="indexterm-741"></a><a name="indexterm-742"></a><a name="indexterm-743"></a><a name="indexterm-744"></a><a name="indexterm-745"></a><a name="indexterm-746"></a><a name="indexterm-747"></a><a name="indexterm-748"></a>DH authentication uses the Data Encryption Standard (DES) and
Diffie-Hellman public-key cryptography to authenticate both users and computers
in the network. DES is a standard encryption mechanism. Diffie-Hellman public-key
cryptography is a cipher system that involves two keys: one public and one
secret. The public keys and secret keys are stored in the namespace. NIS stores
the keys in the public-key map. These maps contain the public key and secret
key for all potential users. See the <i>System Administration Guide: Naming and Directory Services (DNS, NIS, and LDAP)</i>  for more information about how to set
up the maps. </p>
<p>The security of DH authentication is based on a sender's ability to
encrypt the current time, which the receiver can then decrypt and check against
its own clock. The timestamp is encrypted with DES. The requirements for this
scheme to work are as follows:</p>
<ul><li><p>The two agents must agree on the current time.</p>
</li>
<li><p>The sender and receiver must be using the same encryption
key.</p>
</li>
</ul>
<p><a name="indexterm-749"></a><a name="indexterm-750"></a><a name="indexterm-751"></a>If a network runs a time-synchronization program, the time on
the client and the server is synchronized automatically. If a time-synchronization
program is not available, timestamps can be computed by using the server's
time instead of the network time. The client asks the server for the time
before starting the RPC session, then computes the time difference between
its own clock and the server's. This difference is used to offset the client's
clock when computing timestamps. If the client and server clocks become unsynchronized
the server begins to reject the client's requests. The DH authentication system
on the client resynchronizes with the server. </p>
<p><a name="indexterm-752"></a><a name="indexterm-753"></a><a name="indexterm-754"></a><a name="indexterm-755"></a><a name="indexterm-756"></a><a name="indexterm-757"></a><a name="indexterm-758"></a>The client and server arrive at the same encryption key by generating
a random <b>conversation key</b>, also known as the <b>session
key</b>, and by using public-key cryptography to deduce a <b>common
key</b>. The common key is a key that only the client and server are
capable of deducing. The conversation key is used to encrypt and decrypt the
client's timestamp. The common key is used to encrypt and decrypt the conversation
key. </p>

</div>
<!--stopindex-->

<!-- END CENTRAL COLUMN COMPONENTS -->
</td></tr>

<!-- BEGIN SPACER ROW -->
<tr><td><img src="css/a.gif" width="780" height="1" border="0" alt="" /></td></tr>
<!-- END SPACER ROW -->

<tr><td>

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr valign="bottom">
<td></td>
<td style="width: 60%"></td>
<td><a href="p50.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p52.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->
</td></tr>

</table>
<!-- END WRAPPER TABLE, 1 COLUMN, MAIN -->


<!-- BEGIN A5 COMPONENT V.0 -->
<div class="a5" id="a5v0">
<span class="footerlinks">
<a href="http://www.sun.com/company/">Company Info</a>
<a href="http://www.sun.com/contact/">Contact</a>
<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>
<a href="http://www.sun.com/privacy/">Privacy</a>

<span class="footercopy">Copyright 1994-2007 Sun Microsystems, Inc.</span>
</span>
</div>
<!-- END A5 COMPONENT V.0 -->

</body>
</html>

