<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- GenHTML@17046-->
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title>Introduction - Solaris Dynamic Tracing Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2005-09-01">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/ipg.css">
</head>

<body leftmargin="0" topmargin="0" marginheight="0" marginwidth="0" bgcolor="#ffffff"  class="a0v0">
<!--stopindex-->

<a name="top"></a>

<!-- BEGIN A1 COMPONENT V.0 -->
<div class="a1">
<div class="a1v0">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com">sun.com</a>
<a href="http://docs.sun.com/" class="dividelink">docs.sun.com</a>
</span>
</td><td align="right" nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com/MySun/">My Sun</a>
<a href="http://www.sun.com/worldwide/" class="dividelink">Worldwide Sites</a>
</span>
</td></tr>
</table>
</div>
</div>
<!-- END A1 COMPONENT V.0 -->

<!-- BEGIN A2 COMPONENT V.0 -->
<div class="a2" id="a2v0">
<div class="cornerTL">
<div class="cornerTR">
<div class="cornerBL">
<div class="cornerBR">
<div class="a2topiclinks">
<table cellpadding="1" cellspacing="0" border="0">
<tr valign="bottom">
<td><a href="http://www.sun.com/" title="Home Page"><img src="css/a.gif" alt="Home Page" width="104" height="58" border="0" class="sunlogo"></a></td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip1"></td>
<td class="navlinks" id="navlink1">
<div>
<a id="glink1" href="http://www.sun.com/products/">Products</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip2"></td>
<td class="navlinks" id="navlink2">
<div>
<a id="glink2" href="http://www.sun.com/downloads/">Downloads</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip3"></td><td class="navlinks" id="navlink3">
<div>
<a id="glink3" href="http://www.sun.com/service/">Service &amp; Solutions</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip4"></td><td class="navlinks" id="navlink4">
<div>
<a id="glink4" href="http://www.sun.com/support/">Support</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip5"></td><td class="navlinks" id="navlink5">
<div>
<a id="glink5" href="http://www.sun.com/training/">Training</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip6"></td><td class="navlinks" id="navlink6">
<div>
<a id="glink6" href="http://research.sun.com/">Research</a>
</div>
</td>
</tr>
</table>
</div>

</div></div></div></div>
</div>
<!-- END A2 COMPONENT V.0 -->

<!-- BEGIN BREADCRUMB -->
<div id="breadcrumb">
<?GenHTML ReferencePage >Solaris Dynamic Tracing Guide<?GenHTML /ReferencePage>
</div><br />
<!-- END BREADCRUMB -->

<!-- BEGIN WRAPPER TABLE, 1 COLUMN, MAIN -->
<table border="0" cellpadding="0" cellspacing="10" width="100%">
<tr valign="bottom"><td width="100%" valign="top">
<!-- BEGIN CENTRAL COLUMN COMPONENTS -->

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr><td colspan="5"></td></tr>
<tr>
<td></td>
<td style="width: 60%">&nbsp;</td>
<td><a href="p4.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p6.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->

</td></tr>
<tr><td width="100%" valign="top">
<a name="skip2content"> </a>

<!--startindex-->
<div class="maincontent">
<a name="chp-intro"></a>Chapter&nbsp;1<h3>Introduction</h3><p>Welcome to Dynamic Tracing in the Solaris Operating System! If you have ever wanted to understand the behavior of your system, DTrace is the tool for you. DTrace is a comprehensive dynamic tracing facility that is built into Solaris that can be used by administrators and developers on live production systems to examine the behavior of both user programs and of the operating system itself. DTrace enables you to explore your system to understand how it works, track down performance problems across many layers of software, or locate the cause of aberrant behavior. As you'll see, DTrace lets you create your own custom programs to dynamically instrument the system and provide immediate, concise answers to arbitrary questions you can formulate using the DTrace D programming language. The first section of this chapter provides a quick introduction to DTrace and shows you how to write your very first D program. The rest of the chapter introduces the complete set of rules for programming in D as well as tips and techniques for performing in-depth analysis of your system. You can share your DTrace experiences and scripts with the rest of the DTrace community on the web at <a href="http://www.sun.com/bigadmin/content/dtrace/">http://www.sun.com/bigadmin/content/dtrace/</a>. All of the example scripts presented in this guide can be found on your Solaris system in the directory <tt>/usr/demo/dtrace</tt>.</p>
<a name="chp-intro-1"></a><h3>Getting Started</h3>
<p>DTrace helps you understand a software system by enabling you to dynamically modify the operating system kernel and user processes to record additional data that you specify at locations of interest, called probes. A probe is a location or activity to which DTrace can bind a request to perform a set of actions, like recording a stack trace, a timestamp, or the argument to a function. Probes are like programmable sensors scattered all over your Solaris system in interesting places. If you want to figure out what's going on, you use DTrace to program the appropriate sensors to record the information that is of interest to you. Then, as each probe fires, DTrace gathers the data from your probes and reports it back to you. If you don't specify any actions for a probe, DTrace will just take note of each time the probe fires.</p>
<p>Every probe in DTrace has two names: a unique integer ID and a human-readable string name. We're going to start learning DTrace by building some very simple requests using the probe named <tt>BEGIN</tt>, which fires once each time you start a new tracing request. You can use the <tt>dtrace</tt>(1M) utility's <tt>-n</tt> option to enable a probe using its string name. Type the following command:</p>
<pre><tt><b># dtrace -n BEGIN</b></tt></pre><p>After a brief pause, you will see DTrace tell you that one probe was enabled and you will see a line of output indicating that the <tt>BEGIN</tt> probe fired. Once you see this output, <tt>dtrace</tt> remains paused waiting for other probes to fire. Since you haven't enabled any other probes and <tt>BEGIN</tt> only fires once, press Control-C in your shell to exit <tt>dtrace</tt> and return to your shell prompt:</p>
<pre><tt><b># dtrace -n BEGIN</b></tt>
dtrace: description 'BEGIN' matched 1 probe
CPU     ID		      FUNCTION:NAME
  0      1                  :BEGIN
<tt><b>^C</b></tt>
#</pre><p>The output tells you that the probe named <tt>BEGIN</tt> fired once and both its name and integer ID, 1, are printed. Notice that by default, the integer name of the CPU on which this probe fired is displayed. In this example, the CPU column indicates that the <tt>dtrace</tt> command was executing on CPU 0 when the probe fired.</p>
<p>You can construct DTrace requests using arbitrary numbers of probes and actions. Let's create a simple request using two probes by adding the <tt>END</tt> probe to the previous example command. The <tt>END</tt> probe fires once when tracing is completed. Type the following command, and then again press Control-C in your shell after you see the line of output for the <tt>BEGIN</tt> probe:</p>
<pre><tt><b># dtrace -n BEGIN -n END</b></tt>
dtrace: description 'BEGIN' matched 1 probe
dtrace: description 'END' matched 1 probe
CPU     ID		      FUNCTION:NAME
  0      1                  :BEGIN
<tt><b>^C</b></tt>
  0      2                    :END
#</pre><p>As you can see, pressing Control-C to exit <tt>dtrace</tt> triggers the <tt>END</tt> probe. <tt>dtrace</tt> reports this probe firing before exiting.</p>
<p>Now that you understand a little bit about naming and enabling probes, you're ready to write the DTrace version of everyone's first program, &ldquo;Hello, World.&rdquo; In addition to constructing DTrace experiments on the command line, you can also write them in text files using the D programming language. In a text editor, create a new file called <tt>hello.d</tt> and type in your first D program:</p>
<a name="ex-hello.d"></a>Example 1-1 <tt>hello.d</tt>: Hello, World from the D Programming Language<pre>BEGIN
{
	trace("hello, world");
	exit(0);
}</pre><p>After you have saved your program, you can run it using the <tt>dtrace</tt> <tt>-s</tt> option. Type the following command:</p>
<pre><tt><b># dtrace -s hello.d</b></tt>
dtrace: script 'hello.d' matched 1 probe
CPU     ID		      FUNCTION:NAME
  0	    1                  :BEGIN   hello, world
#</pre><p>As you can see, <tt>dtrace</tt> printed the same output as before followed by the text &ldquo;hello, world&rdquo;. Unlike the previous example, you did not have to wait and press Control-C, either. These changes were the result of the actions you specified for your <tt>BEGIN</tt> probe in <tt>hello.d</tt>. Let's explore the structure of your D program in more detail in order to understand what happened.</p>
<p>Each D program consists of a series of clauses, each clause describing one or more probes to enable, and an optional set of actions to perform when the probe fires. The actions are listed as a series of statements enclosed in braces <tt>{ }</tt> following the probe name. Each statement ends with a semicolon (<tt>;</tt>). Your first statement uses the function <tt>trace()</tt> to indicate that DTrace should record the specified argument, the string &ldquo;<tt>hello, world</tt>&rdquo;, when the <tt>BEGIN</tt> probe fires, and then print it out. The second statement uses the function <tt>exit()</tt> to indicate that DTrace should cease tracing and exit the <tt>dtrace</tt> command. DTrace provides a set of useful functions like <tt>trace()</tt> and <tt>exit()</tt> for you to call in your D programs. To call a function, you specify its name followed by a parenthesized list of arguments. The complete set of D functions is described in <a href="p21.html">Chapter&nbsp;10, Actions and Subroutines</a>.</p>
<p>By now, if you're familiar with the C programming language, you've probably realized from the name and our examples that DTrace's D programming language is very similar to C. Indeed, D is derived from a large subset of C combined with a special set of functions and variables to help make tracing easy. You'll learn more about these features in subsequent chapters. If you've written a C program before, you will be able to immediately transfer most of your knowledge to building tracing programs in D. If you've never written a C program before, learning D is still very easy. You will understand all of the syntax by the end of this chapter. But first, let's take a step back from language rules and learn more about how DTrace works, and then we'll return to learning how to build more interesting D programs.</p>
<a name="chp-intro-2"></a><h3>Providers and Probes</h3>
<p>In the preceding examples, you learned to use two simple probes named <tt>BEGIN</tt> and <tt>END</tt>. But where did these probes come from? DTrace probes come from a set of kernel modules called providers, each of which performs a particular kind of instrumentation to create probes. When you use DTrace, each provider is given an opportunity to publish the probes it can provide to the DTrace framework. You can then enable and bind your tracing actions to any of the probes that have been published. To list all of the available probes on your system, type the command:</p>
<pre><tt><b># dtrace -l</b></tt>
  ID   PROVIDER            MODULE          FUNCTION NAME
   1     dtrace                                     BEGIN
   2     dtrace                                     END
   3     dtrace                                     ERROR
   4   lockstat           genunix       mutex_enter adaptive-acquire
   5   lockstat           genunix       mutex_enter adaptive-block
   6   lockstat           genunix       mutex_enter adaptive-spin
   7   lockstat           genunix       mutex_exit  adaptive-release

   ... many lines of output omitted ...

#</pre><p>It might take some time to display all of the output. To count up all your probes, you can type the command:</p>
<pre><tt><b># dtrace -l | wc -l</b></tt>
        30122</pre><p>You might observe a different total on your machine, as the number of probes varies depending on your operating platform and the software you have installed. As you can see, there are a very large number of probes available to you so you can peer into every previously dark corner of the system. In fact, even this output isn't the complete list because, as you'll see later, some providers offer the ability to create new probes on-the-fly based on your tracing requests, making the actual number of DTrace probes virtually unlimited.</p>
<p>Now look back at the output from <tt><b>dtrace -l</b></tt> in your terminal window. Notice that each probe has the two names we mentioned earlier, an integer ID and a human-readable name. The human readable name is composed of four parts, shown as separate columns in the <tt>dtrace</tt> output. The four parts of a probe name are:</p>
<table><tr><td><p>Provider</p>
</td><td><p>The name of the DTrace provider that is publishing this probe. The provider name typically corresponds to the name of the DTrace kernel module that performs the instrumentation to enable the probe.</p>
</td></tr>
<tr><td><p>Module</p>
</td><td><p>If this probe corresponds to a specific program location, the name of the module in which the probe is located. This name is either the name of a kernel module or the name of a user library.</p>
</td></tr>
<tr><td><p>Function</p>
</td><td><p>If this probe corresponds to a specific program location, the name of the program function in which the probe is located.</p>
</td></tr>
<tr><td><p>Name</p>
</td><td><p>The final component of the probe name is a name that gives you some idea of the probe's semantic meaning, such as <tt>BEGIN</tt> or <tt>END</tt>.</p>
</td></tr>
</table><p>When writing out the full human-readable name of a probe, write all four parts of the name separated by colons like this:</p>
<p><i>provider</i>:<i>module</i>:<i>function</i>:<i>name</i></p>
<p>Notice that some of the probes in the list do not have a module and function, such as the <tt>BEGIN</tt> and <tt>END</tt> probes used earlier. Some probes leave these two fields blank because these probes do not correspond to any specific instrumented program function or location. Instead, these probes refer to a more abstract concept like the idea of the end of your tracing request. A probe that has a module and function as part of its name is known as an anchored probe, and one that does not is known as unanchored.</p>
<p>By convention, if you do not specify all of the fields of a probe name, then DTrace matches your request to <b>all</b> of the probes that have matching values in the parts of the name that you do specify. In other words, when you used the probe name <tt>BEGIN</tt> earlier, you were actually telling DTrace to match any probe whose name field is <tt>BEGIN</tt>, regardless of the value of the provider, module, and function fields. As it happens, there is only one probe matching that description, so the result is the same. But you now know that the true name of the <tt>BEGIN</tt> probe is <tt>dtrace:::BEGIN</tt>, which indicates that this probe is provided by the DTrace framework itself and is not anchored to any function. Therefore, the <tt>hello.d</tt> program could have been written as follows and would produce the same result:</p>
<pre>dtrace:::BEGIN
{
	trace("hello, world");
	exit(0);
}</pre><p>Now that you understand where probes originate from and how they are named, we're going to learn a little more about what happens when you enable probes and ask DTrace to do something, and then we'll return to our whirlwind tour of D.</p>
<a name="chp-intro-3"></a><h3>Compilation and Instrumentation</h3>
<p>When you write traditional programs in Solaris, you use a compiler to convert your program from source code into object code that you can execute. When you use the <tt>dtrace</tt> command you are invoking the compiler for the D language used earlier to write the <tt>hello.d</tt> program. Once your program is compiled, it is sent into the operating system kernel for execution by DTrace. There the probes that are named in your program are enabled and the corresponding provider performs whatever instrumentation is needed to activate them.</p>
<p>All of the instrumentation in DTrace is completely dynamic: probes are enabled discretely only when you are using them. No instrumented code is present for inactive probes, so your system does not experience any kind of performance degradation when you are not using DTrace. Once your experiment is complete and the <tt>dtrace</tt> command exits, all of the probes you used are automatically disabled and their instrumentation is removed, returning your system to its exact original state. No effective difference exists between a system where DTrace is not active and one where the DTrace software is not installed.</p>
<p>The instrumentation for each probe is performed dynamically on the live running operating system or on user processes you select. The system is not quiesced or paused in any way, and instrumentation code is added only for the probes that you enable. As a result, the probe effect of using DTrace is limited to exactly what you ask DTrace to do: no extraneous data is traced, no one big &ldquo;tracing switch&rdquo; is turned on in the system, and all of the DTrace instrumentation is designed to be as efficient as possible. These features enable you to use DTrace in production to solve real problems in real time.</p>
<p>The DTrace framework also provides support for an arbitrary number of virtual clients. You can run as many simultaneous DTrace experiments and commands as you like, limited only by your system's memory capacity, and the commands all operate independently using the same underlying instrumentation. This same capability also permits any number of distinct users on the system to take advantage of DTrace simultaneously: developers, administrators, and service personnel can all work together or on distinct problems on the same system using DTrace without interfering with one another.</p>
<p>Unlike programs written in C and C++ and similar to programs written in the Java programming language, DTrace D programs are compiled into a safe intermediate form that is used for execution when your probes fire. This intermediate form is validated for safety when your program is first examined by the DTrace kernel software. The DTrace execution environment also handles any run-time errors that might occur during your D program's execution, including dividing by zero, dereferencing invalid memory, and so on, and reports them to you. As a result, you can never construct an unsafe program that would cause DTrace to inadvertently damage the Solaris kernel or one of the processes running on your system. These safety features allow you to use DTrace in a production environment without worrying about crashing or corrupting your system. If you make a programming mistake, DTrace will report your error to you, disable your instrumentation, and you can correct your mistake and try again. The DTrace error reporting and debugging features are described later in this book.</p>
<p>The following diagram shows the different components of the DTrace architecture, including providers, probes, the DTrace kernel software, and the <tt>dtrace</tt> command.</p>
<a name="chapter1-fig-1"></a>Figure 1-1 Overview of the DTrace Architecture and Components<img src="figures/architecture.gif" alt=""></img><p>Now that you understand how DTrace works, let's return to the tour of the D programming language and start writing some more interesting programs.</p>

</div>
<!--stopindex-->

<!-- END CENTRAL COLUMN COMPONENTS -->
</td></tr>

<!-- BEGIN SPACER ROW -->
<tr><td><img src="css/a.gif" width="780" height="1" border="0" alt="" /></td></tr>
<!-- END SPACER ROW -->

<tr><td>

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr valign="bottom">
<td></td>
<td style="width: 60%"></td>
<td><a href="p4.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p6.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->
</td></tr>

</table>
<!-- END WRAPPER TABLE, 1 COLUMN, MAIN -->


<!-- BEGIN A5 COMPONENT V.0 -->
<div class="a5" id="a5v0">
<span class="footerlinks">
<a href="http://www.sun.com/company/">Company Info</a>
<a href="http://www.sun.com/contact/">Contact</a>
<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>
<a href="http://www.sun.com/privacy/">Privacy</a>

<span class="footercopy">Copyright 1994-2007 Sun Microsystems, Inc.</span>
</span>
</div>
<!-- END A5 COMPONENT V.0 -->

</body>
</html>

