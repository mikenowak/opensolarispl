<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "docbook.dtd"[
	<!ENTITY % xinclude SYSTEM "xinclude.mod">
	%xinclude;
]>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" arch="x86" xml:id="hbx86boot-68676">



<title>
GRUB Based Booting (Tasks)</title>
<toc>
<para>Starting with the Solaris 10 1/06 and the Solaris Express
6/05 releases, the open source GNU GRand Unified Bootloader
(GRUB) has been implemented on x86 based systems that are running the Solaris
OS. GRUB is the boot loader that is responsible for loading a boot archive
into a system's memory. The boot archive contains the kernel modules and configuration
files that are required to boot the system. For more information on GRUB,
see the <olink remap="external" targetdoc="819-2252" targetptr="grub-5">
<citerefentry>
<refentrytitle>grub</refentrytitle>
<manvolnum>
5
</manvolnum>
</citerefentry>
</olink> man
page.</para>
<note>

<para>GNU is a recursive acronym for “GNU's Not UNIX”. You
can find more information at <link remap="" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:type="url" xlink:href="http://www.gnu.org">
</link>.</para>
</note>
<para>The following is list of the overview information in this chapter.</para>
<itemizedlist>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="gcfos">What's New or Changed in GRUB Based Booting?</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvbsc">
GRUB Based Booting (Overview)</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvbsg">
How GRUB Based Booting Works</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="gbxeh">Changes to the Solaris OS Installation Process</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvbsh">
GRUB Device Naming Conventions</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvbsp">
Functional Components of GRUB</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvbsi">
GRUB Menu</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwbee">
Modifying Boot Behavior in the Solaris OS</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvjbs">
GRUB Based Disk Boot</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvjch">
GRUB Based Booting From the Network</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="grubterm">GRUB Terminology</olink>
</para>
</listitem>
</itemizedlist>
<para>For information about the procedures that are associated with using
GRUB to boot an x86 based system, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvixu">
GRUB Based Booting (Task Map)</olink>. For GRUB reference information, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwamf">
The GRUB Based Boot Process (Reference)</olink>.</para>
<para>For information about the procedures that are associated with booting
an x86 based system that does <emphasis>not</emphasis> implement GRUB, see <olink remap="external" targetdoc="chapter-12.xml" targetptr="hbx86boot-75">
Booting a System (Task Map)</olink>.</para>
<para>For overview information about the boot process, see <olink remap="external" targetdoc="chapter-8.xml" targetptr="hboverview-25463">Chapter 8, Shutting Down and Booting a System (Overview)</olink>. For step-by-step instructions on booting a SPARC based
system, see <olink remap="external" targetdoc="chapter-10.xml" targetptr="hbsparcboot-79782">Chapter 10, Booting a System (Tasks)</olink>.</para>
<para>For more information about changes to the Solaris installation process
on x86 based systems, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="gbxeh">Changes to the Solaris OS Installation Process</olink> and the following references:</para>
<itemizedlist>
<listitem>
<para>If you are installing with the Solaris interactive installation
program, see <olink remap="external" targetdoc="819-2393">
<citetitle remap="book">Solaris Express Installation Guide: Basic Installations</citetitle>
</olink>.</para>
</listitem>
<listitem>
<para>If you are installing with the custom JumpStart program, see <olink remap="external" targetdoc="819-2396">
<citetitle remap="book">Solaris Express Installation Guide: Custom JumpStart and Advanced Installations</citetitle>
</olink>.</para>
</listitem>
<listitem>
<para>If you need to set up an install server to install over the
network, see <olink remap="external" targetdoc="819-2394">
<citetitle remap="book">Solaris Express Installation Guide: Network-Based Installations</citetitle>
</olink>.</para>
</listitem>
</itemizedlist>
</toc>
<sect1 xml:id="gcfos">
<title>What's New or Changed in GRUB Based Booting?</title>
<para>
<emphasis role="strong">Solaris Express 3/06:</emphasis> In this Solaris release,
the GRUB failsafe interaction has changed. Previously, when you booted the
failsafe archive, you were prompted to update the boot archives, regardless
of whether any boot archives were out-of-date. Now, the system prompts you
to update only boot archives that are out-of-date. See <olink remap="internal" targetdoc="chapter-11.xml" targetptr="gcbof">Example 11–8</olink> for an example.</para>
<para>For an example of the previous GRUB failsafe interaction, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="failsafe-s10" type="custom-text">Booting the Failsafe Archive for
Recovery Purposes to Repair a Critical System Resource</olink>.</para>
</sect1>
<sect1 arch="x86" xml:id="fvbsc">
<title>
GRUB Based Booting (Overview)</title>
<indexterm xml:id="indexterm-120">
<primary>GRUB based booting</primary>
<secondary>(Overview)</secondary>
</indexterm>
<indexterm xml:id="indexterm-121">
<primary>(Overview)</primary>
<secondary>GRUB based booting</secondary>
</indexterm>
<indexterm xml:id="indexterm-122">
<primary>boot loader</primary>
<secondary>GRUB</secondary>
</indexterm>
<para>In this Solaris release, GRUB is the open source boot loader that is
the default for x86 based systems.</para>
<note>

<para>GRUB based booting is not available on SPARC based systems in
this Solaris release.</para>
</note>
<para>The <emphasis>boot loader</emphasis> is the first software program that
runs after you turn on a system. This program begins the boot process. After
an x86 based system is powered on, the Basic Input/Output System (BIOS) initializes
the CPU, the memory, and the platform hardware. When the initialization phase
has completed, the BIOS loads the boot loader from the configured boot device,
and then gives control of the system to the boot loader.</para>
<para>GRUB implements a simple menu interface that includes boot options that
are predefined in a configuration file. GRUB also has a command-line interface
that is accessible from the menu interface for performing various boot commands.
The GRUB implementation on x86 based systems in the Solaris OS is compliant
with the Multiboot Specification, which is described in detail at <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:type="url" xlink:href="http://www.gnu.org/software/grub/grub.html">
</link>.</para>
<para>Because the Solaris kernel is fully compliant with the Multiboot Specification,
you can boot x86 based systems by using GRUB. With GRUB, you can more easily
boot the various operating systems that are installed on your system. For
example, on one x86 based system, you could individually boot the following
operating systems:</para>
<itemizedlist>
<listitem>
<para>Solaris OS</para>
</listitem>
<listitem>
<para>Linux</para>
</listitem>
<listitem>
<para>Microsoft Windows</para>
</listitem>
</itemizedlist>
<note>

<para>GRUB detects Microsoft Windows partitions but does not verify
that the OS can be booted.</para>
</note>
<para>Because GRUB is intuitive about file systems and kernel executable formats,
you can load an operating system without recording the physical position of
the kernel on the disk. With GRUB based booting, the kernel is loaded by specifying
its file name, and the drive, and the partition where the kernel resides.</para>
<para>When you boot an x86 based system, the GRUB menu is displayed. This
menu provides a list of boot entries to choose from. A <emphasis>boot entry</emphasis> is
an OS instance that is installed on your system. The GRUB main menu is based
on a configuration file that you can modify. </para>
<itemizedlist>
<listitem>
<para>If you install or upgrade the Solaris OS, the GRUB menu is
 automatically updated. The Solaris OS is displayed as a new boot entry.</para>
</listitem>
<listitem>
<para>If you install an operating system other than the Solaris
OS,  you must modify the <filename>menu.lst</filename> configuration file
to include the  new OS instance. Adding the new OS instance enables the new
boot entry to appear in the GRUB menu the next time that you boot the system.</para>
<para>See the section, <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvbsi">
GRUB Menu</olink> for more
information.</para>
</listitem>
</itemizedlist>
<note>

<para>In this release, the GRUB menu replaces the Solaris Device Configuration
Assistant.</para>
</note>
<sect2 arch="x86" xml:id="fvbsg">
<title>
How GRUB Based Booting Works</title>
<indexterm xml:id="indexterm-123">
<primary>GRUB based booting</primary>
<secondary>how it works</secondary>
</indexterm>
<indexterm xml:id="indexterm-124">
<primary>how GRUB based booting works</primary>
</indexterm>
<para>After GRUB gains control of the system, a menu is displayed on the console.
In the GRUB main menu, you can do the following:</para>
<itemizedlist>
<listitem>
<para>Select a boot entry.</para>
</listitem>
<listitem>
<para>Modify a boot entry by using the GRUB edit menu.</para>
</listitem>
<listitem>
<para>Load an OS kernel from the command line manually.</para>
</listitem>
</itemizedlist>
<para>The following is a sample of a typical GRUB main menu. This menu consists
of two boot entries to choose from. If you do not choose an entry, the system
boots the default OS. The default OS is usually the first entry that is displayed
in the GRUB main menu.<indexterm xml:id="indexterm-125">
<primary>GRUB default menu</primary>
<secondary>default</secondary>
</indexterm>
<indexterm xml:id="indexterm-126">
<primary>menu</primary>
<secondary>GRUB</secondary>
<tertiary>default</tertiary>
</indexterm>
<indexterm xml:id="indexterm-127">
<primary>default GRUB menu</primary>
</indexterm>
</para>
<screen>GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)
 +-------------------------------------------------------------------------+
 | Solaris 10.1 ... X86                                                    |
 | Solaris failsafe                                                        |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press enter to boot the selected OS, 'e' to edit the
      commands before booting, or 'c' for a command-line.</screen>
<para>Use the arrows keys to highlight a boot entry, then press Enter to boot
the selected entry. If you want to edit a boot entry by using the GRUB edit
menu, use the arrow keys to highlight a boot entry in the GRUB main menu.
Then, type <command>e</command> to display the GRUB edit menu. If you want
to use the command-line interface, use the arrow keys to select a boot entry
in the GRUB main menu, then type <command>c</command>.</para>
<para>For a complete list of GRUB terms and definitions, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="grubterm">GRUB Terminology</olink>.</para>
<para>A configurable timeout is available to boot the default OS entry. Press
any key to abort the default OS entry boot.</para>
<para>When the system is booted, GRUB loads the primary boot archive and the
multiboot program. The primary boot archive is a ram image of the file system
that contains the Solaris kernel modules and data. See <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwazj">
Management of the GRUB Boot Archive</olink> for more information. GRUB puts this information
in memory, without any interpretations. The multiboot program is an <command>ELF32</command> executable that contains a multiboot-compliant header. After the
operation has completed, GRUB gives control of the system to the multiboot
program. GRUB itself then becomes inactive, and system memory is reclaimed.</para>
<para>By reading the boot archive and passing boot-related information to
the kernel, the multiboot program is responsible for assembling core kernel
modules into memory. The boot-related information is specified by the Multiboot
Specification.</para>
<note>

<para>The multiboot program works together with the boot archive. You
cannot combine the use of a multiboot program from one OS instance with the
boot archive from another OS instance.</para>
</note>
<para>For more information, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwazd">
Solaris Kernel Initialization Process in the GRUB Boot Environment</olink>.</para>
</sect2>
<sect2 xml:id="gbxeh">
<title>Changes to the Solaris OS Installation Process</title>
<para>
<emphasis role="strong">Solaris 10 1/06:</emphasis> The Solaris installation
process has changed in the following ways:</para>
<itemizedlist>
<listitem>
<para>
<emphasis role="strong">Minimum memory requirements</emphasis> –
To support GRUB, x86 based systems must have at least 256 MBytes of main memory
to boot the install miniroot. On systems with insufficient memory, the following
message is displayed:</para>
<screen>Selected item can not fit in memory</screen>
</listitem>
<listitem>
<para>
<emphasis role="strong">USB drive support</emphasis> –
Installation from CD and DVD drives that are connected through USB interfaces
is now fully supported.</para>
</listitem>
<listitem>
<para>
<emphasis role="strong">Network installation procedure</emphasis> –
The standard procedure for setting up net install images for x86 based systems
remains the same. These systems boot with the Preboot eXecution Environment
(PXE) mechanism. Systems that are not capable of a PXE boot can use a GRUB
floppy.</para>
</listitem>
<listitem>
<para>
<emphasis role="strong">Configuring devices</emphasis> –
The GRUB menu replaces the Device Configuration Assistant in this Solaris
release. After GRUB loads the Solaris OS, the following installation menu
is displayed:</para>
<screen>Select the type of installation you want to perform:

1 Solaris Interactive
2 Custom JumpStart
3 Solaris Interactive Text (Desktop session)
4 Solaris Interactive Text (Console session)
5 Apply driver updates
6 Single user shell

Enter the number of your choice followed by the &lt;ENTER&gt; key.
Alternatively, enter custom boot arguments directly.

If you wait 30 seconds without typing anything,
an interactive installation will be started.</screen>
<note>

<para>The Device Configuration Assistant and the associated interactive
shell is no longer available, starting with the Solaris 10 1/06 release. To
add any required drivers during the installation process, select Option 5.</para>
</note>
<para>Note that you must supply an Install Time Update (ITU) floppy diskette,
CD, or DVD when applying driver updates during the installation process. The
ITU will likely contain a package, but it also might contain a patch.  When
adding the contents of an ITU image, check the README file for additional
instructions.</para>
<para>To add drivers to the miniroot during installation,
follow the steps for patching the x86 miniroot. For step-by-step instructions,
see the following documentation:</para>
<itemizedlist>
<listitem>
<para>For DVD media, see <olink remap="external" targetdoc="819-2394" targetptr="netinstall-104">
<citetitle remap="section">To Create an x86 Install Server With SPARC or x86 DVD Media</citetitle> in <citetitle remap="book">Solaris Express Installation Guide: Network-Based Installations</citetitle>
</olink>,
Step 9. </para>
</listitem>
<listitem>
<para> For CD media, see <olink remap="external" targetdoc="819-2394" targetptr="netinstallcd-iaia">
<citetitle remap="section">Creating an x86 Install Server With CD Media</citetitle> in <citetitle remap="book">Solaris Express Installation Guide: Network-Based Installations</citetitle>
</olink>, Step
19. </para>
</listitem>
</itemizedlist>
<para>Option 6 is available for system recovery. This option provides quick
access to a root prompt without having to go through the system identification
process. Note that option 6 is identical to booting the Solaris failsafe archive
option from the GRUB main menu that is displayed when the system is booted.</para>
</listitem>
</itemizedlist>
</sect2>
<sect2 arch="x86" xml:id="fvbsh">
<title>
GRUB Device Naming Conventions</title>
<indexterm xml:id="indexterm-128">
<primary>GRUB device naming conventions</primary>
</indexterm>
<indexterm xml:id="indexterm-129">
<primary>naming conventions for devices</primary>
<secondary>in GRUB</secondary>
</indexterm>
<indexterm xml:id="indexterm-130">
<primary>device naming conventions</primary>
<secondary>in GRUB</secondary>
</indexterm>
<para>GRUB uses device naming conventions that are slightly different from
previous Solaris OS versions. Understanding the GRUB device naming conventions
can assist you in correctly specifying drive and partition information when
you configure GRUB on your system.</para>
<para>The following table describes the GRUB device naming conventions.</para>
<table frame="all" xml:id="fvbsm">

<title>Naming Conventions for GRUB Devices</title>
<tgroup cols="2" colsep="1" rowsep="1">
<colspec colwidth="50*"/>
<colspec colwidth="50*"/>
<thead>
<row>
<entry>
<para>Device Name</para>
</entry>
<entry>
<para>Description</para>
</entry>
</row>
</thead>
<tbody>
<row>
<entry>
<para>(<literal>fd0</literal>), (<literal>fd1</literal>)</para>
</entry>
<entry>
<para>First diskette, second diskette</para>
</entry>
</row>
<row>
<entry>
<para>(<literal>nd</literal>)</para>
</entry>
<entry>
<para>Network device</para>
</entry>
</row>
<row>
<entry>
<para>(<literal>hd0,0</literal>), (<literal>hd0,1</literal>)</para>
</entry>
<entry>
<para>First and second <filename>fdisk</filename> partition of first <filename>bios</filename> disk</para>
</entry>
</row>
<row>
<entry>
<para>
<literal>(hd0,0,a</literal>), (<literal>hd0,0,b</literal>)</para>
</entry>
<entry>
<para>Solaris/BSD slice 0 and 1 on first <filename>fdisk</filename> partition
on the first <filename>bios</filename> disk</para>
</entry>
</row>
</tbody>
</tgroup>
</table>
<note>

<para>All GRUB device names must be enclosed in parentheses. Partition
numbers are counted from 0 (zero), not from 1.</para>
</note>
<para>For more information about <literal>fdisk</literal> partitions, see <olink remap="external" targetdoc="819-2723" targetptr="disksxadd-54639">
<citetitle remap="section">Guidelines for Creating an fdisk Partition</citetitle> in <citetitle remap="book">System Administration Guide: Devices and File Systems</citetitle>
</olink>.</para>
</sect2>
<sect2 arch="x86" xml:id="fvbsp">
<title>
Functional Components of GRUB</title>
<indexterm xml:id="indexterm-131">
<primary>GRUB functional components</primary>
</indexterm>
<indexterm xml:id="indexterm-132">
<primary>components of GRUB</primary>
</indexterm>
<indexterm xml:id="indexterm-133">
<primary>functional components of GRUB</primary>
</indexterm>
<indexterm xml:id="indexterm-134">
<primary>
<filename>stage2</filename>
</primary>
<secondary>GRUB component</secondary>
</indexterm>
<indexterm xml:id="indexterm-135">
<primary>
<filename>menu.1st</filename>
</primary>
<secondary>GRUB component</secondary>
</indexterm>
<para>GRUB consists of the following functional components:</para>
<itemizedlist>
<listitem>
<para>
<filename>stage1</filename> – Is installed on the first
sector of the Solaris <filename>fdisk</filename> partition. You can optionally
install <filename>stage1</filename> on the master boot sector by specifying
the <option>
m</option> option with the <command>installgrub</command> command.
See the <olink remap="external" targetdoc="819-2240" targetptr="installgrub-1m">
<citerefentry>
<refentrytitle>installgrub</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man page and <olink remap="external" targetdoc="819-2723" targetptr="gbehx">
<citetitle remap="section">Disk Management in the GRUB Boot Environment</citetitle> in <citetitle remap="book">System Administration Guide: Devices and File Systems</citetitle>
</olink> for
more information.</para>
</listitem>
<listitem>
<para>
<filename>stage2</filename> – Is installed in a reserved
area in the Solaris <filename>fdisk</filename> partition. <filename>stage2</filename> is
the core image of GRUB.</para>
</listitem>
<listitem>
<para>
<filename>menu.lst</filename> – Is a file that is typically
located in the <filename>/boot/grub</filename> directory. This file is read
by the GRUB <filename>stage2</filename> file. See the section, <olink remap="internal" targetdoc="chapter-11.xml" targetptr="grubterm">GRUB Terminology</olink> for more information.</para>
</listitem>
</itemizedlist>
<para>You cannot use the <command>dd</command> command to write <filename>stage1</filename> and <filename>stage2</filename> to disk. <filename>stage1</filename> must be able to receive
information about the location of <filename>stage2</filename> on the disk.
Use the <command>installgrub</command> command, which is the supported method
for installing GRUB boot blocks.</para>
</sect2>
<sect2 arch="x86" xml:id="fvbsi">
<title>
GRUB Menu</title>
<indexterm xml:id="indexterm-136">
<primary>menu</primary>
<secondary>GRUB</secondary>
<tertiary>description of</tertiary>
</indexterm>
<indexterm xml:id="indexterm-137">
<primary>GRUB menu</primary>
<secondary>description of</secondary>
</indexterm>
<para>By default, the Solaris menu file resides in <filename>/boot/grub/menu.lst</filename>.
If the Solaris OS is booted from a <literal>pcfs</literal> partition, the
effective menu is then loaded from the <filename>/stubboot/boot/grub/menu.lst</filename> file.
You might also get the same configuration when performing a software upgrade.
The contents of this file dictate what is displayed in the GRUB menu when
you boot the system. The GRUB menu file contains entries for all the OS instances
that are installed on your system, as well as other important boot directives.
 See <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fxjig">
How Multiple Operating Systems Are Supported in the GRUB Boot Environment</olink>. </para>
<note>

<para>In
some situations, the GRUB <filename>menu.lst</filename> file resides elsewhere.
For example, if you upgrade your system, the GRUB <filename>menu.lst</filename> file
might exist on a boot environment that is not the currently running boot environment.
Or, if you have upgraded a system with an x86 based boot partition, the <filename>menu.lst</filename> file might reside in the <filename>/stubboot</filename> directory.</para>
<para>Only the active GRUB <filename>menu.lst</filename> file is used
to boot the system.  In order to modify the GRUB menu that is displayed when
you boot the system, the active GRUB  <filename>menu.lst</filename> file must
be modified. Changing any other GRUB <filename>menu.lst</filename> file has
no effect on the menu that is displayed when you boot the system.</para>
<para>To
determine the location of the active GRUB <filename>menu.lst</filename> file,
use the <command>bootadm</command> command.  The <command>list-menu</command> subcommand
displays the location of the active GRUB menu. For more information, see  the <olink remap="external" targetdoc="819-2240" targetptr="bootadm-1m">
<citerefentry>
<refentrytitle>bootadm</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man
page.</para>
</note>
<para>You might need to customize the <filename>menu.lst</filename> file for
one of the following reasons:</para>
<itemizedlist>
<listitem>
<para>To add new OS entries</para>
</listitem>
<listitem>
<para>To add GRUB console redirection information</para>
</listitem>
</itemizedlist>
<para>The instructions for the syntax to use to edit the file can be found
in the <filename>/boot/grub/menu.lst</filename> file comments.  Because these
changes are not directly related to the Solaris OS, you cannot make them by
using the <command>eeprom</command> command. The Solaris software upgrade
process preserves any changes that you make to this file.</para>
<para>The following is a partial sample of the <filename>/boot/grub/menu.lst</filename> file.
The list that follows includes a description of the line entries.</para>
<screen>default 0
timeout 10
.
.
.

title Solaris
  root (hd0,0,a)
  kernel /platform/i86pc/multiboot -B console=ttya
  module /platform/i86pc/boot_archive
title Solaris (test)
  root (hd0,0,a)
  kernel /boot/grub/multiboot -B console=ttya
  module /platform/i86pc/boot_archive
title Solaris fail-safe single user
  root (hd0,0,a)
  kernel /boot/multiboot -B console=ttya -s
  module /boot/x86.miniroot.safe</screen>
<variablelist>
<varlistentry>
<term>
<literal>title</literal> <replaceable>OS name</replaceable>
</term>
<listitem>
<para>Specifies the name of the operating system.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>default 0</literal>
</term>
<listitem>
<para>Specifies which item to boot, if the timeout expires.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>timeout 10</literal>
</term>
<listitem>
<para>Specifies the number of seconds to wait for user input before
booting the default entry. If no timeout is specified, you are required to
choose an entry.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>serial --unit=0 --speed=9600</literal>
</term>
<listitem>
<para>Switches the GRUB output to the tip line. Works in conjunction
with the <command>terminal</command> command.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>terminal serial</literal>
</term>
<listitem>
<para>Switches the GRUB output to the tip line. Works in conjunction
with the <command>serial</command> command.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>root (hd0,0,a)</literal>
</term>
<listitem>
<para>Specifies on which disk, which partition, and which slice
to load the files. GRUB automatically detects the file system type.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>kernel /platform/i86pc/multiboot -B console=ttya</literal>
</term>
<listitem>
<para>Specifies the multiboot program. The <command>kernel</command> command
must always be followed by the multiboot program. The string after multiboot
is passed to the Solaris OS without interpretation.</para>
</listitem>
</varlistentry>
</variablelist>
<para>Any changes that you make to the file take effect at the next system
reboot.</para>
</sect2>
<sect2 arch="x86" xml:id="fwbee">
<title>
Modifying Boot Behavior in the Solaris
OS</title>
<indexterm xml:id="indexterm-138">
<primary>modifying Solaris boot behavior</primary>
</indexterm>
<indexterm xml:id="indexterm-139">
<primary>Solaris boot behavior</primary>
<secondary>modifying</secondary>
</indexterm>
<indexterm xml:id="indexterm-140">
<primary>boot behavior</primary>
<secondary>modifying</secondary>
</indexterm>
<indexterm xml:id="indexterm-141">
<primary>
<command>eeprom</command> command</primary>
<secondary>modifying Solaris boot behavior</secondary>
</indexterm>
<indexterm xml:id="indexterm-142">
<primary>modifying Solaris boot behavior</primary>
<secondary>
<command>kernel</command> command</secondary>
<tertiary>GRUB</tertiary>
</indexterm>
<para>The primary methods for modifying boot behavior in the Solaris OS are
as follows:</para>
<itemizedlist>
<listitem>
<para>By using the <command>eeprom</command> command.</para>
<para>The <command>eeprom</command> command is used to assign a different value to a standard
set of properties. These values, which are the equivalent to the SPARC OpenBoot
PROM NVRAM variables, are stored in the <filename>/boot/solaris/bootenv.rc</filename> file.
Changes that are made to the Solaris boot behavior by using the <command>eeprom</command> command
persist over each system reboot. See the <olink remap="external" targetdoc="819-2240" targetptr="eeprom-1m">
<citerefentry>
<refentrytitle>eeprom</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man page for more information.</para>
</listitem>
<listitem>
<para>By using the <command>kernel</command> command, which is available
in the GRUB menu when the system is booted.</para>
<note>

<para>Changes that are made with the <command>kernel</command> command
override options that you set by using the <command>eeprom</command> command.
These changes remain in effect until the next time you boot the system. See
the <olink remap="external" targetdoc="819-2240" targetptr="kernel-1m">
<citerefentry>
<refentrytitle>kernel</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man
page for more information.</para>
</note>
</listitem>
</itemizedlist>
<para>You can also modify the Solaris boot behavior in the GRUB <filename>menu.lst</filename> file, similarly to how you would use the <command>eeprom</command> command.
However, this method is not preferred, because the Solaris OS entries in the <filename>menu.lst</filename> file could be modified during a software upgrade. In this
instance, any changes that you made to the file are lost. In contrast, changes
made by using the <command>eeprom</command> command are added to the <filename>/boot/solaris/bootenv.rc</filename> file. This file is handled properly during an upgrade.</para>
<para>For instructions, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwbqs">
Modifying the Solaris Boot Behavior by Editing the GRUB Menu</olink>.</para>
</sect2>
<sect2 arch="x86" xml:id="fvjbs">
<title>
GRUB Based Disk Boot</title>
<indexterm xml:id="indexterm-143">
<primary>GRUB based disk boot</primary>
</indexterm>
<indexterm xml:id="indexterm-144">
<primary>booting from disk with GRUB</primary>
</indexterm>
<indexterm xml:id="indexterm-145">
<primary>disk boot</primary>
<secondary>GRUB based</secondary>
</indexterm>
<para>When you install the Solaris OS, two GRUB menu entries are installed
on the system by default. The first entry is the Solaris OS entry. The second
entry is the miniroot (failsafe) archive, which is intended to be used for
system recovery. The GRUB menu entries are installed and then updated automatically
as part of the Solaris software installation and upgrade process. These entries
are directly managed by the OS and should not be manually edited. For a detailed
description of these and other GRUB terms, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="grubterm">GRUB Terminology</olink>.</para>
<para>During a standard Solaris OS installation, GRUB is installed on the
Solaris <literal>fdisk</literal> partition, without modifying the system BIOS
setting. If the OS is not on the BIOS boot disk, you need to do one of the
following:</para>
<itemizedlist>
<listitem>
<para>Modify the BIOS setting.</para>
</listitem>
<listitem>
<para>Use a boot manager to bootstrap to the Solaris partition.
For more details, see your boot manager.</para>
</listitem>
</itemizedlist>
<para>The preferred method is to always install the Solaris OS on the boot
disk. If multiple operating systems are installed on the machine, you can
add entries to the <filename>/boot/grub/menu.lst</filename> file. These entries
are then displayed in the GRUB menu the next time that the system is booted.</para>
<para>For additional information, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fxjig">
How Multiple Operating Systems Are Supported in the GRUB Boot Environment</olink>.</para>
</sect2>
<sect2 arch="x86" xml:id="fvjch">
<title>
GRUB Based Booting From the Network</title>
<indexterm xml:id="indexterm-146">
<primary>GRUB based network boot</primary>
</indexterm>
<indexterm xml:id="indexterm-147">
<primary>network boot</primary>
<secondary>with GRUB</secondary>
</indexterm>
<indexterm xml:id="indexterm-148">
<primary>booting from the network with GRUB</primary>
</indexterm>
<indexterm xml:id="indexterm-149">
<primary>
<literal>PXEClient</literal>
</primary>
<secondary>GRUB based network boot</secondary>
</indexterm>
<indexterm xml:id="indexterm-150">
<primary>
<literal>GRUBClient</literal>
</primary>
<secondary>GRUB based network boot</secondary>
</indexterm>
<para>This section describes the requirements and warnings for performing
a GRUB based boot from the network. For overview information and additional
details on booting an x86 based system from the network, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvjch">
GRUB Based Booting From the Network</olink>.</para>
<para>To perform a GRUB based network boot, a DHCP server that is configured
for PXE clients is required. A boot server that provides <command>tftp</command> service
is also required. The DHCP server supplies the information that the client
needs to configure its network interface. The DHCP server must be able to
respond to the DHCP classes, <literal>PXEClient</literal> and <literal>GRUBClient</literal> with the following information:</para>
<itemizedlist>
<listitem>
<para>IP address of the file server</para>
</listitem>
<listitem>
<para>Name of the boot file (<command>pxegrub</command>)</para>
</listitem>
</itemizedlist>
<para>The file server is responsible for providing the following:</para>
<itemizedlist>
<listitem>
<para>
<command>pxegrub</command> binary</para>
</listitem>
<listitem>
<para>GRUB menu</para>
</listitem>
<listitem>
<para>Multiboot program</para>
</listitem>
<listitem>
<para>
<filename>x86.miniroot</filename>
</para>
</listitem>
</itemizedlist>
<para>The sequence for performing a PXE network boot of the Solaris OS is
as follows:</para>
<orderedlist>
<listitem>
<para>The BIOS is configured to boot from a network interface.</para>
</listitem>
<listitem>
<para>The BIOS sends a DHCP request.</para>
</listitem>
<listitem>
<para>The DHCP server replies with the server address and the name
of the boot file.</para>
</listitem>
<listitem>
<para>The BIOS downloads <command>pxegrub</command> by using <command>tftp</command> and executes <command>pxegrub</command>.</para>
</listitem>
<listitem>
<para>The system downloads a GRUB menu file by using <command>tftp</command>.</para>
<para>This file displays the boot menu entries that are available.</para>
</listitem>
<listitem>
<para>After you select a menu entry, the system begins to load the
Solaris OS.</para>
</listitem>
</orderedlist>
<para>
<indexterm xml:id="indexterm-151">
<primary>DHCP</primary>
<secondary>configuring a GRUB based PXE boot</secondary>
</indexterm>
<indexterm xml:id="indexterm-152">
<primary>booting from the network with GRUB</primary>
<secondary>DHCP configuration</secondary>
</indexterm>See <olink remap="external" targetdoc="819-3000" targetptr="ipconfig-79">
<citetitle remap="section">How to Set Up a Network Configuration Server</citetitle> in <citetitle remap="book">System Administration Guide: IP Services</citetitle>
</olink> for
more information.</para>
<para>Running the <command>add_install_client</command> command creates the <filename>/tftpboot_01</filename>
<replaceable>ethernet-address</replaceable> file. This
file is linked to <command>pxegrub</command> and the<filename>/tftpboot/menu.lst.01</filename>
<replaceable>ethernet-address</replaceable> file. The <filename>/tftpboot/menu.lst.01</filename>
<replaceable>ethernet-address</replaceable> file is the GRUB menu
file. If this file does not exist, then <command>pxegrub</command> reverts
to using DHCP Option 150, if this option is specified, or the <filename>/tftpboot/boot/grub/menu.lst</filename> file. Typically, a single system is set up to serve both functions.
In this instance, the <command>add_install_client</command> command sets up
the <filename>/tftpboot</filename> file with the correct <filename>pxegrub</filename> menu
file and the Solaris files. DHCP service is handled separately by using the <command>add_install_client</command> command. The setup only needs to be completed
once per client. See <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwfdk">About DHCP Macros</olink> and <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzpk">
How to Perform a GRUB Based Boot From the Network</olink> for
more information.</para>
<note>

<para>The <command>rpc.bootparamd</command> daemon is usually required
on the server side for performing a network boot. However, <command>rpc.bootparamd</command> is <emphasis>not</emphasis> required to perform a network based
boot with GRUB.</para>
</note>
<para>If no PXE or DHCP server is available, you can load GRUB from a diskette,
a CD-ROM, or the local disk. You can then manually configure the network in
GRUB and download the multiboot program and the boot archive from the file
server.</para>
<sect3 xml:id="gcfnx">
<title>PXE Network Boot Sequence</title>
<note>

<para>The <command>rpc.bootparamd</command> daemon is usually required
on the server side for performing a network boot. However, <command>rpc.bootparamd</command> is <emphasis>not</emphasis> required to perform a network based
boot with GRUB.</para>
</note>
<para>If no PXE or DHCP server is available, you can load GRUB from a diskette,
a CD-ROM, or the local disk. You can then manually configure the network in
GRUB and download the multiboot program and the boot archive from the file
server.</para>
</sect3>
</sect2>
<sect2 xml:id="grubterm">
<title>GRUB Terminology</title>
<para>The following GRUB terms are used throughout this documentation. To
grasp GRUB concepts, an understanding of these terms is essential.</para>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">boot archive</emphasis>
</term>
<listitem>
<para>A boot archive is a collection of critical files that is used
to boot the Solaris OS. These files are needed during system startup before
the root (<filename>/</filename>) file system is mounted. Two boot archives
are maintained on a system:</para>
<itemizedlist>
<listitem>
<para>The boot archive that is used to boot the Solaris OS on a
system. This boot archive is sometimes called the primary boot archive.</para>
</listitem>
<listitem>
<para>The boot archive that is used for recovery when the primary
boot archive is damaged. This boot archive starts the system without   mounting
the root (<filename>/</filename>) file system. On the GRUB menu, this boot
archive is called failsafe. The archive's essential purpose is to regenerate
the primary boot archive, which is usually used   to boot the system.</para>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">boot loader</emphasis>
</term>
<listitem>
<para>The boot loader is the first software program that runs after
you turn on a system. This program begins the booting process.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">failsafe archive</emphasis>
</term>
<listitem>
<para>See boot archive.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">GRUB</emphasis>
</term>
<listitem>
<para>GNU GRand Unified Bootloader (GRUB) is an open source boot
loader with a simple menu interface.  The menu displays a list of the operating
systems that are installed on a system. GRUB enables you to easily boot these
various operating systems,  such as the Solaris OS, Linux, or Microsoft Windows.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">GRUB edit menu</emphasis>
</term>
<listitem>
<para>A boot menu that is a submenu of the GRUB main menu. GRUB
commands are displayed on this menu. These commands can be edited to change
 boot behavior.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">GRUB main menu</emphasis>
</term>
<listitem>
<para>A boot menu that lists the operating systems that are installed
 on a system. From this menu, you can easily boot an operating  system without
modifying the BIOS or fdisk partition settings.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<filename>menu.lst</filename> <emphasis role="strong">file</emphasis>
</term>
<listitem>
<para>A file that lists all the operating systems that are installed
on a system.  The contents of this file dictate the list of operating systems
that is displayed on the GRUB menu.  From the GRUB menu, you can easily boot
an operating system without modifying the BIOS or fdisk partition settings.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">miniroot</emphasis>
</term>
<listitem>
<para>A minimal, bootable root (<filename>/</filename>) file system
that resides on the Solaris installation media. A miniroot consists of the
Solaris software that is required to install and upgrade systems. On x86 based
systems, the miniroot is copied to the system to be used as the failsafe boot
archive. See boot archive for details.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">primary boot archive</emphasis>
</term>
<listitem>
<para>See boot archive.</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1>
<sect1 arch="x86" xml:id="fvixu">
<title>
GRUB Based Booting (Task Map)</title>
<informaltable frame="all" pgwide="1">
<tgroup cols="3" colsep="0" rowsep="0">
<colspec colname="column1" colwidth="105.73*"/>
<colspec colname="column2" colwidth="162.35*"/>
<colspec colname="column3" colwidth="127.92*"/>
<thead>
<row rowsep="1">
<entry colsep="1" rowsep="1">
<para>Task</para>
</entry>
<entry colsep="1" rowsep="1">
<para>Description</para>
</entry>
<entry colsep="1" rowsep="1">
<para>For Instructions</para>
</entry>
</row>
</thead>
<tbody>
<row>
<entry colsep="1" rowsep="0">
<para>Boot a system.</para>
</entry>
<entry colsep="1" rowsep="0">
<para>Select one of the following boot options:</para>
</entry>
<entry colsep="1" rowsep="0">
<para>
</para>
</entry>
</row>
<row>
<entry colsep="1" morerows="2" rowsep="1">
</entry>
<entry colsep="1" rowsep="0">
<para>
<emphasis role="strong">Boot to run level 3</emphasis> – Used
after shutting down the system or performing some system hardware maintenance
task. </para>
</entry>
<entry colsep="1" rowsep="0">
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzun">
How to Boot a System to Run Level 3 (Multiuser Level)</olink>
</para>
</entry>
</row>
<row>
<entry colsep="1" rowsep="0">
<para>
<emphasis role="strong">Boot to run level S</emphasis> – Used
after performing a system maintenance task, such as backing up a file system. </para>
</entry>
<entry colsep="1" rowsep="0">
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzqr">
How to Boot a System to Run Level S (Single-User Level)</olink>
</para>
</entry>
</row>
<row>
<entry colsep="1" rowsep="1">
<para>
<emphasis role="strong">Boot interactively</emphasis> – Used after
making temporary changes to a system file or the kernel for testing purposes.</para>
</entry>
<entry colsep="1" rowsep="1">
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzmg">
How to Boot a System Interactively</olink>
</para>
</entry>
</row>
<row>
<entry colsep="1" rowsep="1">
<para>Customize the Solaris boot behavior.</para>
</entry>
<entry colsep="1" rowsep="1">
<para>You can customize the Solaris boot behavior by using the <command>eeprom</command> command
from the command-line. You can also customize the Solaris boot behavior by
using the <command>kernel</command> command that is available in the GRUB
menu. </para>
<para>Boot options that are set by using the <command>eeprom</command> command
persist over a system reboot, unless these options are overridden by the <command>kernel</command> command. Boot options that are set by editing the GRUB menu
or by using the <command>kernel</command> command persist until the next system
reboot.</para>
</entry>
<entry colsep="1" rowsep="1">
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwbon">
How to Set Solaris Boot Parameters by Using the <command>eeprom</command> Command</olink>
</para>
<para>
</para>
<para>
</para>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwbme">
How to Modify the Solaris Boot Behavior by Editing the GRUB Menu</olink>
</para>
</entry>
</row>
<row>
<entry colsep="1" rowsep="1">
<para>Boot a system from the network.</para>
</entry>
<entry colsep="1" rowsep="1">
<para>Used to boot a PXE or non-PXE device from the network with the default
network configuration strategy. This method is used for booting a diskless
client.</para>
</entry>
<entry colsep="1" rowsep="1">
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzpk">
How to Perform a GRUB Based Boot From the Network</olink>
</para>
</entry>
</row>
<row>
<entry colsep="1" morerows="1" rowsep="1">
<para>Boot the system in the failsafe archive for recovery purposes. </para>
</entry>
<entry colsep="1" rowsep="0">
<para>Used to boot the system when a damaged file is preventing the system
from booting normally. You might need to do the following to boot for recovery
purposes:</para>
<itemizedlist>
<listitem>
<para>Stop the system to attempt recovery.</para>
</listitem>
<listitem>
<para>Boot the failsafe archive to update the boot archive or repair
an important system file that is preventing the system from booting successfully.</para>
</listitem>
</itemizedlist>
</entry>
<entry colsep="1" rowsep="0">
<para>
</para>
<para>
</para>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzot">
How to Stop a System for Recovery Purposes</olink>
</para>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvznb">
How to Boot the Failsafe Archive for Recovery Purposes</olink>
</para>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="gcbcn">
How to Boot the Failsafe Archive to Forcibly Update a Corrupt Boot Archive</olink>
</para>
</entry>
</row>
<row>
<entry colsep="1" rowsep="1">
<itemizedlist>
<listitem>
<para>Force a crash dump. Then, reboot the system – Used to
force a crash dump for troubleshooting purposes.</para>
</listitem>
<listitem>
<para>Boot <command>kmdb</command> – Used to troubleshoot
system problems.</para>
</listitem>
</itemizedlist>
<para>Use the <command>reboot</command> and <command>halt</command> command
with the <option>
d</option> option if you do not have time to debug the system
interactively. To run the <command>halt</command> command with the <option>
d</option> option
requires a manual reboot of the system afterwards. Whereas, if you use the <command>reboot</command> command, the system boots automatically. See the <olink remap="external" targetdoc="819-2240" targetptr="reboot-1m">
<citerefentry>
<refentrytitle>reboot</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> for more information.</para>
</entry>
<entry colsep="1" rowsep="1">
<para>
</para>
<para>
</para>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzpo">
Forcing a Crash Dump and Reboot of the System</olink>
</para>
<para>
</para>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvzpl">
How to Boot a System With the Kernel Debugger in the GRUB Based Boot Environment (<command>kmdb</command>)</olink>
</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect1>
<sect1 arch="x86" xml:id="fvzqe">
<title>
Booting a System in the GRUB Based Boot
Environment</title>
<indexterm xml:id="indexterm-153">
<primary>task map</primary>
<secondary>GRUB based booting</secondary>
</indexterm>
<indexterm xml:id="indexterm-154">
<primary>GRUB based booting</primary>
<secondary>Task Map</secondary>
</indexterm>
<para>This section includes new information for performing a GRUB based disk
boot and a GRUB based network boot on an x86 based system. Also included are
instructions for configuring DHCP to perform GRUB based network boots and
how to modify the Solaris boot behavior.</para>
<note>

<para>GRUB based booting is not available on SPARC based systems in
this Solaris release.</para>
</note>
<para>Some of the procedures in this section indicate to use the Reset button
to restart the system. If your system does not have a Reset button, use the
power switch to restart the system. You might be able to press Ctrl-Alt-Del
to interrupt system operation, depending upon the state of the system.</para>
<sect2>
<title/>
<task arch="x86" id="fvzun">

<title>
How to Boot a System to Run Level 3 (Multiuser
Level)</title>
<tasksummary>
<para>Use this procedure to boot a system that is currently at run level 0
to run level 3.</para>
</tasksummary>
<procedure>
<step xml:id="fvzsa">
<para>If the system displays the <literal>Press any key to
reboot</literal> prompt, press any key to reboot the system.</para>
<para>You
can also use the Reset button at this prompt. If the system is shut down,
turn the system on with the power switch.</para>
<para>When the boot sequence
begins, the GRUB menu is displayed.</para>
</step>
<step xml:id="fvzmf">
<para>
<indexterm xml:id="fvzmv">
<primary>run level</primary>
<secondary>3 (multiuser with NFS)</secondary>
<tertiary>booting to</tertiary>
</indexterm>To boot the system to run level 3, press Enter to boot the default
OS instance.</para>
<para>If you do not choose an entry within 10 seconds,
the system automatically boots to run level 3.</para>
</step>
<step xml:id="fvzrw">
<para>Verify that the system has booted to run level 3.</para>
<screen># <userinput>who -r</userinput>
</screen>
<para>The login prompt is displayed when the boot process has finished successfully.</para>
<screen>
<replaceable>hostname</replaceable> console login:</screen>
</step>
</procedure>
<example arch="x86">

<title>
Booting a System to Run Level 3 (Multiuser Level) in the Solaris OS</title>
<indexterm xml:id="indexterm-155">
<primary>booting a system to run level 3 with GRUB</primary>
<secondary>example of</secondary>
</indexterm>
<indexterm xml:id="indexterm-156">
<primary>example of GRUB based booting</primary>
</indexterm>
<indexterm xml:id="indexterm-157">
<primary>GRUB based booting</primary>
<secondary>example of booting a system to run level 3</secondary>
</indexterm>
<para>For new installations of the Solaris OS, the system automatically boots
a 64-bit kernel if the system is 64-bit capable. For upgrade installations,
the system boots a 64-bit kernel, if the system is 64-bit capable. However,
the system does not boot a 64-bit kernel if the <literal>boot-file</literal> parameter
was previously set to a value other than <filename>kernel/unix</filename> with
the <command>eeprom</command> command.</para>
<para>This example shows how to boot an x86 based system that has 64-bit computing
capabilities to run level 3.</para>
<screen width="100">Press any key to reboot.
Resetting...

  GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | Solaris 10.1 ... X86                                                    |
 | Solaris failsafe                                                        |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press enter to boot the selected OS, 'e' to edit the
      commands before booting, or 'c' for a command-line.

     The highlighted entry will be booted automatically in 10 seconds

Booting 'Solaris 10.1  ... X86'

root (hd0,2,a)
 Filesystem type is ufs, partition type 0x000000bf
kernel /platform/i86pc/multiboot
[Multiboot-elf, &lt;0x1000000:0x13f3b:0x3941d&gt;, shtab=0x104e258, entry=0x1000000]
module /platform/i86pc/boot_archive

SunOS Release 5.10.1 Version ... 64-bit
Copyright 1983-2005 Sun Microsystems, Inc.  All rights reserved.
Use is subject to license terms.
Hostname: swoozie.Central.Sun.COM
NIS domain name is boulder.Central.Sun.COM
checking ufs filesystems
/dev/rdsk/c1d0s7: is logging.

swoozie.Central.Sun.COM console login:</screen>
</example>
</task>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fvzqr">

<title>
How to Boot a System to Run Level S (Single-User
Level)</title>
<indexterm xml:id="indexterm-158">
<primary>GRUB based booting</primary>
<secondary>how to boot a system run level S</secondary>
</indexterm>
<indexterm xml:id="indexterm-159">
<primary>how to use GRUB to boot a system to run level s</primary>
</indexterm>
<indexterm xml:id="indexterm-160">
<primary>booting a system to run level S</primary>
<secondary>GRUB based booting</secondary>
<tertiary>how to</tertiary>
</indexterm>
<tasksummary>
<para>Use this procedure to boot a system that is at run level 0 to run level
S. Single-user level is used for performing system maintenance.</para>
</tasksummary>
<procedure>
<step xml:id="fvzos">
<para>If the system displays the <literal>Press any key to
reboot</literal> prompt, press any key to reboot the system.</para>
<para>You
can also use the Reset button at this prompt. If the system is shut down,
turn the system on with the power switch.</para>
<para>When the boot sequence
begins, the GRUB menu is displayed.</para>
</step>
<step xml:id="fvzme">
<para>
<indexterm xml:id="fvzms">
<primary>run level</primary>
<secondary>s or S (single-user level)</secondary>
<tertiary>booting to</tertiary>
</indexterm>To boot the system to run level S, type <command>e</command> when
the GRUB main menu is displayed.</para>
</step>
<step>
<para>Use the arrow keys to choose the <command>kernel /platform/i86pc/multiboot</command> boot entry.</para>
<note>

<para>If you cannot use the arrow keys, use the <literal>^</literal> key
to scroll up and the <literal>v</literal> key to scroll down.</para>
</note>
</step>
<step>
<para>Type <command>e</command> to edit the <command>kernel /platform/i86pc/multiboot</command> boot entry.</para>
<para>The GRUB edit menu is displayed, enabling
you to add options and arguments to the <command>kernel</command> command.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot</screen>
</step>
<step>
<para>Type <option>
s</option> at the end of the <command>kernel /platform/i86pc/multiboot</command> line. Then, press Enter.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot <userinput>-s</userinput>
</screen>
<para>After you press Enter, you are returned to the GRUB main menu.</para>
</step>
<step>
<para>To boot the system to the single-user level, type <command>b</command>.</para>
<para>The system boots to the single-user level.</para>
</step>
<step xml:id="fvzta">
<para>Type the superuser password, if prompted.</para>
</step>
<step xml:id="fvzoq">
<para>Verify that the system is at run level S.</para>
<screen># <userinput>who -r</userinput>
 </screen>
</step>
<step xml:id="fvzuf">
<para>Perform the system maintenance task that required the
run level change to S.</para>
</step>
<step xml:id="fvzqb">
<para>After you complete the system maintenance task, type
Control-D to bring the system to the multiuser state.</para>
</step>
</procedure>
<example arch="x86">

<title>
Booting a System to Run Level S (Single-User Level)</title>
<indexterm xml:id="indexterm-161">
<primary>example of booting a system to run level S</primary>
<secondary>GRUB based booting</secondary>
</indexterm>
<indexterm xml:id="indexterm-162">
<primary>GRUB based booting</primary>
<secondary>example of booting a system to run level S</secondary>
</indexterm>
<screen width="100">Press any key to reboot.
Resetting...
GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | Solaris 10.1 ... X86                                                    |
 | Solaris failsafe                                                        |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press enter to boot the selected OS, 'e' to edit the
      commands before booting, or 'c' for a command-line.

&lt;<emphasis>Type e to edit Solaris entry</emphasis>&gt;

GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | root (hd0,2,a)                                                          |
 | kernel /platform/i86pc/multiboot                                        |
 | module /platform/i86pc/boot_archive                                     |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press 'b' to boot, 'e' to edit the selected command in the
      boot sequence, 'c' for a command-line, 'o' to open a new line
      after ('O' for before) the selected line, 'd' to remove the
      selected line, or escape to go back to the main menu.


&lt;<emphasis>Type e to edit the line</emphasis>&gt;

grub edit&gt; kernel /platform/i86pc/multiboot <userinput>-s</userinput>
<replaceable>Press Enter</replaceable>
 GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | root (hd0,2,a)                                                          |
 | kernel /platform/i86pc/multiboot -s                                     |
 | module /platform/i86pc/boot_archive                                     |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press 'b' to boot, 'e' to edit the selected command in the
      boot sequence, 'c' for a command-line, 'o' to open a new line
      after ('O' for before) the selected line, 'd' to remove the
      selected line, or escape to go back to the main menu.

&lt;<emphasis>Type b to boot system in single-user mode</emphasis>&gt;

Booting List command
root (hd0,2,a)
Filesystem type is ufs, partition type 0x000000bf
kernel /platform/i86pc/multiboot -s
 [Multiboot-elf, &lt;0x1000000:0x13f3b:0x3941d&gt;, shtab=0x104e258, entry=0x100000
0]...

SunOS Release 5.10.1 Version ... 64-bit
Copyright 1983-2005 Sun Microsystems, Inc.  All rights reserved.
Use is subject to license terms.
Booting to milestone "milestone/single-user:default".
.
.
.
Root password for system maintenance (control-d to bypass): <userinput>xxxxxx</userinput> 

single-user privilege assigned to /dev/console.
Entering System Maintenance Mode

May 30 12:11:15 su: 'su root' succeeded for root on /dev/console
Sun Microsystems Inc.   SunOS 5.10.1  ...  October 2007.
# <userinput>who -r</userinput>
    .       run-level S  Jun 10 11:44     S      0  0
# <userinput>svcs | grep milestone</userinput>
disabled       11:44:02 svc:/milestone/sysconfig:default
disabled       11:44:02 svc:/milestone/name-services:default
disabled       11:44:02 svc:/milestone/multi-user:default
disabled       11:44:02 svc:/milestone/multi-user-server:default
online         11:44:05 svc:/milestone/devices:default
online         11:44:10 svc:/milestone/network:default
online         11:44:10 svc:/milestone/single-user:default
#  <lineannotation>&lt;Perform some maintenance task&gt;
</lineannotation>
# <userinput>^D</userinput>
</screen>
</example>
</task>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fvzmg">

<title>
How to Boot a System Interactively</title>
<indexterm xml:id="indexterm-163">
<primary>booting an x86 based system interactively with GRUB</primary>
</indexterm>
<indexterm xml:id="indexterm-164">
<primary>GRUB based booting</primary>
<secondary>booting a system interactively</secondary>
</indexterm>
<indexterm xml:id="indexterm-165">
<primary>interactive boot</primary>
<secondary>booting an x86 based system with GRUB</secondary>
</indexterm>
<tasksummary>
<para>Use this procedure to boot a system when you need to specify an alternate
kernel or an alternate <filename>/etc/system</filename> file. </para>
</tasksummary>
<procedure>
<step xml:id="fvzpr">
<para>If the system displays the <literal>Press any key to
reboot</literal> prompt, press any key to reboot the system.</para>
<para>You
can also use the Reset button at this prompt. If the system is shut down,
turn the system on with the power switch.</para>
<para>When the boot sequence
begins, the GRUB main menu is displayed.</para>
</step>
<step xml:id="fvzmu">
<para>Type <command>e</command> to access the GRUB edit menu.</para>
</step>
<step>
<para>Use the arrow keys to select the <command>kernel /platform/i86pc/multiboot</command> line.</para>
</step>
<step>
<para>Type <command>e</command> to edit the line.</para>
<para>The GRUB
edit menu is displayed, enabling you to add options to the <command>kernel</command> command.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot</screen>
</step>
<step>
<para>Type <option>
a</option> at the end of the <command>kernel /platform/i86pc/multiboot</command> line. Then, press Enter.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot <userinput>-a</userinput>
</screen>
<para>The GRUB main menu is displayed.</para>
</step>
<step>
<para>To boot the system interactively, type <command>b</command>.</para>
<para>A series of system prompts are displayed. If you want to accept the
default, press Enter.</para>
</step>
<step>
<para>Provide the name of the default directory for modules.</para>
<para>The
following prompt is displayed: <literal>Enter default directory for modules</literal>
</para>
<screen>[/platform/i86pc/kernel /kernel /usr/kernel]:</screen>
</step>
<step>
<para>Provide the name of the kernel to use for booting.</para>
<para>The
following prompt appears: <literal>Name of system file</literal>
</para>
<screen>[etc/system]:</screen>
</step>
<step>
<para>When prompted, provide an alternate path for the module directories.</para>
<para>Press Enter to use the default module directories. Otherwise, provide
the alternate paths to module directories, press Enter.</para>
</step>
<step>
<para>When prompted, type the physical name of the root device.</para>
<para>Provide an alternate device name, or press Enter to use the default.</para>
</step>
<step>
<para>If you are not prompted to answer these questions, modify the
entry by using the <option>
a</option> option, boot the system interactively
again.</para>
</step>
</procedure>
<example arch="x86">

<title>
Booting a System Interactively</title>
<indexterm xml:id="indexterm-166">
<primary>example of booting an x86 based system with GRUB</primary>
<secondary>interactive boot</secondary>
</indexterm>
<indexterm xml:id="indexterm-167">
<primary>GRUB based booting</primary>
<secondary>example of interactive boot</secondary>
</indexterm>
<para>In the following example, the default choices (shown in square brackets <literal>[]</literal>) are accepted.</para>
<screen width="100">Press any key to reboot.
Resetting...
Press any key to reboot.

    GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | Solaris 10.1 ... X86                                                    |
 | Solaris failsafe                                                        |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press enter to boot the selected OS, 'e' to edit the
      commands before booting, or 'c' for a command-line.

The highlighted entry will be booted in 10 seconds.

    GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | root (hd0,2,a)                                                          |
 | kernel /platform/i86pc/multiboot                                        |
 | module /platform/i86pc/boot_archive                                     |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press 'b' to boot, 'e' to edit the selected command in the
      boot sequence, 'c' for a command-line, 'o' to open a new line
      after ('O' for before) the selected line, 'd' to remove the
      selected line, or escape to go back to the main menu.


grub edit&gt; kernel /platform/i86pc/multiboot  <userinput>-a</userinput>

    GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | root (hd0,2,a)                                                          |
 | kernel /platform/i86pc/multiboot -a                                     |
 | module /platform/i86pc/boot_archive                                     |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press 'b' to boot, 'e' to edit the selected command in the
      boot sequence, 'c' for a command-line, 'o' to open a new line
      after ('O' for before) the selected line, 'd' to remove the
      selected line, or escape to go back to the main menu.
  Booting command-list

root (hd0,2,a)
 Filesystem type is ufs, partition type 0x000000bf
kernel /platform/i86pc/multiboot -a
   [Multiboot-elf, &lt;0x1000000:0x13f3b:0x3941d&gt;, shtab=0x104e258, entry=0x100000
0]...
module /platform/i86pc/boot_archive
  
Enter default directory for modules [/platform/i86pc/kernel /kernel /usr/kernel]
: <lineannotation>&lt;Press Enter&gt;
</lineannotation>
Name of system file [etc/system]:<lineannotation>&lt;Press Enter&gt;
</lineannotation> 
SunOS Release 5.10.1 Version ... 64-bit
Copyright 1983-2005 Sun Microsystems, Inc.  All rights reserved.
Use is subject to license terms.
Hostname: swoozie.Central.Sun.COM
NIS domain name is boulder.Central.Sun.COM
checking ufs filesystems
/dev/rdsk/c1d0s7: is logging.

swoozie.Central.Sun.COM console login:</screen>
</example>
</task>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fwbon">

<title>
How to Set Solaris Boot Parameters by Using
the <command>eeprom</command> Command</title>
<indexterm xml:id="indexterm-168">
<primary>Setting boot parameters by using <command>eeprom</command> command</primary>
<secondary>GRUB based booting</secondary>
</indexterm>
<indexterm xml:id="indexterm-169">
<primary>
<command>eeprom</command> command</primary>
<secondary>how to use to set boot parameters</secondary>
<tertiary>GRUB</tertiary>
</indexterm>
<tasksummary>
<para>You can display or set Solaris boot parameters by using the <command>eeprom</command> command. The parameters that you can set with the <command>eeprom</command> command
are found in the <filename>/boot/solaris/bootenv.rc</filename> file. Changes
that you make by using the <command>eeprom</command> command persist over
a system reboot. However, you can override this <command>eeprom</command> setting
if you boot the system by using the <command>kernel</command> command in the
GRUB menu.</para>
<para>See <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwbme">
How to Modify the Solaris Boot Behavior by Editing the GRUB Menu</olink>. For more information about changes to the <command>eeprom</command> command in this release, see the <olink remap="external" targetdoc="819-2240" targetptr="eeprom-1m">
<citerefentry>
<refentrytitle>eeprom</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man page.</para>
</tasksummary>
<procedure>
<step>
<para>Become superuser or assume an equivalent role.</para>
<para>Roles
contain authorizations and privileged commands. For more information about
roles, see <olink remap="external" targetdoc="819-3321" targetptr="rbactask-15">
<citetitle remap="section">Configuring RBAC (Task Map)</citetitle> in <citetitle remap="book">System Administration Guide: Security Services</citetitle>
</olink>.</para>
</step>
<step>
<para>To change the specified parameter, type the <command>eeprom</command> command
with the appropriate arguments .</para>
<screen># <userinput>eeprom <replaceable>parameter</replaceable>=<replaceable>new-value</replaceable>
</userinput>
</screen>
</step>
<step>
<para>Verify that the new parameter has been set.</para>
<screen># <userinput>eeprom <replaceable>parameter</replaceable>
</userinput>
</screen>
<para>The output should display the new <command>eeprom</command> value for
the specified parameter.</para>
</step>
</procedure>
<example arch="x86" xml:id="fwbps">

<title>
Setting <literal>boot-file</literal> Parameters by Using the <command>eeprom</command> Command</title>
<para>This example shows how to manually specify that the system boot a 64-bit
kernel. Note that the system must support 64-bit computing.</para>
<screen># <userinput>eeprom boot-file=kernel/amd64/unix</userinput>
</screen>
<para>This example shows how to manually boot a 32-bit kernel on a 64-bit
capable system.</para>
<screen># <userinput>eeprom boot-file=kernel/unix</userinput>
</screen>
<para>This example shows how to restore the default autodetected boot behavior
on a system.</para>
<screen># <userinput>eeprom boot-file=""</userinput>
</screen>
<para>This example shows how to determine the current <literal>boot-file</literal> parameter.</para>
<screen>$ <userinput>eeprom boot-file</userinput>
</screen>
</example>
<example xml:id="fwboo">

<title>Setting the Console Destination, Mode, and Speed by Using the <command>eeprom</command> Command.</title>
<indexterm xml:id="indexterm-170">
<primary>GRUB based booting</primary>
<secondary>setting console parameters with <command>eeprom</command> command</secondary>
</indexterm>
<indexterm xml:id="indexterm-171">
<primary>
<command>eeprom</command> command</primary>
<secondary>setting console parameters</secondary>
</indexterm>
<indexterm xml:id="indexterm-172">
<primary>setting console parameters with <command>eeprom</command> command</primary>
<secondary>GRUB based booting</secondary>
</indexterm>
<para>The following examples show how to direct the console to run on <literal>ttyb</literal>.</para>
<screen># <userinput>eeprom console=ttyb</userinput>
</screen>
<screen># <userinput>eeprom input-device=ttyb output-device=ttyb</userinput>
</screen>
<para>The <command>eeprom console=ttyb</command> command only works if you
are running at least the Solaris Express 6/05 OS. Note that <literal>input-device</literal> and <literal>output-device</literal> must have the same value. Or, the system might not boot at all.</para>
<para>This example shows how to set a high serial line speed.</para>
<screen># <userinput>eeprom ttyb-mode=115200,8,n,1</userinput>
</screen>
<para>To enable the Solaris software to work with a higher serial line speed,
you must also modify the console line in the <filename>/etc/ttydefs</filename> file,
as shown in the following example.</para>
<screen>console:115200 hupcl opost onlcr:115200::console</screen>
<para>For more information about setting the baud rate on the terminal console,
see <olink remap="external" targetdoc="819-2380" targetptr="fxcgt">
<citetitle remap="section">How to Set the Baud Rate Speed on the ttymon Console Terminal</citetitle> in <citetitle remap="book">System Administration Guide: Advanced Administration</citetitle>
</olink>.</para>
</example>
</task>
</sect2>
<sect2 arch="x86" xml:id="fwbqs">
<title>
Modifying the Solaris Boot Behavior by
Editing the GRUB Menu</title>
<indexterm xml:id="indexterm-173">
<primary>modifying Solaris boot behavior in GRUB menu</primary>
</indexterm>
<indexterm xml:id="indexterm-174">
<primary>editing the GRUB menu</primary>
<secondary>modifying Solaris boot behavior</secondary>
</indexterm>
<indexterm xml:id="indexterm-175">
<primary>boot behavior</primary>
<secondary>modifying by editing GRUB menu</secondary>
</indexterm>
<indexterm xml:id="indexterm-176">
<primary>Solaris boot behavior</primary>
<secondary>how to modify</secondary>
<tertiary>GRUB</tertiary>
</indexterm>
<para>You can modify the Solaris boot behavior by editing the GRUB menu when
the system is first booted. Typing <command>e</command> when the GRUB main
menu is displayed interrupts the boot process, enabling you to access the
GRUB edit menu. Each line in this menu is an individual command for the boot
entry that you chose in the GRUB main menu. See the section, <olink remap="internal" targetdoc="chapter-11.xml" targetptr="grubterm">GRUB Terminology</olink> for more information.</para>
<para>The following is a sample of the menu that is displayed when you type <command>e</command> in the GRUB main menu to edit a boot entry. The second line, <filename>kernel /platform/i86pc/multiboot</filename>, executes the <command>kernel</command> command,
which determines the boot behavior of the Solaris OS. Use the arrow keys to
navigate the menu, then highlight the specified line. Type <command>e</command> again
to edit the line. Note that any modifications you make persist only until
the next time the system is booted.</para>
<screen width="100">GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | root (hd0,2,a)                                                          |
 | kernel /platform/i86pc/multiboot                                        |
 | module /platform/i86pc/boot_archive                                     |
 |                                                                         |
 +-------------------------------------------------------------------------+
 </screen>
<caution>

<para>You can only add additional arguments to the end of boot entry
that you are editing. You should not modify any portion of the text in the
menu entry itself. Doing so prevents the Solaris instance from booting.</para>
</caution>
</sect2>
<sect2 xml:id="fxjha">
<title>Using the <command>kernel</command> Command</title>
<indexterm xml:id="indexterm-177">
<primary>GRUB based booting</primary>
<secondary>using the <command>kernel</command> command</secondary>
</indexterm>
<indexterm xml:id="indexterm-178">
<primary>GRUB menu</primary>
<secondary>
<command>kernel</command> command</secondary>
</indexterm>
<indexterm xml:id="indexterm-179">
<primary>commands in GRUB menu</primary>
<secondary>
<command>kernel</command> command</secondary>
</indexterm>
<indexterm xml:id="indexterm-180">
<primary>
<command>kernel</command> command</primary>
<secondary>using in the GRUB menu</secondary>
</indexterm>
<para>The following list describes how to use the <command>kernel</command> command
with the appropriate options and arguments to specify Solaris boot behavior
in the GRUB menu.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot/ <userinput>[<replaceable>kernel-name</replaceable>] [-asrvxk]
-m [<replaceable>smf-options</replaceable>] [-i altinit] [-B prop=value[,prop=value]...]</userinput>
</screen>
<variablelist>
<varlistentry>
<term>
<replaceable>kernel-name</replaceable>
</term>
<listitem>
<para>Specifies the kernel to boot.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
a</option>
</term>
<listitem>
<para>Prompts the user for configuration information.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
s</option>
</term>
<listitem>
<para>Boots the system in single-user mode.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
r</option>
</term>
<listitem>
<para>Specifies a reconfiguration boot.  The  system probes all
attached hardware devices and then assigns nodes in the file system to represent
only those devices that are actually found.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
v</option>
</term>
<listitem>
<para>Boots the system with verbose messages enabled.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
x</option>
</term>
<listitem>
<para>Does not boot in clustered mode.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
k</option>
</term>
<listitem>
<para>Boots the system with the kernel debugger enabled.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
m</option> <replaceable>smf-options</replaceable>
</term>
<listitem>
<para>Controls  the boot behavior of the Service Management Facility
(SMF). Included are two categories of options, recovery options and messages
options.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
i</option> <command>altinit</command>
</term>
<listitem>
<para>Specifies an alternative executable as the primordial process.
 <command>altinit</command> is a valid path to an executable.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
B</option> <replaceable>prop=value[,prop=value]...</replaceable>
</term>
<listitem>
<para>Is parsed by the multiboot program. The multiboot program
then translates the argument into properties.</para>
</listitem>
</varlistentry>
</variablelist>
<para>The following describes various ways that you can used the <command>kernel</command> command
with the <option>
B</option> option:</para>
<variablelist>
<varlistentry>
<term>
<option>
B</option> <literal>console=ttya</literal>
</term>
<listitem>
<para>Redirects the console to <literal>ttya</literal>.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
B</option> <literal>acpi-enum=off</literal>
</term>
<listitem>
<para>Disables Advanced Configuration and Power Interface (ACPI)
enumeration of devices.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
B</option> <literal>console=ttya,apci-enum=off</literal>
</term>
<listitem>
<para>Redirects the console to <literal>ttya</literal> and disables
the ACPI enumeration of devices.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<option>
B</option> <literal>acpi-user-options=0x2</literal>
</term>
<listitem>
<para>Disables ACPI entirely.</para>
</listitem>
</varlistentry>
</variablelist>
<para>Note that when properties are specified by using the <command>eeprom</command> command <emphasis>and</emphasis> on the GRUB command line, that the GRUB command takes precedence.</para>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fwbme">

<title>
How to Modify the Solaris Boot Behavior
by Editing the GRUB Menu</title>
<indexterm xml:id="indexterm-181">
<primary>modify Solaris boot behavior</primary>
<secondary>editing the GRUB menu</secondary>
</indexterm>
<indexterm xml:id="indexterm-182">
<primary>boot behavior</primary>
<secondary>how to modify with GRUB</secondary>
</indexterm>
<indexterm xml:id="indexterm-183">
<primary>GRUB based booting</primary>
<secondary>modifying the GRUB menu</secondary>
<tertiary>boot behavior</tertiary>
</indexterm>
<tasksummary>
<para>This procedure shows how to modify the Solaris boot behavior in the
GRUB menu. Changes that you make persist until the next time the system is
booted.</para>
</tasksummary>
<procedure>
<step xml:id="fwbqq">
<para>If the system displays the <literal>Press any key to
reboot</literal> prompt, press any key to reboot the system.</para>
<para>You
can also use the Reset button at this prompt. If the system is shut down,
turn the system on with the power switch.</para>
<para>When the boot sequence
begins, the GRUB main menu is displayed.</para>
</step>
<step>
<para>To access the GRUB edit menu, type <command>e</command>.</para>
</step>
<step>
<para>Ue the arrow keys to select the second line in the menu. </para>
<screen width="100">GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | root (hd0,2,a)                                                          |
 | kernel /platform/i86pc/multiboot                                        |
 | module /platform/i86pc/boot_archive                                     |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
 </screen>
<para>The second line in the GRUB menu includes the <command>kernel</command> command,
which is used to specify Solaris boot options.</para>
</step>
<step>
<para>Type <command>e</command> again to edit the <command>kernel /platform/i86pc/multiboot</command> line.</para>
</step>
<step>
<para>Type the appropriate information for the boot parameter that you
want to specify.</para>
<screen>kernel /platform/i86pc/multiboot/ <userinput>[<replaceable>kernel-name</replaceable>] [-afsrvxk]
-m [<replaceable>smf-options</replaceable>] [-i atinit] [-B prop=value[,prop=value]...]</userinput>
</screen>
<para>For example, to boot a 64-bit capable x86 based system in 32-bit mode,
you would type:</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot <userinput>kernel/unix</userinput>
</screen>
<para>See <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fxjha">Using the <command>kernel</command> Command</olink> for a
description of all the <command>kernel</command> command options.</para>
</step>
<step>
<para>Return to the GRUB main menu, by pressing Enter.</para>
<note>

<para>Pressing Enter saves your changes and returns you to the GRUB
main menu. Pressing the Escape key returns you to the GRUB main menu without
saving your changes.</para>
</note>
</step>
<step>
<para>To boot the system, type <command>b</command>. </para>
<para>Changes
that you made take affect when the system is booted.</para>
</step>
</procedure>
<example xml:id="fwbtl">

<title>Modifying the Solaris Boot Behavior in the GRUB Menu</title>
<para>This example shows how to modify the <command>kernel /platform/i86pc/multiboot</command> line to boot a 32-bit kernel to single-user mode.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot <userinput>kernel/unix -s</userinput>
<userinput>
</userinput>
</screen>
<para>This example shows how to manually redirect the console to <literal>ttyb</literal>.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot <userinput>-B console=ttyb</userinput>
</screen>
<para>Alternatively, you can use <literal>input-device/output-device</literal> property,
as shown in the following example.</para>
<screen width="100">grub edit&gt; kernel /platform/i86pc/multiboot <userinput>-B input-device=ttyb,output-device=ttyb</userinput>
</screen>
<para>This example shows how to override the serial line speed.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot <userinput>-B ttyb-mode="115200,8,n,1,-"</userinput>
</screen>
<para>In the preceding example, the property value contains commas, which
is also a property separator. To avoid confusing the property parser, use
double quotation marks around the entire property value.</para>
</example>
</task>
</sect2>
<sect2 arch="x86" xml:id="fvzok">
<title>
Performing a GRUB Based Boot From the
Network</title>
<indexterm xml:id="indexterm-184">
<primary>performing a GRUB based network boot</primary>
</indexterm>
<indexterm xml:id="indexterm-185">
<primary>GRUB based booting</primary>
<secondary>from the network</secondary>
</indexterm>
<indexterm xml:id="indexterm-186">
<primary>network boot</primary>
<secondary>using GRUB</secondary>
</indexterm>
<para>Any system can boot from the network, if a boot server is available.
You might need to boot a stand-alone system from the network for recovery
purposes if the system cannot boot from the local disk. You can boot a Solaris
OS x86 based system directly from a network that supports the PXE network
boot protocol.</para>
<note>

<para>The PXE network boot is available only for devices that implement
the Intel Preboot Execution Environment specification.</para>
</note>
<para>The default network boot strategy  that is used for a GRUB based PXE
network boot is DHCP. For non-PXE devices, you can use either the DHCP or
the RARP boot strategy. The strategy that you use depends on which type of
boot server is available on your network. If no PXE or DHCP server is available,
you can load GRUB from a diskette, a CD-ROM, or a local disk. You can then
configure the network in GRUB manually and download the multiboot program
and the boot archive from the file server. For additional information, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvjch">
GRUB Based Booting From the Network</olink>.</para>
</sect2>
<sect2 xml:id="fwfdk">
<title>About DHCP Macros</title>
<indexterm xml:id="indexterm-187">
<primary>macros</primary>
<secondary>DHCP</secondary>
</indexterm>
<indexterm xml:id="indexterm-188">
<primary>DHCP macros</primary>
<secondary>using in GRUB</secondary>
</indexterm>
<indexterm xml:id="indexterm-189">
<primary>GRUB based booting</primary>
<secondary>about DHCP macros</secondary>
</indexterm>
<indexterm xml:id="indexterm-190">
<primary>configuring DHCP</primary>
<secondary>booting from the network with GRUB</secondary>
</indexterm>
<para>When you add clients with the <command>add_install_client</command> <option>
d</option> script on the install server, the script reports DHCP configuration
information to standard output. You can use this information when you create
the options and macros that are needed to pass network installation information
to clients. </para>
<para>To install DHCP clients with a DHCP server over the network, you must
create DHCP options. This information is needed to install the Solaris OS.
When a client sends a DHCP request, the server must have the following client
information:</para>
<itemizedlist>
<listitem>
<para>Client's ID, which is typically the Ethernet address</para>
</listitem>
<listitem>
<para>Class of the client request</para>
</listitem>
<listitem>
<para>Subnet the client resides on</para>
</listitem>
</itemizedlist>
<para>The Solaris DHCP server forms a response. This response is based on
the following <emphasis>macros</emphasis>, which matches the client request:</para>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">class macro</emphasis>
</term>
<listitem>
<para>The class macro is based on a <emphasis>class string</emphasis> that
is contained in the DHCP request. On x86 based systems, the BIOS already makes
a DHCP request with the class <literal>PXEClient:Arch:00000:UNDI:002001</literal>.
If a macro by this name is defined in the DHCP server configuration, then
the macro content is sent to the x86 based clients.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">network macro</emphasis>
</term>
<listitem>
<para>The network macro is named by the IP address of the subnet
that the client resides on. If the macro <literal>129.146.87.0</literal> is
defined on the DHPC server, the macro content is sent to all clients on that
subnet. The macro content is sent, regardless of the class of the request.
If an option is defined in both the class macro and the network macro, the
network macro takes precedence.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">IP macro</emphasis>
</term>
<listitem>
<para>The IP macro is named by an IP address. This macro is rarely
used</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">client macro</emphasis>
</term>
<listitem>
<para>The client macro is named by the client's type (01 for Ethernet)
and the mac address of the client, in uppercase letters. For a client with
the Ethernet address <literal>0:0:39:fc:f2:ef</literal>, the corresponding
macro name is <literal>01000039FCEF</literal>. Note the absence of colons
in the client macro.</para>
</listitem>
</varlistentry>
</variablelist>
<para>For example, for a client on the subnet <literal>192.168.100.0</literal>,
with the Ethernet address <literal>0:0:39:fc:f2:ef</literal>, making a DHCP
request of class <literal>PXEClient</literal>, the DHCP server has the following
matching macro:</para>
<screen>PXEClient
	BootSrvA:  192.168.100.0
	BootFile:  pxegrub
  129.146.87.0
	Router:    129.146.87.1
	NISdmain:  sunsoft.eng.sun.com
  01000039FCEF
	BootFile:  01000039FCEF
The actual DHCP response will be
	BootSrvA:  192.168.100.0
	BootFile:  01000039FCEF
	Router:    129.146.87.1
	NISdmain:  sunsoft.eng.sun.com</screen>
<para>Note that the <filename>BootFile</filename> in the client macro overrides
the <filename>BootFile</filename> in the class macro. </para>
<para>For more detailed information, see <olink remap="external" targetdoc="819-2394" targetptr="dhcp-admin-38">
<citetitle remap="section">Preconfiguring System Configuration Information With the DHCP Service (Tasks)</citetitle> in <citetitle remap="book">Solaris Express Installation Guide: Network-Based Installations</citetitle>
</olink>.</para>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fvzpk">

<title>
How to Perform a GRUB Based Boot From the
Network</title>
<tasksummary>
<para>To perform a GRUB based network boot a DHCP server that is configured
for PXE clients is required.  A boot server that provides <command>tftp</command> service
is also required. The DHCP server must be able respond to the DHCP classes, <literal>PXEClient</literal> and <literal>GRUBClient</literal> to obtain the IP address
of the file server and the boot file (<command>pxegrub</command>). By default,
the menu file is <filename>/tftpboot/menu.lst.01<replaceable>ethernet-address</replaceable>
</filename>.
If this file does not exist, then <command>pxegrub</command> reverts to DHCP
Option 150, if this option is specified, or the <filename>/tftpboot/boot/grub/menu.lst</filename> file.</para>
<para>If you are booting the system from the Solaris Software 1 CD or DVD,
the system boots automatically.</para>
<note>

<para>In this release, the Device Configuration Assistant has been replaced
by the GRUB menu.</para>
</note>
</tasksummary>
<taskprerequisites>

<para>Before performing a network boot on an x86 based system with GRUB, do
the following: </para>
<itemizedlist>
<listitem>
<para>Run the appropriate commands on the installation server to
enable the system to boot from the network.</para>
</listitem>
<listitem>
<para>Add the client system as an install client.</para>
</listitem>
</itemizedlist>
<para>See <olink remap="external" targetdoc="819-2394" targetptr="netinstalloverview-28995">Chapter 8, <citetitle remap="chapter">Preparing to Install From the Network (Overview),</citetitle> in <citetitle remap="book">Solaris Express Installation Guide: Network-Based Installations</citetitle>
</olink> for
more information.</para>
</taskprerequisites>
<procedure>
<step>
<para>On the DHCP server, create a client macro for the DHCP service
with the following two options:</para>
<itemizedlist>
<listitem>
<para>
<literal>BootSrvA</literal>:  <replaceable>svr-addr</replaceable>
</para>
</listitem>
<listitem>
<para>
<literal>BootFile</literal>:  <replaceable>client-macro</replaceable>
</para>
<para>Note that you must have superuser privileges on the DHCP server to run
the <command>dhtadm</command> command.</para>
<para>where <replaceable>svr-addr</replaceable> is
the IP address of the server, and <replaceable>client-macro</replaceable> is
is named by the client's Ethernet type (01) and the mac address, in uppercase
letters. This number is also the name of the file that is used in the <filename>/tftpboot</filename> directory on the installation server.</para>
<note>

<para>The notation for the <replaceable>client-macro</replaceable> should
not contain any colons.</para>
</note>
<para>You can create the client macro from the DHCP GUI or from command-line
interface.</para>
<para>To create the client macro from the command-line, type:</para>
<screen># <userinput>dhtadm -[MA] -m <replaceable>client macro</replaceable> -d
":BootFile=<replaceable>client-macro</replaceable>:BootSrvA=<replaceable>svr-addr:</replaceable>"</userinput>
</screen>
</listitem>
</itemizedlist>
</step>
<step xml:id="fvzqv">
<para>Reboot the system.</para>
</step>
<step>
<para>Instruct the BIOS to boot from the network.</para>
<itemizedlist>
<listitem>
<para>If your system uses a specific keystroke sequence to boot
from the network, type the keystrokes when the BIOS screen is displayed.</para>
</listitem>
<listitem>
<para>If you need to manually modify the BIOS settings to boot from
the network, type the keystroke sequence to access the BIOS setup utility.
Then, modify the boot priority to boot from the network.</para>
</listitem>
</itemizedlist>
</step>
<step>
<para>When the GRUB menu is displayed, select the network installation
image that you want to install.</para>
</step>
</procedure>
</task>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fvzot">

<title>
How to Stop a System for Recovery Purposes</title>
<procedure>
<step>
<para>
<indexterm xml:id="indexterm-191">
<primary>stopping</primary>
<secondary>a system for recovery purposes (how to)</secondary>
<tertiary>x86</tertiary>
</indexterm>Stop the system by using one of the following commands, if possible:</para>
<itemizedlist>
<listitem>
<para>If the keyboard and mouse are functional, become superuser.
Then, type <command>init 0</command> to stop the system. After the <literal>Press
any key to reboot</literal> prompt appears, press any key to reboot the system.</para>
</listitem>
<listitem>
<para>If the keyboard and mouse are functional, become superuser.
then, type <command>init 6</command> to reboot the system.</para>
</listitem>
</itemizedlist>
</step>
<step xml:id="fvzoz">
<para>If the system does not respond to any input from the
mouse or the keyboard, press the Reset key, if it exists, to reboot the system. </para>
<para>Or, you can use the power switch to reboot the system.</para>
</step>
</procedure>
</task>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fvznb">

<title>
How to Boot the Failsafe Archive for Recovery
Purposes</title>
<indexterm xml:id="indexterm-192">
<primary>failsafe archive</primary>
<secondary>GRUB based booting</secondary>
<tertiary>recovery</tertiary>
</indexterm>
<indexterm xml:id="indexterm-193">
<primary>recovering</primary>
<secondary>booting the failsafe archive</secondary>
<tertiary>GRUB based booting</tertiary>
</indexterm>
<indexterm xml:id="indexterm-194">
<primary>GRUB based booting</primary>
<secondary>booting the failsafe archive</secondary>
</indexterm>
<indexterm xml:id="indexterm-195">
<primary>archive</primary>
<secondary>booting the failsafe archive</secondary>
<tertiary>GRUB</tertiary>
</indexterm>
<indexterm xml:id="indexterm-196">
<primary>booting the failsafe archive</primary>
<secondary>GRUB based booting</secondary>
</indexterm>
<tasksummary>
<para>Follow this procedure to boot the Solaris failsafe archive, so that
you can update the boot archives or repair a critical system resource.</para>
<note>

<para>Starting with the Solaris
Express 3/06 release, the GRUB failsafe interaction has changed. Previously,
when you booted the failsafe archive, you were prompted to update the boot
archives, regardless of whether the boot archives were out-of-date. Now, you
are prompted to update the boot archives only if the system detects any out-of-date
boot archives. See <olink remap="internal" targetdoc="chapter-11.xml" targetptr="gcbof">Example 11–8</olink> for
an example.</para>
<para>For an example of the previous GRUB failsafe interaction,
see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="failsafe-s10" type="custom-text">Booting the Failsafe
Archive for Recovery Purposes to Repair a Critical System Resource</olink>.</para>
</note>
</tasksummary>
<procedure>
<step xml:id="gcbmu">
<para>Stop the system by using the system's Stop key sequence.</para>
<para>Use the Stop key sequence for your system if you do not know the superuser
password, or if you cannot log in to the system. For more information, see <olink remap="external" targetdoc="chapter-12.xml" targetptr="hbx86boot-51369">
How to Stop a System for Recovery Purposes</olink>.</para>
</step>
<step xml:id="gcbnn">
<para>If the system displays the <literal>Press any key to
reboot</literal> prompt, press any key to reboot the system.</para>
<para>You
can also use the Reset button at this prompt.</para>
<para>When the boot sequence
begins, the GRUB menu is displayed.</para>
<screen>GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | Solaris 10.1 ... X86                                                    |
 | Solaris failsafe                                                        |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the ^ and v keys to select which entry is highlighted.
      Press enter to boot the selected OS, 'e' to edit the
      commands before booting, or 'c' for a command-line.

The highlighted entry will be booted in 10 seconds.</screen>
</step>
<step>
<para>Use the arrow keys to navigate the GRUB menu, then select the <literal>Solaris failsafe</literal> entry. Type <command>b</command> or press Enter
to boot the failsafe archive.</para>
<para>The system searches for installed
OS instances. If the system detects any out-of-date boot archives, a message
that is similar to the following is displayed:</para>
<screen>Searching for installed OS instances...
	
	An out of sync boot archive was detected on /dev/dsk/c0t0d0s0.
	The boot archive is a cache of files used during boot and
	should be kept in sync to ensure proper system operation.
	
	Do you wish to automatically update this boot archive? [y,n,?]</screen>
</step>
<step>
<para>Type <command>y</command> to automatically update the out-of-date
boot archive. If multiple out-of-date boot archives are found, the system
prompts you to update each boot archive, one at a time. Type <command>y</command> and
press Enter to update each boot archive.</para>
<para>A message that is similar
to the following is displayed:</para>
<screen>Updating boot archive on /dev/dsk/c0t0d0s0.
	The boot archive on /dev/dsk/c0t0d0s0 was updated successfully.</screen>
<para>After the boot archive has been updated successfully, the system searches
again for all installed OS instances and prompts you to select a device to
mount on <filename>/a</filename>. If more than one OS instance is found, a
message that is similar to the following is displayed:</para>
<screen>Multiple OS instances were found. To check and mount one of them
read-write under /a, select it from the following list. To not mount
any, select 'q'.

  1  /dev/dsk/c0t0d0s0     Solaris 10 1/06 s10x_u1wos_19a X86
  2  /dev/dsk/c0t1d0s0     Solaris Nevada snv_25 X86

Please select a device to be mounted (q for none) [?,??,q]: 2
mounting /dev/dsk/c0t1d0s0 on /a

Starting shell.
#</screen>
<stepalternatives>
<step>
<para>If you do not want to mount a device, type <command>q</command> and
press Enter. Then, proceed to <olink remap="internal" targetdoc="chapter-11.xml" targetptr="failsafe-init6" type="custom-text">Step 7</olink>.</para>
</step>
<step>
<para>If any out-of-date archives were updated in the previous step,
you do not need to mount the device. The device is already mounted. Proceed
to Step 5.</para>
</step>
<step>
<para>If no out-of-date boot archives were updated in the previous step,
and you want to mount the device, type the corresponding number of the device,
and press Enter.</para>
<para>The system mounts the device on <filename>/a</filename>,
and you are returned to the shell prompt.</para>
</step>
</stepalternatives>
</step>
<step>
<para>Repair the critical system resource.</para>
</step>
<step>
<para>When you have finished repairing the critical system resource,
unmount the device.</para>
<screen># <userinput>umount /a</userinput>
</screen>
</step>
<step xml:id="failsafe-init6">
<para>Reboot the system.</para>
<screen># <userinput>init 6</userinput>
</screen>
</step>
</procedure>
<example arch="x86" xml:id="failsafe-s10">

<title>
Booting the Failsafe Archive to Repair a Critical System Resource</title>
<para>This example shows the previous failsafe interaction. In the preceding
task, the failsafe interaction that is shown is for the current release. If
you have installed or have upgraded to at least the Solaris Express 3/06 OS, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="gcbof">Example 11–8</olink> for the current failsafe interaction.</para>
<screen width="100">Press any key to reboot.
Resetting...

 GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)

 +-------------------------------------------------------------------------+
 | Solaris 10.1 ... X86                                                    |
 | Solaris failsafe                                                        |
 |                                                                         |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
 

 GNU GRUB  version 0.95  (631K lower / 2095488K upper memory)
Filesystem type is ufs, partition type 0x000000bf
[Multiboot-elf, &lt;0x1000000:0x13f3b:0x3941d&gt;, shtab=0x104e258, entry=0x100000
0]...
module /boot/x86.miniroot-safe
SunOS Release 5.10.1 Version ... 64-bit
Copyright 1983-2005 Sun Microsystems, Inc.  All rights reserved.
Use is subject to license terms.
Booting to milestone "milestone/single-user:default".
Configuring devices.
Searching for installed OS...
        /dev/dsk/c1t0d0s0 --       Solaris 10.1 ... X86

Do you wish to automatically update boot archives? [y,n,?] <userinput>y</userinput>
# <userinput>mount /dev/dsk/c0t0d0s0 /a</userinput>
      .
      .
      .
# <userinput>cd /a/etc</userinput>
# <userinput>vi passwd</userinput>
<lineannotation>(Remove invalid entry)</lineannotation>
# <userinput>cd /</userinput>
# <userinput>umount /a</userinput>
# <userinput>init 6</userinput>
.
.
.
Booting 'Solaris 10.1 ... X86'

root (hd0,2,a)
Filesystem type is ufs, partition type 0x000000bf
kernel /platform/i86pc/multiboot
[Multiboot-elf, &lt;0x1000000:0x13f3b:0x3941d&gt;, shtab=0x104e258, entry=0x1000000]
module /platform/i86pc/boot_archive

SunOS Release 5.10.1 Version ... 64-bit
Copyright 1983-2005 Sun Microsystems, Inc.  All rights reserved.
Use is subject to license terms.
Hostname: swoozie.Central.Sun.COM
NIS domain name is boulder.Central.Sun.COM
checking ufs filesystems
/dev/rdsk/c1d0s7: is logging.

<replaceable>hostname.domain</replaceable> console login:</screen>
</example>
</task>
</sect2>
<sect2>
<title/>
<task arch="x86" id="gcbcn">

<title>
How to Boot the Failsafe Archive to Forcibly
Update a Corrupt Boot Archive</title>
<indexterm xml:id="indexterm-197">
<primary>replacing corrupt boot archive (how to)</primary>
</indexterm>
<indexterm xml:id="indexterm-198">
<primary>boot archive</primary>
<secondary>how to replace a corrupt</secondary>
</indexterm>
<indexterm xml:id="indexterm-199">
<primary>corrupt boot archive</primary>
<secondary>how to replace</secondary>
</indexterm>
<indexterm xml:id="indexterm-200">
<primary>GRUB based booting</primary>
<secondary>how to replace a corrupt boot archive</secondary>
</indexterm>
<indexterm xml:id="indexterm-201">
<primary>boot archive</primary>
<secondary>replacing a corrupt boot archive</secondary>
</indexterm>
<indexterm xml:id="indexterm-202">
<primary>booting the failsafe archive</primary>
<secondary>to replace a corrupt boot archive</secondary>
</indexterm>
<tasksummary>
<para>This procedure shows you how to replace a corrupt boot archive by using
the <command>bootadm</command> command. For more information, see the <olink remap="external" targetdoc="819-2240" targetptr="bootadm-1m">
<citerefentry>
<refentrytitle>bootadm</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man page.</para>
</tasksummary>
<procedure>
<step xml:id="gcbcp">
<para>Stop the system by using the system's Stop key sequence.</para>
<para>Use the Stop key sequence for your system if you do not know the superuser
password, or if you cannot log in to the system. For more information, see <olink remap="external" targetdoc="chapter-12.xml" targetptr="hbx86boot-51369">
How to Stop a System for Recovery Purposes</olink>.</para>
</step>
<step xml:id="gcbfg">
<para>If the system displays the <literal>Press any key to
reboot</literal> prompt, press any key to reboot the system.</para>
<para>You
can also use the Reset button at this prompt.</para>
<para>When the boot sequence
begins, the GRUB menu is displayed.</para>
<screen>+-------------------------------------------------------------------------+
 | Solaris 10.1... X86                                                     |
 | Solaris failsafe                                                        |
 |                                                                         |
 |                                                                         |
 +-------------------------------------------------------------------------+
      Use the  and  keys to select which entry is highlighted.
      Press enter to boot the selected OS, 'e' to edit the
      commands before booting, or 'c' for a command-line.</screen>
</step>
<step>
<para>Use the arrow keys to navigate the GRUB menu, then select the <literal>Solaris failsafe</literal> entry. Type <command>b</command> or press Enter
to boot the failsafe archive.</para>
<para>If any boot archives are out of
date, a message that is similar to the following is displayed:</para>
<screen>Searching for installed OS instances...
	
	An out of sync boot archive was detected on /dev/dsk/c0t0d0s0.
	The boot archive is a cache of files used during boot and
	should be kept in sync to ensure proper system operation.
	
	Do you wish to automatically update this boot archive? [y,n,?]
		</screen>
</step>
<step>
<para>Type <command>y</command>, then press Enter to update the out-of-date
boot archive.</para>
<para>The system displays the following message:</para>
<screen>Updating boot archive on /dev/dsk/c0t0d0s0.
	The boot archive on /dev/dsk/c0t0d0s0 was updated successfully.</screen>
<para>If no out-of-date boot archives are found, a message that is similar
to the following is displayed:</para>
<screen>Searching for installed OS instances...
	
	Solaris 10.1... X86 was found on /dev/dsk/c0t0d0s0.
	Do you wish to have it mounted read-write on /a? [y,n,?]</screen>
<para>This message is also displayed after any out-of-date boot archives are
updated successfully.</para>
</step>
<step>
<para>Mount the device that contains the corrupt boot archive on <filename>/a</filename> by typing the corresponding number of the device, then press
Enter.</para>
<note>

<para>If any out-of-date boot archives were updated in the previous
step, the device is already mounted on <filename>/a</filename>. Proceed to
Step 6.</para>
</note>
</step>
<step xml:id="gcbey">
<para>To forcibly update the corrupt boot archive, type:</para>
<screen># <userinput>bootadm update-archive -f -R /a</userinput>
</screen>
</step>
<step xml:id="gcber">
<para>Unmount the device.</para>
<screen># <userinput>umount /a</userinput>
</screen>
</step>
<step>
<para>Reboot the system.</para>
<screen># <userinput>init 6</userinput>
</screen>
</step>
</procedure>
<example arch="x86" xml:id="gcbof">

<title>
Booting the Failsafe Archive to Forcibly Update a Corrupt Boot Archive</title>
<para>
<indexterm xml:id="gcbpm">
<primary>repairing the <filename>/etc/passwd</filename> file</primary>
<secondary>x86</secondary>
</indexterm>
<indexterm xml:id="gcbnw">
<primary>
<filename>/etc/passwd</filename> file</primary>
<secondary>recovering (example of)</secondary>
<tertiary>x86</tertiary>
</indexterm>
<indexterm xml:id="indexterm-203">
<primary>
<filename>passwd</filename> file</primary>
<secondary>recovering (example of)</secondary>
<tertiary>x86</tertiary>
</indexterm>This example shows how to boot the failsafe archive to forcibly
update a corrupt boot archive. Note that this example shows the failsafe interaction
in the current Solaris release. For an example of the previous failsafe interaction,
see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="failsafe-s10">Example 11–7</olink>.</para>
<screen>		 GNU GRUB  version 0.95  (635K lower / 523200K upper memory)                 
                                                                                
 +-------------------------------------------------------------------------+    
 | Solaris 10 1/06 s10x_u1wos_19a X86                                      |    
 | &gt;Solaris failsafe&lt;                                                      |    
 |                                                                         |    
 |                                                                         |    
  +-------------------------------------------------------------------------+   
      Use the  and  keys to select which entry is highlighted.                  
      Press enter to boot the selected OS, 'e' to edit the                      
      commands before booting, or 'c' for a command-line.                       
                                                                                

  
SunOS Release 5.11 Version snv_34 32-bit
Copyright 1983-2006 Sun Microsystems, Inc.  All rights reserved.
Use is subject to license terms.
Booting to milestone "milestone/single-user:default".
Configuring devices.
Searching for installed OS instances...

Multiple OS instances were found. To check and mount one of them
read-write under /a, select it from the following list. To not mount
any, select 'q'.

  1  /dev/dsk/c0t0d0s0     Solaris 10 1/06 s10x_u1wos_19a X86
  2  /dev/dsk/c0t1d0s0     Solaris Nevada snv_25 X86

Please select a device to be mounted (q for none) [?,??,q]: 1
mounting /dev/dsk/c0t0d0s0 on /a

Starting shell.
# rm /a/platform/i86pc/boot_archive
# bootadm update-archive -f -R /a
Creating ram disk on /a
updating /a/platform/i86pc/boot_archive...this may take a minute
# umount /a
# reboot
syncing file systems... done
rebooting...
.
.
.</screen>
</example>
</task>
</sect2>
<sect2>
<title/>
<task arch="x86" id="fvzpl">

<title>
How to Boot a System With the Kernel Debugger
in the GRUB Based Boot Environment (<command>kmdb</command>)</title>
<tasksummary>
<para>This procedure shows the basics for loading the kernel debugger (<command>kmdb</command>). The <command>savecore</command> feature is enabled by default.
For more detailed information about using the kernel debugger, see the <olink remap="external" targetdoc="816-5041">
<citetitle remap="book">Solaris Modular Debugger Guide</citetitle>
</olink>.</para>
</tasksummary>
<procedure>
<step>
<para>Boot the system.</para>
<para>The GRUB menu is displayed when the
system is booted.</para>
</step>
<step xml:id="fwbug">
<para>When the GRUB menu is displayed, type <command>e</command> to
access the GRUB edit menu.</para>
</step>
<step>
<para>Use the arrow keys to choose the <command>kernel /platform/i86pc/multiboot</command> entry.</para>
<note>

<para>If you cannot use the arrow keys, use the <literal>^</literal> key
to scroll up and the <literal>v</literal> key to scroll down.</para>
</note>
</step>
<step>
<para>Type <command>e</command> to edit the boot entry.</para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot</screen>
<para>The boot entry menu is displayed. In this menu, you can add options
to the <command>kernel</command> command.</para>
</step>
<step>
<para>Type <option>
k</option> after the <command>kernel /platform/i86pc/multiboot</command> entry. </para>
<screen>grub edit&gt; kernel /platform/i86pc/multiboot <userinput>-k</userinput>
</screen>
</step>
<step>
<para>To save your changes and return to the GRUB main menu, press Enter.</para>
</step>
<step>
<para>Type <command>b</command> to boot the system with the kernel debugger
enabled.</para>
<para>The system boots with the kernel debugger enabled.</para>
</step>
<step>
<para>Access the kernel debugger.</para>
<para>The method used to access
the debugger is dependent upon the type of console that you are using to access
the system:</para>
<itemizedlist>
<listitem>
<para>If you are using a locally attached keyboard, press F1–A.</para>
</listitem>
<listitem>
<para>If you are using a serial console, send a break by using the
method appropriate to that type of serial console.</para>
</listitem>
</itemizedlist>
<para>A welcome message is displayed when you access the kernel debugger for
the first time.</para>
</step>
</procedure>
<example arch="x86" xml:id="fwbpo">

<title>
Booting a System With the Kernel Debugger in the GRUB Based Boot Environment</title>
<para>This example shows how to manually boot a 64-bit capable x86 based system
with the kernel debugger enabled.</para>
<screen>/kernel/platform/i86pc/multiboot <userinput>kernel/amd64/unix -k</userinput>
</screen>
<para>This example shows how to boot a 64-bit capable x86 based system 32-bit
mode with the kernel debugger enabled.</para>
<screen>/kernel/platform/i86pc/multiboot <userinput>kernel/unix -k</userinput>
</screen>
<para>If you type <command>kmdb</command> at the GRUB menu, the system boots
the autodetected kernel type, with the kernel debugger enabled. The system
boots in this manner regardless of how the <command>eeprom</command> <literal>boot-file</literal> parameter has been set.</para>
<para>Typing <option>
k</option> at the GRUB menu, with no additional arguments,
has the same boot result as typing <command>b</command>, with the kernel debugger
enabled. The kernel is specified by the <command>eeprom</command> <literal>boot-file</literal> parameter or by the autodetected default, if the <literal>boot-file</literal> parameter
is set to a null value (<literal>""</literal>).</para>
</example>
</task>
</sect2>
<sect2 arch="x86" xml:id="fvzpo">
<title>
Forcing a Crash Dump and Reboot of the
System</title>
<para>Forcing a crash dump and reboot of the system are sometimes necessary
for troubleshooting purposes. The <command>savecore</command> feature is enabled
by default.</para>
<para>For more information about system crash dumps, see <olink remap="external" targetdoc="819-2380" targetptr="tscrashdumps-40145">Chapter 24, <citetitle remap="chapter">Managing System Crash Information (Tasks),</citetitle> in <citetitle remap="book">System Administration Guide: Advanced Administration</citetitle>
</olink>. </para>
<task arch="x86" xml:id="fvzni">
<title>
How to Force a Crash Dump and Reboot of
the System</title>
<tasksummary>
<para>If you cannot use the <command>reboot</command> <option>
d</option> or
the <command>halt</command> <option>
d</option> command, you can use the kernel
debugger, <command>kmdb</command>, to force a crash dump. The kernel debugger
must have been loaded, either at boot, or with the <command>mdb</command> <option>
k</option> command, for the following procedure to work.</para>
<note>

<para>You must be in text mode to access the kernel debugger (<command>kmdb</command>). So, first exit any window system.</para>
</note>
</tasksummary>
<procedure>
<step>
<para>Access the kernel debugger.</para>
<para>The method used to access
the debugger is dependent upon the type of console that you are using to access
the system.</para>
<itemizedlist>
<listitem>
<para>If you are using a locally attached keyboard, press F1–A.</para>
</listitem>
<listitem>
<para>If you are using a serial console, send a break by using the
method appropriate to that type of serial console.</para>
</listitem>
</itemizedlist>
<para>The <command>kmdb</command> prompt is displayed.</para>
</step>
<step>
<para>To induce a crash, use the <literal>systemdump</literal> macro.</para>
<screen>[0]&gt; $&lt;<userinput>systemdump</userinput>
</screen>
<para>Panic messages are displayed, the crash dump is saved, and the system
reboots.</para>
</step>
<step xml:id="fvzoj">
<para>Verify that the system has rebooted by logging in at
the console login prompt.</para>
</step>
</procedure>
<example>

<title>
Forcing a Crash Dump and Reboot of the System by Using <command>halt</command> <option>
d</option>
</title>
<para>This example shows how to force a crash dump and reboot of the x86 based
system <literal>neptune</literal> by using the <command>halt</command> <option>
d</option> and <command>boot</command> commands. Use this method to force a crash dump of the system.
Reboot the system afterwards manually.</para>
<screen width="100"># <userinput>halt -d</userinput>
4ay 30 15:35:15 wacked.Central.Sun.COM halt: halted by <replaceable>user</replaceable>

panic[cpu0]/thread=ffffffff83246ec0: forced crash dump initiated at user request

fffffe80006bbd60 genunix:kadmin+4c1 ()
fffffe80006bbec0 genunix:uadmin+93 ()
fffffe80006bbf10 unix:sys_syscall32+101 ()

syncing file systems... done
dumping to /dev/dsk/c1t0d0s1, offset 107675648, content: kernel
NOTICE: adpu320: bus reset
100% done: 38438 pages dumped, compression ratio 4.29, dump succeeded

Welcome to kmdb
Loaded modules: [ audiosup crypto ufs unix krtld s1394 sppp nca uhci lofs 
genunix ip usba specfs nfs md random sctp ]
[0]&gt; 
kmdb: Do you really want to reboot? (y/n) <userinput>y</userinput>
</screen>
</example>
</task>
</sect2>
</sect1>
<sect1 arch="x86" xml:id="fwamf">
<title>
The GRUB Based Boot Process (Reference)</title>
<indexterm xml:id="indexterm-204">
<primary>GRUB based booting</primary>
<secondary>(Reference)</secondary>
</indexterm>
<indexterm xml:id="indexterm-205">
<primary>booting with GRUB</primary>
<secondary>reference</secondary>
</indexterm>
<indexterm xml:id="indexterm-206">
<primary>reference</primary>
<secondary>GRUB based boot process</secondary>
</indexterm>
<para>This section includes the following reference information:</para>
<itemizedlist>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwaze">
System BIOS in the GRUB Boot Environment</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwazo">
Boot Subsystem in the GRUB Boot Environment</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwazd">
Solaris Kernel Initialization Process in the GRUB Boot Environment</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fxjig">
How Multiple Operating Systems Are Supported in the GRUB Boot Environment</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwazj">
Management of the GRUB Boot Archive</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-11.xml" targetptr="fwbow">GRUB Boot Archives</olink>
</para>
</listitem>
</itemizedlist>
<sect2 arch="x86" xml:id="fwaze">
<title>
System BIOS in the GRUB Boot Environment</title>
<indexterm xml:id="indexterm-207">
<primary>BIOS</primary>
<secondary>system BIOS</secondary>
<tertiary>in GRUB boot environment</tertiary>
</indexterm>
<indexterm xml:id="indexterm-208">
<primary>system BIOS in GRUB boot environment</primary>
</indexterm>
<para>When a system is powered on, the system is controlled by the read-only-memory
(ROM) Basic Input/Output System (BIOS). The BIOS is the firmware interface
on Solaris Operating Systems that have 64-bit and 32-bit x86 support.</para>
<para>Hardware adapters usually have an on-board BIOS that displays the physical
characteristics of the device. The BIOS is used to access the device. During
the startup process, the system BIOS checks for the presence of any adapter
BIOS. If any adapters are found, the system then loads and executes each adapter
BIOS. Each adapter's BIOS runs self-test diagnostics and then displays device
information.</para>
<para>The BIOS on most systems has a user interface, where you can select
an ordered list of boot devices that consists of the following selections:</para>
<itemizedlist>
<listitem>
<para>Diskette</para>
</listitem>
<listitem>
<para>CD or DVD</para>
</listitem>
<listitem>
<para>Hard disk</para>
</listitem>
<listitem>
<para>Network</para>
</listitem>
</itemizedlist>
<para>The BIOS attempts to boot from each device, in turn, until a valid device
with a bootable program is found.</para>
</sect2>
<sect2 arch="x86" xml:id="fwazo">
<title>
Boot Subsystem in the GRUB Boot Environment</title>
<indexterm xml:id="indexterm-209">
<primary>boot subsystem in the GRUB boot environment</primary>
</indexterm>
<para>Boot devices are either local media or network devices. When you boot
from local media, the BIOS loads, then executes a 512-byte program that is
located in the first physical sector of the media. This program is supplied
by the operating system vendor. The program is then installed on the disk
as part of the normal Solaris software installation or upgrade process. After
the BIOS transfers control to this program, the OS takes over the system.</para>
<para>To boot a system from a network interface, a DHCP server is required.
A boot file server is also required. These servers can reside on the same
machine or on separate machines.  The de facto boot protocol for an x86 network
is PXE, which works in conjunction with DHCP. The BIOS boots the system from
a network interface. The BIOS then issues a DHCP request for the name of the
boot program and the IP address of the server that the program is to be downloaded
from. After the BIOS receives the DHCP response, the BIOS downloads the program
by using the TFTP protocol and executes the program. The boot program is supplied
by the OS vendor. You install the boot program on the boot file server.</para>
<para>Current operation system kernels are too large for the BIOS to load
directly. Therefore, the OS needs a boot subsystem to bootstrap the kernel
into existence. This process involves several stages, whereby a small program
loads and executes a larger program. Eventually, control is handed over to
the Solaris OS kernel. On x86 based systems, the Solaris OS uses the open
source GRUB program to bootstrap the kernel.</para>
</sect2>
<sect2 arch="x86" xml:id="fwazd">
<title>
Solaris Kernel Initialization Process
in the GRUB Boot Environment</title>
<indexterm xml:id="indexterm-210">
<primary>kernel initialization in the GRUB boot environment</primary>
</indexterm>
<caution>

<para>This section includes Solaris implementation details that are
subject to change in a future Solaris release or a future Solaris patch without
notice. You should not build procedures that rely on the details that are
described in this section.</para>
</caution>
<para>The <command>/platform/i86pc/multiboot</command> program is an <literal>ELF32</literal> executable that contains a header which is defined in the Multiboot
Specification. The multiboot program is responsible for performing the following
tasks:</para>
<itemizedlist>
<listitem>
<para>Interpreting the content of boot archive</para>
</listitem>
<listitem>
<para>Autodetecting whether the system is 64-bit capable</para>
</listitem>
<listitem>
<para>Selecting the best kernel mode for booting the system</para>
</listitem>
<listitem>
<para>Assembling core kernel modules in memory</para>
</listitem>
<listitem>
<para>Handing control of the system to the Solaris kernel</para>
</listitem>
</itemizedlist>
<para>After the kernel gains control of the system, the kernel initializes
the CPU, memory, and device subsystems. The kernel then mounts the root device,
which corresponds  to the <literal>bootpath</literal> and <literal>fstype</literal> properties
that are specified in the <filename>/boot/solaris/bootenv.rc</filename> file.
This file is part of the boot archive. If these properties are not specified
in the <filename>bootenv.rc</filename> file, or on the GRUB command line,
the root (<filename>/</filename>) file system defaults to UFS on <filename>/devices/ramdisk:a</filename>. The root (<filename>/</filename>) file system defaults to UFS
when you boot the installation miniroot. After the root device is mounted,
the kernel initializes the <command>sched</command> and <command>init</command> commands.
These commands start the Service Management Facility (SMF) services.</para>
</sect2>
<sect2 arch="x86" xml:id="fxjig">
<title>
How Multiple Operating Systems Are Supported
in the GRUB Boot Environment</title>
<indexterm xml:id="indexterm-211">
<primary>multiple operating systems in the GRUB boot environment</primary>
</indexterm>
<para>This section describes multiple operating systems that are supported
on the same disk with GRUB. The following is an example of an x86 based system
that has the Solaris Express 6/05 OS, the Solaris 9 OS, Linux, and Microsoft Windows installed on the
same disk.</para>
<table frame="topbot" xml:id="gbgfd">

<title>Sample GRUB Menu Configuration</title>
<tgroup cols="2" colsep="0" rowsep="0">
<colspec colwidth="28.94*"/>
<colspec colwidth="71.06*"/>
<thead>
<row rowsep="1">
<entry>
<para>Operating System</para>
</entry>
<entry>
<para>Location on Disk</para>
</entry>
</row>
</thead>
<tbody>
<row>
<entry>
<para>Microsoft Windows</para>
</entry>
<entry>
<para>
<literal>fdisk</literal> partition 0:</para>
</entry>
</row>
<row>
<entry>
<para>Linux</para>
</entry>
<entry>
<para>
<literal>fdisk</literal> partition 1:</para>
</entry>
</row>
<row>
<entry>
</entry>
<entry>
<para>
<literal>fdisk</literal> partition 2:</para>
</entry>
</row>
<row>
<entry>
<para>slice 0</para>
</entry>
<entry>
<para>Solaris 9 OS</para>
</entry>
</row>
<row>
<entry>
<para>slice 3</para>
</entry>
<entry>
<para>Solaris Express 6/05 OS</para>
</entry>
</row>
</tbody>
</tgroup>
</table>
<para>Based on the preceding information, the  GRUB menu appears as follows:</para>
<screen>title Solaris 6/05 Express
			root (hd0,2,d)
			kernel /platform/i86pc/multiboot
			module /platform/i86pc/boot_archive
title Solaris 9
			root (hd0,2,a)
			chainloader +1
			makeactivetitle Linux
			root (hd0,1)
			kernel &lt;from Linux GRUB menu...&gt;
			initrd &lt;from Linux GRUB menu...&gt;
title Windows
			root (hd0,0)
			chainloader +1</screen>
<para>The Solaris partition must be the active partition. Also, do not indicate <literal>makeactive</literal> under the Microsoft Windows menu. Doing so causes the
system to boot Microsoft Windows every time. Note that if Linux installed
GRUB on the master boot block, you cannot access the Solaris boot option.
The inability to access the Solaris boot option occurs whether or not you
designate it as the active partition. In this case, you can do one of the
following:</para>
<itemizedlist>
<listitem>
<para>Chain-load from the Linux GRUB by modifying the menu on Linux.</para>
<para>
<emphasis>Chain-loading</emphasis> is a mechanism for loading unsupported
operating systems by using another boot loader.</para>
</listitem>
<listitem>
<para>Replace the master boot sector with the Solaris GRUB by running
the <command>installgrub</command> command with the <option>
m</option> option:</para>
<screen># <userinput>installgrub -m /boot/grub/stage1 /boot/grub/stage2 /dev/rdsk/<replaceable>root-slice</replaceable>
</userinput>
</screen>
<para>See <olink remap="external" targetdoc="819-2240" targetptr="installgrub-1m">
<citerefentry>
<refentrytitle>installgrub</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> for more information.</para>
</listitem>
</itemizedlist>
</sect2>
<sect2 arch="x86" xml:id="fwazj">
<title>
Management of the GRUB Boot Archive</title>
<indexterm xml:id="indexterm-212">
<primary>reference</primary>
<secondary>managing the GRUB boot archive</secondary>
</indexterm>
<indexterm xml:id="indexterm-213">
<primary>GRUB boot archive</primary>
<secondary>managing</secondary>
</indexterm>
<indexterm xml:id="indexterm-214">
<primary>managing the GRUB boot archive</primary>
</indexterm>
<indexterm xml:id="indexterm-215">
<primary>boot archive</primary>
<secondary>managing</secondary>
<tertiary>GRUB</tertiary>
</indexterm>
<para>The boot archive contains core kernel modules, including drivers and
configuration files, that are needed to initialize the OS kernel. After the
I/O subsystem is initialized, the kernel mounts the root (<filename>/</filename>)
file system on the real root device. The Solaris OS updates the boot archive
from files on the root (<filename>/</filename>) file system whenever necessary.
This update typically occurs when a kernel patch is applied or when a driver
package is added. To detect any file updates that were performed manually,
the boot archive might also be updated during system shutdown.</para>
<para>If a system failure, a power failure, or a kernel panic occurs, immediately
following a kernel file update, the boot archive and the root (<filename>/</filename>)
file system might not be synchronized. Although the system might still boot
with the old boot archive, you should boot the system in the failsafe archive
to rebuild the boot archive. On mission critical systems, where system availability
is essential, you might choose to set up a <command>cron</command> job to
run the <command>bootadm</command> command on a regular basis. If the boot
archive does not need to be updated, this process uses very little resources
and usually takes only 0.1 to 0.2 seconds to complete.</para>
<para>The boot archive is updated by using the <command>bootadm</command> command.
Immediately after you perform a system upgrade or apply a patch, manually
rebuild the boot archive by running the following command as superuser:</para>
<screen># <userinput>bootadm update-archive</userinput>
</screen>
<para>For more information, see the <olink remap="external" targetdoc="819-2240" targetptr="bootadm-1m">
<citerefentry>
<refentrytitle>bootadm</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man page. For step-by-step
instructions, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="gcbcn">
How to Boot the Failsafe Archive to Forcibly Update a Corrupt Boot Archive</olink>.</para>
</sect2>
<sect2 xml:id="fwbow">
<title>GRUB Boot Archives</title>
<indexterm xml:id="indexterm-216">
<primary>archive</primary>
<secondary>GRUB failsafe and normal</secondary>
<tertiary>description</tertiary>
</indexterm>
<indexterm xml:id="indexterm-217">
<primary>normal archive in GRUB</primary>
<secondary>boot archive</secondary>
<tertiary>reference</tertiary>
</indexterm>
<indexterm xml:id="indexterm-218">
<primary>GRUB archives</primary>
<secondary>failsafe and normal</secondary>
<tertiary>reference</tertiary>
</indexterm>
<indexterm xml:id="indexterm-219">
<primary>failsafe archive</primary>
<secondary>GRUB reference</secondary>
<tertiary>description</tertiary>
</indexterm>
<para>GRUB has two kinds of boot archives:</para>
<itemizedlist>
<listitem>
<para>Failsafe boot archive</para>
</listitem>
<listitem>
<para>Primary boot archive</para>
</listitem>
</itemizedlist>
<para>A failsafe boot archive has the following benefits and characteristics:</para>
<itemizedlist>
<listitem>
<para>Is self-sufficient</para>
</listitem>
<listitem>
<para>Can boot on its own</para>
</listitem>
<listitem>
<para>Is created by default during installation of the OS</para>
</listitem>
<listitem>
<para>Requires no maintenance</para>
</listitem>
</itemizedlist>
<para>A primary boot archive shadows a root (<filename>/</filename>) file
system. This boot archive contains all of the kernel modules, <filename>driver.conf</filename> files, plus a few configuration files. These files are located
in the <filename>/etc</filename> directory. The files in the boot archive
are read by the kernel before the root (<filename>/</filename>) file system
is mounted. After the root (<filename>/</filename>) file system is mounted,
the boot archive is discarded by the kernel from memory. Then, file I/O is
performed against the root device.</para>
<para>By default, the primary boot archive contains the following files:</para>
<itemizedlist>
<listitem>
<para>
<filename>boot/solaris/bootenv.rc</filename>
</para>
</listitem>
<listitem>
<para>
<filename>boot/solaris.xpm</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/dacf.conf</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/devices</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/driver_aliases</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/driver_classes</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/mach</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/name_to_sysnum</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/path_to_inst</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/rtc_config</filename>
</para>
</listitem>
<listitem>
<para>
<filename>etc/system</filename>
</para>
</listitem>
<listitem>
<para>
<filename>kernel</filename>
</para>
</listitem>
<listitem>
<para>
<filename>platform/i86pc/biosint</filename>
</para>
</listitem>
<listitem>
<para>
<filename>platform/i86pc/kernel</filename>
</para>
</listitem>
</itemizedlist>
<para>If any files in the archive are updated, the boot archive must be rebuilt.
For modifications to take effect, the rebuild of the archive must take place
before the next system reboot.</para>
<para>To rebuild the boot archive manually, use the <command>bootadm</command> command.
You can also rebuild the boot archive by booting the system in the failsafe
archive which is an available option in the GRUB main menu. During the failsafe
boot procedure, when prompted by the system, type <command>y</command> to
rebuild the primary boot archive. For more information, see <olink remap="internal" targetdoc="chapter-11.xml" targetptr="fvznb">
How to Boot the Failsafe Archive for Recovery Purposes</olink>.</para>
</sect2>
</sect1>
</chapter>
