<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- GenHTML@17046-->
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title><tt>sched</tt> Provider - Solaris Dynamic Tracing Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2005-09-01">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/ipg.css">
</head>

<body leftmargin="0" topmargin="0" marginheight="0" marginwidth="0" bgcolor="#ffffff"  class="a0v0">
<!--stopindex-->

<a name="top"></a>

<!-- BEGIN A1 COMPONENT V.0 -->
<div class="a1">
<div class="a1v0">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com">sun.com</a>
<a href="http://docs.sun.com/" class="dividelink">docs.sun.com</a>
</span>
</td><td align="right" nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com/MySun/">My Sun</a>
<a href="http://www.sun.com/worldwide/" class="dividelink">Worldwide Sites</a>
</span>
</td></tr>
</table>
</div>
</div>
<!-- END A1 COMPONENT V.0 -->

<!-- BEGIN A2 COMPONENT V.0 -->
<div class="a2" id="a2v0">
<div class="cornerTL">
<div class="cornerTR">
<div class="cornerBL">
<div class="cornerBR">
<div class="a2topiclinks">
<table cellpadding="1" cellspacing="0" border="0">
<tr valign="bottom">
<td><a href="http://www.sun.com/" title="Home Page"><img src="css/a.gif" alt="Home Page" width="104" height="58" border="0" class="sunlogo"></a></td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip1"></td>
<td class="navlinks" id="navlink1">
<div>
<a id="glink1" href="http://www.sun.com/products/">Products</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip2"></td>
<td class="navlinks" id="navlink2">
<div>
<a id="glink2" href="http://www.sun.com/downloads/">Downloads</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip3"></td><td class="navlinks" id="navlink3">
<div>
<a id="glink3" href="http://www.sun.com/service/">Service &amp; Solutions</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip4"></td><td class="navlinks" id="navlink4">
<div>
<a id="glink4" href="http://www.sun.com/support/">Support</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip5"></td><td class="navlinks" id="navlink5">
<div>
<a id="glink5" href="http://www.sun.com/training/">Training</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip6"></td><td class="navlinks" id="navlink6">
<div>
<a id="glink6" href="http://research.sun.com/">Research</a>
</div>
</td>
</tr>
</table>
</div>

</div></div></div></div>
</div>
<!-- END A2 COMPONENT V.0 -->

<!-- BEGIN BREADCRUMB -->
<div id="breadcrumb">
<?GenHTML ReferencePage >Solaris Dynamic Tracing Guide<?GenHTML /ReferencePage>
</div><br />
<!-- END BREADCRUMB -->

<!-- BEGIN WRAPPER TABLE, 1 COLUMN, MAIN -->
<table border="0" cellpadding="0" cellspacing="10" width="100%">
<tr valign="bottom"><td width="100%" valign="top">
<!-- BEGIN CENTRAL COLUMN COMPONENTS -->

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr><td colspan="5"></td></tr>
<tr>
<td></td>
<td style="width: 60%">&nbsp;</td>
<td><a href="p47.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p49.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->

</td></tr>
<tr><td width="100%" valign="top">
<a name="skip2content"> </a>

<!--startindex-->
<div class="maincontent">
<a name="chp-sched"></a>Chapter&nbsp;26<h3><tt>sched</tt> Provider</h3><p>The <tt>sched</tt> provider makes available probes related to CPU scheduling. Because CPUs are the one resource that all threads must consume, the <tt>sched</tt> provider is very useful for understanding systemic behavior. For example, using the <tt>sched</tt> provider, you can understand when and why threads sleep, run, change priority, or wake other threads.</p>
<a name="gelro"></a><h3>Probes</h3>
<p><a name="indexterm-393"></a><a name="indexterm-394"></a>The <tt>sched</tt> probes are described in <a href="p48.html#tbl-sched">Table 26-1</a>.</p>
<a name="tbl-sched"></a>Table 26-1 <tt>sched</tt> Probes<table><tr><th valign="top"><p>Probe</p>
</th><th valign="top"><p>Description</p>
</th></tr>
<tr><td><p><tt>change-pri</tt></p>
</td><td><p>Probe that fires whenever a thread's priority is about to be changed. The <tt>lwpsinfo_t</tt> of the thread is pointed to by <tt>args[0]</tt>. The thread's current priority is in the <tt>pr_pri</tt> field of this structure. The <tt>psinfo_t</tt> of the process containing the thread is pointed to by <tt>args[1]</tt>. The thread's new priority is contained in <tt>args[2]</tt>.</p>
</td></tr>
<tr><td><p><tt>dequeue</tt></p>
</td><td><p>Probe that fires immediately before a runnable thread is dequeued from a run queue. The <tt>lwpsinfo_t</tt> of the thread being dequeued is pointed to by <tt>args[0]</tt>. The <tt>psinfo_t</tt> of the process containing the thread is pointed to by <tt>args[1]</tt>. The <tt>cpuinfo_t</tt> of the CPU from which the thread is being dequeued is pointed to by <tt>args[2]</tt>. If the thread is being dequeued from a run queue that is not associated with a particular CPU, the <tt>cpu_id</tt> member of this structure will be <tt>-1</tt>.</p>
</td></tr>
<tr><td><p><tt>enqueue</tt></p>
</td><td><p>Probe that fires immediately before a runnable thread is enqueued to a run queue. The <tt>lwpsinfo_t</tt> of the thread being enqueued is pointed to by <tt>args[0]</tt>. The <tt>psinfo_t</tt> of the process containing the thread is pointed to by <tt>args[1]</tt>. The <tt>cpuinfo_t</tt> of the CPU to which the thread is being enqueued is pointed to by <tt>args[2]</tt>. If the thread is being enqueued from a run queue that is not associated with a particular CPU, the <tt>cpu_id</tt> member of this structure will be <tt>-1</tt>. The value in <tt>args[3]</tt> is a boolean indicating whether the thread will be enqueued to the front of the run queue. The value is non-zero if the thread will be enqueued at the front of the run queue, and zero if the thread will be enqueued at the back of the run queue.</p>
</td></tr>
<tr><td><p><tt>off-cpu</tt></p>
</td><td><p>Probe that fires when the current CPU is about to end execution of a thread. The <tt>curcpu</tt> variable indicates the current CPU. The <tt>curlwpsinfo</tt> variable indicates the thread that is ending execution. The <tt>curpsinfo</tt> variable describes the process containing the current thread. The <tt>lwpsinfo_t</tt> structure of the thread that the current CPU will next execute is pointed to by <tt>args[0]</tt>. The <tt>psinfo_t</tt> of the process containing the next thread is pointed to by <tt>args[1]</tt>.</p>
</td></tr>
<tr><td><p><tt>on-cpu</tt></p>
</td><td><p>Probe that fires when a CPU has just begun execution of a thread. The <tt>curcpu</tt> variable indicates the current CPU. The <tt>curlwpsinfo</tt> variable indicates the thread that is beginning execution. The <tt>curpsinfo</tt> variable describes the process containing the current thread.</p>
</td></tr>
<tr><td><p><tt>preempt</tt></p>
</td><td><p>Probe that fires immediately before the current thread is preempted. After this probe fires, the current thread will select a thread to run and the <tt>off-cpu</tt> probe will fire for the current thread. In some cases, a thread on one CPU will be preempted, but the preempting thread will run on another CPU in the meantime. In this situation, the <tt>preempt</tt> probe will fire, but the dispatcher will be unable to find a higher priority thread to run and the <tt>remain-cpu</tt> probe will fire instead of the <tt>off-cpu</tt> probe.</p>
</td></tr>
<tr><td><p><tt>remain-cpu</tt></p>
</td><td><p>Probe that fires when a scheduling decision has been made, but the dispatcher has elected to continue to run the current thread. The <tt>curcpu</tt> variable indicates the current CPU. The <tt>curlwpsinfo</tt> variable indicates the thread that is beginning execution. The <tt>curpsinfo</tt> variable describes the process containing the current thread.</p>
</td></tr>
<tr><td><p><tt>schedctl-nopreempt</tt></p>
</td><td><p>Probe that fires when a thread is preempted and then re-enqueued at the <b>front</b> of the run queue due to a preemption control request. See <tt>schedctl_init</tt>(3C) for details on preemption control. As with <tt>preempt</tt>, either <tt>off-cpu</tt> or <tt>remain-cpu</tt> will fire after <tt>schedctl-nopreempt</tt>. Because <tt>schedctl-nopreempt</tt> denotes a re-enqueuing of the current thread at the front of the run queue, <tt>remain-cpu</tt> is more likely to fire after <tt>schedctl-nopreempt</tt> than <tt>off-cpu</tt>. The <tt>lwpsinfo_t</tt> of the thread being preempted is pointed to by <tt>args[0]</tt>. The <tt>psinfo_t</tt> of the process containing the thread is pointed to by <tt>args[1]</tt>.</p>
</td></tr>
<tr><td><p><tt>schedctl-preempt</tt></p>
</td><td><p>Probe that fires when a thread that is using preemption control is nonetheless preempted and re-enqueued at the <b>back</b> of the run queue. See <tt>schedctl_init</tt>(3C) for details on preemption control. As with <tt>preempt</tt>, either <tt>off-cpu</tt> or <tt>remain-cpu</tt> will fire after <tt>schedctl-preempt</tt>. Like <tt>preempt</tt> (and unlike <tt>schedctl-nopreempt</tt>), <tt>schedctl-preempt</tt> denotes a re-enqueuing of the current thread at the back of the run queue. As a result, <tt>off-cpu</tt> is more likely to fire after <tt>schedctl-preempt</tt> than <tt>remain-cpu</tt>. The <tt>lwpsinfo_t</tt> of the thread being preempted is pointed to by <tt>args[0]</tt>. The <tt>psinfo_t</tt> of the process containing the thread is pointed to by <tt>args[1]</tt>.</p>
</td></tr>
<tr><td><p><tt>schedctl-yield</tt></p>
</td><td><p>Probe that fires when a thread that had preemption control enabled and its time slice artificially extended executed code to yield the CPU to other threads.</p>
</td></tr>
<tr><td><p><tt>sleep</tt></p>
</td><td><p>Probe that fires immediately before the current thread sleeps on a synchronization object. The type of the synchronization object is contained in the <tt>pr_stype</tt> member of the <tt>lwpsinfo_t</tt> pointed to by <tt>curlwpsinfo</tt>. The address of the synchronization object is contained in the <tt>pr_wchan</tt> member of the <tt>lwpsinfo_t</tt> pointed to by <tt>curlwpsinfo</tt>. The meaning of this address is a private implementation detail, but the address value may be treated as a token unique to the synchronization object.</p>
</td></tr>
<tr><td><p><tt>surrender</tt></p>
</td><td><p>Probe that fires when a CPU has been instructed by another CPU to make a scheduling decision &ndash; often because a higher-priority thread has become runnable.</p>
</td></tr>
<tr><td><p><tt>tick</tt></p>
</td><td><p>Probe that fires as a part of clock tick-based accounting. In clock tick-based accounting, CPU accounting is performed by examining which threads and processes are running when a fixed-interval interrupt fires. The <tt>lwpsinfo_t</tt> that corresponds to the thread that is being assigned CPU time is pointed to by <tt>args[0]</tt>. The <tt>psinfo_t</tt> that corresponds to the process that contains the thread is pointed to by <tt>args[1]</tt>.</p>
</td></tr>
<tr><td><p><tt>wakeup</tt></p>
</td><td><p>Probe that fires immediately before the current thread wakes a thread sleeping on a synchronization object. The <tt>lwpsinfo_t</tt> of the sleeping thread is pointed to by <tt>args[0]</tt>. The <tt>psinfo_t</tt> of the process containing the sleeping thread is pointed to by <tt>args[1]</tt>. The type of the synchronization object is contained in the <tt>pr_stype</tt> member of the <tt>lwpsinfo_t</tt> of the sleeping thread. The address of the synchronization object is contained in the <tt>pr_wchan</tt> member of the <tt>lwpsinfo_t</tt> of the sleeping thread. The meaning of this address is a private implementation detail, but the address value may be treated as a token unique to the synchronization object.</p>
</td></tr>
</table><a name="chp-sched-1"></a><h3>Arguments</h3>
<p>The argument types for the <tt>sched</tt> probes are listed in <a href="p48.html#tbl-sched-args">Table 26-2</a>; the arguments are described in <a href="p48.html#tbl-sched">Table 26-1</a>.</p>
<a name="tbl-sched-args"></a>Table 26-2 <tt>sched</tt> Probe Arguments<table><tr><th valign="top"><p>Probe</p>
</th><th valign="top"><p><tt>args[0]</tt></p>
</th><th valign="top"><p><tt>args[1]</tt></p>
</th><th valign="top"><p><tt>args[2]</tt></p>
</th><th valign="top"><p><tt>args[3]</tt></p>
</th></tr>
<tr><td><p><tt>change-pri</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p><tt>pri_t</tt></p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>dequeue</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p><tt>cpuinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>enqueue</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p><tt>cpuinfo_t *</tt></p>
</td><td><p><tt>int</tt></p>
</td></tr>
<tr><td><p><tt>off-cpu</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>on-cpu</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>preempt</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>remain-cpu</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>schedctl-nopreempt</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>schedctl-preempt</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>schedctl-yield</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>sleep</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>surrender</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>tick</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
<tr><td><p><tt>wakeup</tt></p>
</td><td><p><tt>lwpsinfo_t *</tt></p>
</td><td><p><tt>psinfo_t *</tt></p>
</td><td><p>&mdash;</p>
</td><td><p>&mdash;</p>
</td></tr>
</table><p>As <a href="p48.html#tbl-sched-args">Table 26-2</a> indicates, many <tt>sched</tt> probes have arguments consisting of a pointer to an <tt>lwpsinfo_t</tt> and a pointer to a <tt>psinfo_t</tt>, indicating a thread and the process containing the thread, respectively. These structures are described in detail in <a href="p46.html#chp-proc-lwpsinfo"><tt>lwpsinfo_t</tt></a> and <a href="p46.html#chp-proc-psinfo"><tt>psinfo_t</tt></a>, respectively.</p>
<a name="chp-sched-cpuinfo"></a><h4><tt>cpuinfo_t</tt></h4>
<p>The <tt>cpuinfo_t</tt> structure defines a CPU. As <a href="p48.html#tbl-sched-args">Table 26-2</a> indicates, arguments to both the <tt>enqueue</tt> and <tt>dequeue</tt> probes include a pointer to a <tt>cpuinfo_t</tt>. Additionally, the <tt>cpuinfo_t</tt> corresponding to the current CPU is pointed to by the <tt>curcpu</tt> variable. The definition of the <tt>cpuinfo_t</tt> structure is as follows:</p>
<pre>typedef struct cpuinfo {
	processorid_t cpu_id;           /* CPU identifier */
	psetid_t cpu_pset;              /* processor set identifier */
	chipid_t cpu_chip;              /* chip identifier */
	lgrp_id_t cpu_lgrp;             /* locality group identifer */
	processor_info_t cpu_info;      /* CPU information */
} cpuinfo_t;</pre><p>The <tt>cpu_id</tt> member is the processor identifier, as returned by <tt>psrinfo</tt>(1M) and <tt>p_online</tt>(2).</p>
<p>The <tt>cpu_pset</tt> member is the processor set that contains the CPU, if any. See <tt>psrset</tt>(1M) for more details on processor sets.</p>
<p>The <tt>cpu_chip</tt> member is the identifier of the physical chip. Physical chips may contain several CPUs. See <tt>psrinfo</tt>(1M) for more information.</p>
<p>The <tt>cpu_lgrp</tt> member is the identifier of the latency group associated with the CPU. See <tt>liblgrp</tt>(3LIB) for details on latency groups.</p>
<p>The <tt>cpu_info</tt> member is the <tt>processor_info_t</tt> structure associated with the CPU, as returned by <tt>processor_info</tt>(2).</p>
<a name="chp-sched-2"></a><h3>Examples</h3>
<a name="chp-sched-5"></a><h4><tt>on-cpu</tt> and <tt>off-cpu</tt></h4>
<p>One common question you might want answered is which CPUs are running threads and for how long. You can use the <tt>on-cpu</tt> and <tt>off-cpu</tt> probes to easily answer this question on a system-wide basis as shown in the following example:</p>
<pre>sched:::on-cpu
{
	self->ts = timestamp;
}

sched:::off-cpu
/self->ts/
{
	@[cpu] = quantize(timestamp - self->ts);
	self->ts = 0;
}</pre><p>Running the above script results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./where.d</b></tt>
dtrace: script './where.d' matched 5 probes
<tt><b>^C</b></tt>

        0
           value  ------------- Distribution ------------- count    
            2048 |                                         0        
            4096 |@@                                       37       
            8192 |@@@@@@@@@@@@@                            212      
           16384 |@                                        30       
           32768 |                                         10       
           65536 |@                                        17       
          131072 |                                         12       
          262144 |                                         9        
          524288 |                                         6        
         1048576 |                                         5        
         2097152 |                                         1        
         4194304 |                                         3        
         8388608 |@@@@                                     75       
        16777216 |@@@@@@@@@@@@                             201      
        33554432 |                                         6        
        67108864 |                                         0        

        1
           value  ------------- Distribution ------------- count    
            2048 |                                         0        
            4096 |@                                        6        
            8192 |@@@@                                     23       
           16384 |@@@                                      18       
           32768 |@@@@                                     22       
           65536 |@@@@                                     22       
          131072 |@                                        7        
          262144 |                                         5        
          524288 |                                         2        
         1048576 |                                         3        
         2097152 |@                                        9        
         4194304 |                                         4        
         8388608 |@@@                                      18       
        16777216 |@@@                                      19       
        33554432 |@@@                                      16       
        67108864 |@@@@                                     21       
       134217728 |@@                                       14       
       268435456 |                                         0</pre><p>The above output shows that on CPU 1 threads tend to run for less than 100 microseconds at a stretch, or for approximately 10 milliseconds. A noticable gap between the two clusters of data shown in the histogram. You also might be interested in knowing which CPUs are running a particular process. You can use the <tt>on-cpu</tt> and <tt>off-cpu</tt> probes for answering this question as well. The following script displays which CPUs run a specified application over a period of ten seconds:</p>
<pre>#pragma D option quiet

dtrace:::BEGIN
{
	start = timestamp;
}

sched:::on-cpu
/execname == $$1/
{
	self->ts = timestamp;
}

sched:::off-cpu
/self->ts/
{
	@[cpu] = sum(timestamp - self->ts);
	self->ts = 0;
}

profile:::tick-1sec
/++x == 10/
{
	exit(0);
}
        
dtrace:::END
{
	printf("CPU distribution over %d seconds:\n\n",
	    (timestamp - start) / 1000000000);
	printf("CPU microseconds\n--- ------------\n");
	normalize(@, 1000);
	printa("%3d %@d\n", @);
}</pre><p>Running the above script on a large mail server and specifying the IMAP daemon results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./whererun.d imapd</b></tt>
CPU distribution of imapd over 10 seconds:

CPU microseconds
--- ------------
 15 10102
 12 16377
 21 25317
 19 25504
 17 35653
 13 41539
 14 46669
 20 57753
 22 70088
 16 115860
 23 127775
 18 160517</pre><p>Solaris takes into account the amount of time that a thread has been sleeping when selecting a CPU on which to run the thread: a thread that has been sleeping for less time tends not to migrate. You can use the <tt>off-cpu</tt> and <tt>on-cpu</tt> probes to observe this behavior:</p>
<pre>sched:::off-cpu
/curlwpsinfo->pr_state == SSLEEP/
{
	self->cpu = cpu;
	self->ts = timestamp;
}

sched:::on-cpu
/self->ts/
{
	@[self->cpu == cpu ?
	    "sleep time, no CPU migration" : "sleep time, CPU migration"] =
	    lquantize((timestamp - self->ts) / 1000000, 0, 500, 25);
	self->ts = 0;
	self->cpu = 0;
}</pre><p>Running the above script for approximately 30 seconds results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./howlong.d</b></tt>
dtrace: script './howlong.d' matched 5 probes
<tt><b>^C</b></tt>
 sleep time, CPU migration                         
           value  -------------- Distribution ------------ count    
             &lt; 0 |                                         0        
               0 |@@@@@@@                                  6838     
              25 |@@@@@                                    4714     
              50 |@@@                                      3108     
              75 |@                                        1304     
             100 |@                                        1557     
             125 |@                                        1425     
             150 |                                         894      
             175 |@                                        1526     
             200 |@@                                       2010     
             225 |@@                                       1933     
             250 |@@                                       1982     
             275 |@@                                       2051     
             300 |@@                                       2021     
             325 |@                                        1708     
             350 |@                                        1113     
             375 |                                         502      
             400 |                                         220      
             425 |                                         106      
             450 |                                         54       
             475 |                                         40       
          >= 500 |@                                        1716     

  sleep time, no CPU migration                      
           value  -------------- Distribution ------------ count    
             &lt; 0 |                                         0        
               0 |@@@@@@@@@@@@                             58413    
              25 |@@@                                      14793    
              50 |@@                                       10050    
              75 |                                         3858     
             100 |@                                        6242     
             125 |@                                        6555     
             150 |                                         3980     
             175 |@                                        5987     
             200 |@                                        9024     
             225 |@                                        9070     
             250 |@@                                       10745    
             275 |@@                                       11898    
             300 |@@                                       11704    
             325 |@@                                       10846    
             350 |@                                        6962     
             375 |                                         3292     
             400 |                                         1713     
             425 |                                         585      
             450 |                                         201      
             475 |                                         96       
          >= 500 |                                         3946</pre><p>The example output shows that there are many more occurences of non-migration than migration. Also, when sleep times are longer, migrations are more likely. The distributions are noticeably different in the sub-100 millisecond range, but look very similar as the sleep times get longer. This result would seem to indicate that sleep time is not factored into the scheduling decision once a certain threshold is exceeded.</p>
<p>The final example using <tt>off-cpu</tt> and <tt>on-cpu</tt> shows how to use these probes along with the <tt>pr_stype</tt> field to determine why threads sleep and for how long:</p>
<pre>sched:::off-cpu
/curlwpsinfo->pr_state == SSLEEP/
{
	/*
	 * We're sleeping.  Track our sobj type.
	 */
	self->sobj = curlwpsinfo->pr_stype;
	self->bedtime = timestamp;
}

sched:::off-cpu
/curlwpsinfo->pr_state == SRUN/
{
	self->bedtime = timestamp;
}

sched:::on-cpu
/self->bedtime &amp;&amp; !self->sobj/
{
	@["preempted"] = quantize(timestamp - self->bedtime);
	self->bedtime = 0;
}

sched:::on-cpu
/self->sobj/
{
	@[self->sobj == SOBJ_MUTEX ? "kernel-level lock" :
	    self->sobj == SOBJ_RWLOCK ? "rwlock" :
	    self->sobj == SOBJ_CV ? "condition variable" :
	    self->sobj == SOBJ_SEMA ? "semaphore" :
	    self->sobj == SOBJ_USER ? "user-level lock" :
	    self->sobj == SOBJ_USER_PI ? "user-level prio-inheriting lock" :
	    self->sobj == SOBJ_SHUTTLE ? "shuttle" : "unknown"] =
	    quantize(timestamp - self->bedtime);

	self->sobj = 0;
	self->bedtime = 0;
}</pre><p>Running the above script for several seconds results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./whatfor.d</b></tt>
dtrace: script './whatfor.d' matched 12 probes
<tt><b>^C</b></tt>
 kernel-level lock
           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |@@@@@@@@                                 3        
           65536 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@            11       
          131072 |@@                                       1        
          262144 |                                         0        

  preempted
           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |                                         4        
           65536 |@@@@@@@@                                 408      
          131072 |@@@@@@@@@@@@@@@@@@@@@@                   1031     
          262144 |@@@                                      156      
          524288 |@@                                       116      
         1048576 |@                                        51       
         2097152 |                                         42       
         4194304 |                                         16       
         8388608 |                                         15       
        16777216 |                                         4        
        33554432 |                                         8        
        67108864 |                                         0        

  semaphore
           value  -------------- Distribution ------------ count    
           32768 |                                         0        
           65536 |@@                                       61       
          131072 |@@@@@@@@@@@@@@@@@@@@@@@@                 553      
          262144 |@@                                       63       
          524288 |@                                        36       
         1048576 |                                         7        
         2097152 |                                         22       
         4194304 |@                                        44       
         8388608 |@@@                                      84       
        16777216 |@                                        36       
        33554432 |                                         3        
        67108864 |                                         6        
       134217728 |                                         0        
       268435456 |                                         0        
       536870912 |                                         0        
      1073741824 |                                         0        
      2147483648 |                                         0        
      4294967296 |                                         0        
      8589934592 |                                         0        
     17179869184 |                                         1        
     34359738368 |                                         0        

  shuttle                                           
           value  -------------- Distribution ------------ count    
           32768 |                                         0        
           65536 |@@@@@                                    2        
          131072 |@@@@@@@@@@@@@@@@                         6        
          262144 |@@@@@                                    2        
          524288 |                                         0        
         1048576 |                                         0        
         2097152 |                                         0        
         4194304 |@@@@@                                    2        
         8388608 |                                         0        
        16777216 |                                         0        
        33554432 |                                         0        
        67108864 |                                         0        
       134217728 |                                         0        
       268435456 |                                         0        
       536870912 |                                         0        
      1073741824 |                                         0        
      2147483648 |                                         0        
      4294967296 |@@@@@                                    2        
      8589934592 |                                         0        
     17179869184 |@@                                       1        
     34359738368 |                                         0        

  condition variable                                
           value  -------------- Distribution ------------ count    
           32768 |                                         0        
           65536 |                                         122      
          131072 |@@@@@                                    1579     
          262144 |@                                        340      
          524288 |                                         268      
         1048576 |@@@                                      1028     
         2097152 |@@@                                      1007     
         4194304 |@@@                                      1176     
         8388608 |@@@@                                     1257     
        16777216 |@@@@@@@@@@@@@@                           4385     
        33554432 |                                         295      
        67108864 |                                         157      
       134217728 |                                         96       
       268435456 |                                         48       
       536870912 |                                         144      
      1073741824 |                                         10       
      2147483648 |                                         22       
      4294967296 |                                         18       
      8589934592 |                                         5        
     17179869184 |                                         6        
     34359738368 |                                         4        
     68719476736 |                                         0</pre><a name="chp-sched-10"></a><h4><tt>enqueue</tt> and <tt>dequeue</tt></h4>
<p>When a CPU becomes idle, the dispatcher looks for work enqueued on other (non-idle) CPUs. The following example uses the <tt>dequeue</tt> probe to understand how often applications are transferred and by which CPU:</p>
<pre>#pragma D option quiet

sched:::dequeue
/args[2]->cpu_id != -1 &amp;&amp; cpu != args[2]->cpu_id &amp;&amp;
    (curlwpsinfo->pr_flag &amp; PR_IDLE)/
{
	@[stringof(args[1]->pr_fname), args[2]->cpu_id] =
	    lquantize(cpu, 0, 100);
}

END
{
	printa("%s stolen from CPU %d by:\n%@d\n", @);
}</pre><p>The tail of the output from running the above script on a 4 CPU system results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./whosteal.d</b></tt>
<tt><b>^C</b></tt>
...
 nscd stolen from CPU 1 by:

           value  -------------- Distribution ------------ count    
               1 |                                         0        
               2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 28       
               3 |                                         0        

snmpd stolen from CPU 1 by:

           value  -------------- Distribution ------------ count    
             &lt; 0 |                                         0        
               0 |@                                        1        
               1 |                                         0        
               2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     31       
               3 |@@                                       2        
               4 |                                         0        

sched stolen from CPU 1 by:

           value  -------------- Distribution ------------ count    
             &lt; 0 |                                         0        
               0 |@@                                       3        
               1 |                                         0        
               2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         36       
               3 |@@@@                                     5        
               4 |                                         0</pre><p>Instead of knowing which CPUs took which work, you might want to know the CPUs on which processes and threads are waiting to run. You can use the <tt>enqueue</tt> and <tt>dequeue</tt> probes together to answer this question:</p>
<pre>sched:::enqueue
{
	self->ts = timestamp;
}

sched:::dequeue
/self->ts/
{
	@[args[2]->cpu_id] = quantize(timestamp - self->ts);
	self->ts = 0;
}</pre><p>Running the above script for several seconds results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./qtime.d</b></tt>
dtrace: script './qtime.d' matched 5 probes
<tt><b>^C</b></tt>
       -1
           value  -------------- Distribution ------------ count    
            4096 |                                         0        
            8192 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 2        
           16384 |                                         0        

        0
           value  -------------- Distribution ------------ count    
            1024 |                                         0        
            2048 |@@@@@@@@@@@@@@@                          262      
            4096 |@@@@@@@@@@@@@                            227      
            8192 |@@@@@                                    87       
           16384 |@@@                                      54       
           32768 |                                         7        
           65536 |                                         9        
          131072 |                                         1        
          262144 |                                         5        
          524288 |                                         4        
         1048576 |                                         2        
         2097152 |                                         0        
         4194304 |                                         0        
         8388608 |                                         0        
        16777216 |                                         1        
        33554432 |                                         2        
        67108864 |                                         2        
       134217728 |                                         0        
       268435456 |                                         0        
       536870912 |                                         0        
      1073741824 |                                         1        
      2147483648 |                                         1        
      4294967296 |                                         0        

        1
           value  -------------- Distribution ------------ count    
            1024 |                                         0        
            2048 |@@@@                                     49       
            4096 |@@@@@@@@@@@@@@@@@@@@                     241      
            8192 |@@@@@@@                                  91       
           16384 |@@@@                                     55       
           32768 |                                         7        
           65536 |                                         3        
          131072 |                                         2        
          262144 |                                         1        
          524288 |                                         0        
         1048576 |                                         0        
         2097152 |                                         0        
         4194304 |                                         0        
         8388608 |                                         0        
        16777216 |                                         0        
        33554432 |                                         3        
        67108864 |                                         1        
       134217728 |                                         4        
       268435456 |                                         2        
       536870912 |                                         0        
      1073741824 |                                         3        
      2147483648 |                                         2        
      4294967296 |                                         0</pre><p>Notice the non-zero values at the bottom of the example output. These data points reveal several instances on both CPUs where a thread was enqueued to run for several <b>seconds</b>.</p>
<p>Instead of looking at wait times, you might want to examine the length of the run queue over time. Using the <tt>enqueue</tt> and <tt>dequeue</tt> probes, you can set up an associative array to track the queue length:</p>
<pre>sched:::enqueue
{
	this->len = qlen[args[2]->cpu_id]++;
	@[args[2]->cpu_id] = lquantize(this->len, 0, 100);
}

sched:::dequeue
/qlen[args[2]->cpu_id]/
{
	qlen[args[2]->cpu_id]&mdash;;
}</pre><p>Running the above script for approximately 30 seconds on a largely idle uniprocessor laptop system results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./qlen.d</b></tt>
dtrace: script './qlen.d' matched 5 probes
<tt><b>^C</b></tt>
        0
           value  -------------- Distribution ------------ count    
             &lt; 0 |                                         0        
               0 |@@@@@@@@@@@@@@@@@@@@@@@@@                110626   
               1 |@@@@@@@@@                                41142    
               2 |@@                                       12655    
               3 |@                                        5074     
               4 |                                         1722     
               5 |                                         701      
               6 |                                         302      
               7 |                                         63       
               8 |                                         23       
               9 |                                         12       
              10 |                                         24       
              11 |                                         58       
              12 |                                         14       
              13 |                                         3        
              14 |                                         0</pre><p>The output is roughly what you would expect for an idle system: the majority of the time that a runnable thread is enqueued, the run queue was very short (three or fewer threads in length). However, given that the system was largely idle, the exceptional data points at the bottom of the table might be unexpected. For example, why was the run queue as long as 13 runnable threads? To explore this question, you could write a D script that displays the contents of the run queue when the length of the run queue is long. This problem is complicated because D enablings cannot iterate over data structures, and therefore cannot simply iterate over the entire run queue. Even if D enablings could do so, you should avoid dependencies on the kernel's internal data structures.</p>
<p>For this type of script, you would enable the <tt>enqueue</tt> and <tt>dequeue</tt> probes and use both speculations and associative arrays. Whenever a thread is enqueued, the script increments the length of the queue and records the timestamp in an associative array keyed by the thread. You cannot use a thread-local variable in this case because a thread might be enqueued by another thread. The script then checks to see if the queue length exceeds the maximum. If it does, the script starts a new speculation, and records the timestamp and the new maximum. Then, when a thread is dequeued, the script compares the enqueue timestamp to the timestamp of the longest length: if the thread was enqueued <b>before</b> the timestamp of the longest length, the thread was in the queue when the longest length was recorded. In this case, the script speculatively traces the thread's information. Once the kernel dequeues the last thread that was enqueued at the timestamp of the longest length, the script commits the speculation data. This script is shown below:</p>
<pre>#pragma D option quiet
#pragma D option nspec=4
#pragma D option specsize=100k

int maxlen;
int spec[int];

sched:::enqueue
{
	this->len = ++qlen[this->cpu = args[2]->cpu_id];
	in[args[0]->pr_addr] = timestamp;
}

sched:::enqueue
/this->len > maxlen &amp;&amp; spec[this->cpu]/
{
	/*
	 * There is already a speculation for this CPU.  We just set a new
	 * record, so we'll discard the old one.
	 */
	discard(spec[this->cpu]);
}

sched:::enqueue
/this->len > maxlen/
{
	/*
	 * We have a winner.  Set the new maximum length and set the timestamp
	 * of the longest length.
	 */
	maxlen = this->len;
	longtime[this->cpu] = timestamp;	

	/*
	 * Now start a new speculation, and speculatively trace the length.
	 */
	this->spec = spec[this->cpu] = speculation();
	speculate(this->spec);
	printf("Run queue of length %d:\n", this->len);
}

sched:::dequeue
/(this->in = in[args[0]->pr_addr]) &amp;&amp;
    this->in &lt;= longtime[this->cpu = args[2]->cpu_id]/
{
	speculate(spec[this->cpu]);
	printf("  %d/%d (%s)\n", 
	    args[1]->pr_pid, args[0]->pr_lwpid,
	    stringof(args[1]->pr_fname));
}

sched:::dequeue
/qlen[args[2]->cpu_id]/
{
	in[args[0]->pr_addr] = 0;
	this->len = --qlen[args[2]->cpu_id];
}

sched:::dequeue
/this->len == 0 &amp;&amp; spec[this->cpu]/
{
	/*
	 * We just processed the last thread that was enqueued at the time
	 * of longest length; commit the speculation, which by now contains
	 * each thread that was enqueued when the queue was longest.
	 */
	commit(spec[this->cpu]);
	spec[this->cpu] = 0;
}</pre><p>Running the above script on the same uniprocessor laptop results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./whoqueue.d</b></tt>
Run queue of length 3:
 0/0 (sched)
  0/0 (sched)
  101170/1 (dtrace)
Run queue of length 4:
  0/0 (sched)
  100356/1 (Xsun)
  100420/1 (xterm)
  101170/1 (dtrace)
Run queue of length 5:
  0/0 (sched)
  0/0 (sched)
  100356/1 (Xsun)
  100420/1 (xterm)
  101170/1 (dtrace)
Run queue of length 7:
  0/0 (sched)
  100221/18 (nscd)
  100221/17 (nscd)
  100221/16 (nscd)
  100221/13 (nscd)
  100221/14 (nscd)
  100221/15 (nscd)
Run queue of length 16:
  100821/1 (xterm)
  100768/1 (xterm)
  100365/1 (fvwm2)
  101118/1 (xterm)
  100577/1 (xterm)
  101170/1 (dtrace)
  101020/1 (xterm)
  101089/1 (xterm)
  100795/1 (xterm)
  100741/1 (xterm)
  100710/1 (xterm)
  101048/1 (xterm)
  100697/1 (MozillaFirebird-)
  100420/1 (xterm)
  100394/1 (xterm)
  100368/1 (xterm)
<tt><b>^C</b></tt></pre><p>The output reveals that the long run queues are due to many runnable <tt>xterm</tt> processes. This experiment coincided with a change in virtual desktop, and therefore the results are probably due to some sort of X event processing.</p>
<a name="chp-sched-11"></a><h4><tt>sleep</tt> and <tt>wakeup</tt></h4>
<p>In <a href="p48.html#chp-sched-10"><tt>enqueue</tt> and <tt>dequeue</tt></a>, the final example demonstrated that a burst in run queue length was due to runnable <tt>xterm</tt> processes. One hypothesis is that the observations resulted from a change in virtual desktop. You can use the <tt>wakeup</tt> probe to explore this hypothesis by determining who is waking the <tt>xterm</tt> processes, and when, as shown in the following example:</p>
<pre>#pragma D option quiet

dtrace:::BEGIN
{
	start = timestamp;
}

sched:::wakeup
/stringof(args[1]->pr_fname) == "xterm"/
{
	@[execname] = lquantize((timestamp - start) / 1000000000, 0, 10);
}

profile:::tick-1sec
/++x == 10/
{
	exit(0);
}</pre><p>To investigate the hypothesis, run the above script, waiting roughly five seconds, and switch your virtual desktop exactly once. If the burst of runnable <tt>xterm</tt> processes is due to switching the virtual desktop, the output should show a burst of wakeup activity at the five second mark.</p>
<pre><tt><b># dtrace -s ./xterm.d</b></tt>

  Xsun

           value  -------------- Distribution ------------ count    
               4 |                                         0        
               5 |@                                        1        
               6 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   32       
               7 |                                         0</pre><p>The output does show that the X server is waking xterm processes, clustered around the time that you switched virtual desktops. If you wanted to understand the interaction between the X server and the <tt>xterm</tt> processes, you could aggregate on user stack traces when the X server fires the <tt>wakeup</tt> probe.</p>
<p>Understanding the performance of client/server systems like the X windowing system requires understanding the clients on whose behalf the server is doing work. This kind of question is difficult to answer with conventional performance analysis tools. However, if you have a model where a client sends a message to the server and sleeps pending the server's processing, you can use the <tt>wakeup</tt> probe to determine the client for whom the request is being performed, as shown in the following example:</p>
<pre>self int last;

sched:::wakeup
/self->last &amp;&amp; args[0]->pr_stype == SOBJ_CV/
{
	@[stringof(args[1]->pr_fname)] = sum(vtimestamp - self->last);
	self->last = 0;
}

sched:::wakeup
/execname == "Xsun" &amp;&amp; self->last == 0/
{
	self->last = vtimestamp;
}</pre><p>Running the above script results in output similar to the following example:</p>
<pre><tt><b>dtrace -s ./xwork.d</b></tt>
dtrace: script './xwork.d' matched 14 probes
<tt><b>^C</b></tt>
  xterm                                                       9522510
  soffice.bin                                                 9912594
  fvwm2                                                     100423123
  MozillaFirebird                                           312227077
  acroread                                                  345901577</pre><p>This output reveals that much <tt>Xsun</tt> work is being done on behalf of the processes <tt>acroread</tt>, <tt>MozillaFirebird</tt> and, to a lesser degree, <tt>fvwm2</tt>. Notice that the script only examined wakeups from condition variable synchronization objects (<tt>SOBJ_CV</tt>). As described in <a href="p46.html#tbl-sched-sobj">Table 25-4</a>, condition variables are the type of synchronization object typically used to synchronize for reasons other than access to a shared data region. In the case of the X server, a client will wait for data in a pipe by sleeping on a condition variable.</p>
<p>You can additionally use the <tt>sleep</tt> probe along with the <tt>wakeup</tt> probe to understand which applications are blocking on which applications, and for how long, as shown in the following example:</p>
<pre>#pragma D option quiet

sched:::sleep
/!(curlwpsinfo->pr_flag &amp; PR_ISSYS) &amp;&amp; curlwpsinfo->pr_stype == SOBJ_CV/
{
	bedtime[curlwpsinfo->pr_addr] = timestamp;
}

sched:::wakeup
/bedtime[args[0]->pr_addr]/
{
	@[stringof(args[1]->pr_fname), execname] =
	    quantize(timestamp - bedtime[args[0]->pr_addr]);
	bedtime[args[0]->pr_addr] = 0;
}

END
{
	printa("%s sleeping on %s:\n%@d\n", @);
}</pre><p>The tail of the output from running the example script for several seconds on a desktop system resembles the following example:</p>
<pre><tt><b># dtrace -s ./whofor.d</b></tt>
<tt><b>^C</b></tt>
...
 xterm sleeping on Xsun:

           value  -------------- Distribution ------------ count    
          131072 |                                         0        
          262144 |                                         12       
          524288 |                                         2        
         1048576 |                                         0        
         2097152 |                                         5        
         4194304 |@@@                                      45       
         8388608 |                                         1        
        16777216 |                                         9        
        33554432 |@@@@@                                    83       
        67108864 |@@@@@@@@@@@                              164      
       134217728 |@@@@@@@@@@                               147      
       268435456 |@@@@                                     56       
       536870912 |@                                        17       
      1073741824 |                                         9        
      2147483648 |                                         1        
      4294967296 |                                         3        
      8589934592 |                                         1        
     17179869184 |                                         0        

fvwm2 sleeping on Xsun:

           value  -------------- Distribution ------------ count    
           32768 |                                         0        
           65536 |@@@@@@@@@@@@@@@@@@@@@@                   67       
          131072 |@@@@@                                    16       
          262144 |@@                                       6        
          524288 |@                                        3        
         1048576 |@@@@@                                    15       
         2097152 |                                         0        
         4194304 |                                         0        
         8388608 |                                         1        
        16777216 |                                         0        
        33554432 |                                         0        
        67108864 |                                         1        
       134217728 |                                         0        
       268435456 |                                         0        
       536870912 |                                         1        
      1073741824 |                                         1        
      2147483648 |                                         2        
      4294967296 |                                         2        
      8589934592 |                                         2        
     17179869184 |                                         0        
     34359738368 |                                         2        
     68719476736 |                                         0        

syslogd sleeping on syslogd:

           value  -------------- Distribution ------------ count    
     17179869184 |                                         0        
     34359738368 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 3        
     68719476736 |                                         0        

MozillaFirebird sleeping on MozillaFirebird:

           value  -------------- Distribution ------------ count    
           65536 |                                         0        
          131072 |                                         3        
          262144 |@@                                       14       
          524288 |                                         0        
         1048576 |@@@                                      18       
         2097152 |                                         0        
         4194304 |                                         0        
         8388608 |                                         1        
        16777216 |                                         0        
        33554432 |                                         1        
        67108864 |                                         3        
       134217728 |@                                        7        
       268435456 |@@@@@@@@@@                               53       
       536870912 |@@@@@@@@@@@@@@                           78       
      1073741824 |@@@@                                     25       
      2147483648 |                                         0        
      4294967296 |                                         0        
      8589934592 |@                                        7        
     17179869184 |                                         0</pre><p>You might want to understand how and why <tt>MozillaFirebird</tt> is blocking on itself. You could modify the above script as shown in the following example to answer this question:</p>
<pre>#pragma D option quiet

sched:::sleep
/execname == "MozillaFirebird" &amp;&amp; curlwpsinfo->pr_stype == SOBJ_CV/
{
	bedtime[curlwpsinfo->pr_addr] = timestamp;
}

sched:::wakeup
/execname == "MozillaFirebird" &amp;&amp; bedtime[args[0]->pr_addr]/
{
	@[args[1]->pr_pid, args[0]->pr_lwpid, pid, curlwpsinfo->pr_lwpid] = 
	    quantize(timestamp - bedtime[args[0]->pr_addr]);
	bedtime[args[0]->pr_addr] = 0;
}

sched:::wakeup
/bedtime[args[0]->pr_addr]/
{
	bedtime[args[0]->pr_addr] = 0;
}

END
{
	printa("%d/%d sleeping on %d/%d:\n%@d\n", @);
}</pre><p>Running the modified script for several seconds results in output similar to the following example:</p>
<pre><tt><b># dtrace -s ./firebird.d</b></tt>
<tt><b>^C</b></tt>

 100459/1 sleeping on 100459/13:

           value  -------------- Distribution ------------ count    
          262144 |                                         0        
          524288 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 1        
         1048576 |                                         0        

100459/13 sleeping on 100459/1:

           value  -------------- Distribution ------------ count    
        16777216 |                                         0        
        33554432 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 1        
        67108864 |                                         0        

100459/1 sleeping on 100459/2:

           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |@@@@                                     5        
           65536 |@                                        2        
          131072 |@@@@@                                    6        
          262144 |                                         1        
          524288 |@                                        2        
         1048576 |                                         0        
         2097152 |@@                                       3        
         4194304 |@@@@                                     5        
         8388608 |@@@@@@@@                                 9        
        16777216 |@@@@@                                    6        
        33554432 |@@                                       3        
        67108864 |                                         0        

100459/1 sleeping on 100459/5:

           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |@@@@@                                    12       
           65536 |@@                                       5        
          131072 |@@@@@@                                   15       
          262144 |                                         1        
          524288 |                                         1        
         1048576 |                                         2        
         2097152 |@                                        4        
         4194304 |@@@@@                                    13       
         8388608 |@@@                                      8        
        16777216 |@@@@@                                    13       
        33554432 |@@                                       6        
        67108864 |@@                                       5        
       134217728 |@                                        4        
       268435456 |                                         0        
       536870912 |                                         1        
      1073741824 |                                         0        

100459/2 sleeping on 100459/1:

           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |@@@@@@@@@@@@@@                           11       
           65536 |                                         0        
          131072 |@@                                       2        
          262144 |                                         0        
          524288 |                                         0        
         1048576 |@@@@                                     3        
         2097152 |@                                        1        
         4194304 |@@                                       2        
         8388608 |@@                                       2        
        16777216 |@                                        1        
        33554432 |@@@@@@                                   5        
        67108864 |                                         0        
       134217728 |                                         0        
       268435456 |                                         0        
       536870912 |@                                        1        
      1073741824 |@                                        1        
      2147483648 |@                                        1        
      4294967296 |                                         0        

100459/5 sleeping on 100459/1:

           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |                                         1        
           65536 |                                         2        
          131072 |                                         4        
          262144 |                                         7        
          524288 |                                         1        
         1048576 |                                         5        
         2097152 |                                         10       
         4194304 |@@@@@@                                   77       
         8388608 |@@@@@@@@@@@@@@@@@@@@@@@                  270      
        16777216 |@@@                                      43       
        33554432 |@                                        20       
        67108864 |@                                        14       
       134217728 |                                         5        
       268435456 |                                         2        
       536870912 |                                         1        
      1073741824 |                                         0        </pre><p>You can also use the <tt>sleep</tt> and <tt>wakeup</tt> probes to understand the performance of door servers such as the name service cache daemon, as shown in the following example:</p>
<pre>sched:::sleep
/curlwpsinfo->pr_stype == SOBJ_SHUTTLE/
{
	bedtime[curlwpsinfo->pr_addr] = timestamp;
}

sched:::wakeup
/execname == "nscd" &amp;&amp; bedtime[args[0]->pr_addr]/
{
	@[stringof(curpsinfo->pr_fname), stringof(args[1]->pr_fname)] =
	    quantize(timestamp - bedtime[args[0]->pr_addr]);
	bedtime[args[0]->pr_addr] = 0;
}

sched:::wakeup
/bedtime[args[0]->pr_addr]/
{
	bedtime[args[0]->pr_addr] = 0;
}</pre><p>The tail of the output from running the above script on a large mail server resembles the following example:</p>
<pre>imapd
           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |                                         2        
           65536 |@@@@@@@@@@@@@@@@@                        57       
          131072 |@@@@@@@@@@@                              37       
          262144 |                                         3        
          524288 |@@@                                      11       
         1048576 |@@@                                      10       
         2097152 |@@                                       9        
         4194304 |                                         1        
         8388608 |                                         0        

  mountd                                            
           value  -------------- Distribution ------------ count    
           65536 |                                         0        
          131072 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@            49       
          262144 |@@@                                      6        
          524288 |                                         1        
         1048576 |                                         0        
         2097152 |                                         0        
         4194304 |@@@@                                     7        
         8388608 |@                                        3        
        16777216 |                                         0        

  sendmail
           value  -------------- Distribution ------------ count    
           16384 |                                         0        
           32768 |@                                        18       
           65536 |@@@@@@@@@@@@@@@@@                        205      
          131072 |@@@@@@@@@@@@@                            154      
          262144 |@                                        23       
          524288 |                                         5        
         1048576 |@@@@                                     50       
         2097152 |                                         7        
         4194304 |                                         5        
         8388608 |                                         2        
        16777216 |                                         0        

  automountd                                        
           value  -------------- Distribution ------------ count    
           32768 |                                         0        
           65536 |@@@@@@@@@@                               22       
          131072 |@@@@@@@@@@@@@@@@@@@@@@@                  51       
          262144 |@@                                       6        
          524288 |                                         1        
         1048576 |                                         0        
         2097152 |                                         2        
         4194304 |                                         2        
         8388608 |                                         1        
        16777216 |                                         1        
        33554432 |                                         1        
        67108864 |                                         0        
       134217728 |                                         0        
       268435456 |                                         1        
       536870912 |                                         0</pre><p>You might be interested in the unusual data points for <tt>automountd</tt> or the persistent data point at over one millisecond for <tt>sendmail</tt>. You can add additional predicates to the above script to hone in on the causes of any exceptional or anomalous results.</p>

</div>
<!--stopindex-->

<!-- END CENTRAL COLUMN COMPONENTS -->
</td></tr>

<!-- BEGIN SPACER ROW -->
<tr><td><img src="css/a.gif" width="780" height="1" border="0" alt="" /></td></tr>
<!-- END SPACER ROW -->

<tr><td>

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr valign="bottom">
<td></td>
<td style="width: 60%"></td>
<td><a href="p47.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p49.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->
</td></tr>

</table>
<!-- END WRAPPER TABLE, 1 COLUMN, MAIN -->


<!-- BEGIN A5 COMPONENT V.0 -->
<div class="a5" id="a5v0">
<span class="footerlinks">
<a href="http://www.sun.com/company/">Company Info</a>
<a href="http://www.sun.com/contact/">Contact</a>
<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>
<a href="http://www.sun.com/privacy/">Privacy</a>

<span class="footercopy">Copyright 1994-2007 Sun Microsystems, Inc.</span>
</span>
</div>
<!-- END A5 COMPONENT V.0 -->

</body>
</html>

