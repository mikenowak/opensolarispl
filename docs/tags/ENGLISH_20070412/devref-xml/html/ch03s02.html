<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3.2 Tour of Your ON Workspace</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="OpenSolaris Developer's Reference"><link rel="up" href="ch03.html" title="Chapter 3. The Source Tree"><link rel="prev" href="ch03.html" title="Chapter 3. The Source Tree"><link rel="next" href="ch03s03.html" title="3.3 Using Your Workspace"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.2 Tour of Your ON Workspace</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><th width="60%" align="center">Chapter 3. The Source Tree</th><td width="20%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_3_2_Tour_of_Your_ON_Workspace"></a>3.2 Tour of Your ON Workspace</h2></div></div></div><p>
After creating and populating your <a href="apa.html#_workspace">workspace</a>, you can begin to
investigate the contents of the source tree.  This section describes the
layout and contents of your <a href="apa.html#_ON">ON</a> workspace.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_1_Organization"></a>3.2.1 Organization</h3></div></div></div><p>
Initially, your <a href="apa.html#_workspace">workspace</a> will have only one directory: usr.  Once
you have completed a build, you may have several additional directories,
including archives, log, packages, and proto.  We include here a diagram
showing all these directories and their subdirectories.  We also include
the build subdirectories, which contain object files and are described
in greater detail in subsections 2-4 below.
</p><p>
If you have done a nightly(1) build, you will also have a log directory
at the top level.  It will contain the complete output from the
nightly(1) build process.  See <a href="ch04s02.html">4.2 Using nightly and bldenv</a> for more
information on nightly(1) and the log files it generates.
</p><p>
All sources are found under usr/src.  This includes both the sources
used to build the <a href="apa.html#_ON">ON</a> consolidation and sources for tools and other
peripheral utilities needed to build but not shipped as part of Solaris.
Because it includes only ON sources, it does not contain Java, the
windowing system, or packaging and installation tools.  Because of
contractual obligations, it may not include all code from third-party
hardware vendors.  The usr/src directory has several subdirectories
which are described here.
</p><div class="itemizedlist"><ul type="disc"><li><p>cmd</p><p>
This directory contains sources for the executable programs and scripts
that are part of ON.  It includes all the basic commands, daemons,
startup scripts, and related data.  Most subdirectories are named for
the command or commands they provide; however, there are some exceptions
listed here.
</p></li><li><p>cmd/Adm</p><p>
Miscellaneous key system files, such as crontabs and data installed in /etc.
</p></li><li><p>cmd/cmd-crypto</p><p>
Basic cryptographic utilities, such as elfsign and kcfd.
</p></li><li><p>cmd/cmd-inet</p><p>
Network commands and daemons, including the Berkeley r-commands, PPP,
telnet, the inetd super-server, and other network-related utilities.
</p></li><li><p>cmd/fs.d</p><p>
Utilities for checking, mounting, unmounting, and analyzing filesystems.
</p></li><li><p>cmd/netfiles</p><p>
IP port definitions and name service switch configuration files
installed into /etc.
</p></li><li><p>cmd/ptools</p><p>
Utilities for manipulating and observing processes; these are based
on proc(4) and libproc interfaces.
</p></li><li><p>cmd/sgs</p><p>
Software Generation System.  This directory contains binary utilities,
such as ld(1), ar(1), and mcs(1), and development tools such as lex(1),
yacc(1), and m4(1).  Note that this directory also includes several
libraries and headers used by these tools.
</p></li><li><p>common</p><p>
Files which are common among cmd, lib, stand, and uts.  These
typically include headers and sources to basic libraries used by both
the kernel and user programs.
</p></li><li><p>head</p><p>
Userland header files (kernel headers are in uts/).  Note that only libc
headers should be stored here; other libraries should have their headers
in their own subdirectories under lib/.
</p></li><li><p>lib</p><p>
Libraries.  Most subdirectories are named for the library whose
sources they contain or are otherwise self-explanatory.
</p></li><li><p>pkgdefs</p><p>
Contains one subdirectory for each package generated from the ON
sources.  Each subdirectory contains packaging information files; see
pkginfo(4), depend(4), prototype(4), pkgmap(1), and pkgproto(1) for more
information about the contents of these files.
</p></li><li><p>prototypes</p><p>
Sample files showing format and copyright notices.
</p></li><li><p>psm</p><p>
Platform-specific modules.  Currently this contains only OBP and most of
the boot code.
</p></li><li><p>stand</p><p>
Standalone environment code.  This is used for booting; for example,
code for reading from UFS and the network is here.
</p></li><li><p>tools</p><p>
Development tools and sources.  See README.tools for more information
about each tool; the file should be updated as tools are added or
removed.
</p></li><li><p>ucbcmd</p><p>
Commands and daemons installed into /usr/ucb (for SunOS 4.x
compatibility).
</p></li><li><p>ucbhead</p><p>
Header files installed into /usr/ucb (for SunOS 4.x compatibility).
</p></li><li><p>ucblib</p><p>
Libraries installed into /usr/ucb (for SunOS 4.x compatibility).
</p></li><li><p>uts</p><p>
Kernel sources are here (UTS == UNIX Time Sharing).  There are numerous
subdirectories of uts which are of interest:
</p></li><li><p>uts/adb</p><p>
adb contained the obsolete kernel debugger macros; it is no longer
supported, and this directory is now empty.  Use mdb(1) instead, and
write mdb dcmds instead of adb macros.
</p></li><li><p>uts/common</p><p>
All platform-independent kernel sources.  Nearly all of the Solaris
kernel is here; only a few small parts are architecture-dependent.
</p></li><li><p>uts/common/c2</p><p>
Auditing code to support the C2 U.S. government security standard.
</p></li><li><p>uts/common/conf</p><p>
System configuration parameters.
</p></li><li><p>uts/common/contract</p><p>
Code to support process contracts.  See contract(4) and
libcontract(3LIB) for more information on process contracts.
</p></li><li><p>uts/common/cpr</p><p>
CheckPoint-and-Resume support.  This implements suspend and resume
functionality.
</p></li><li><p>uts/common/crypto</p><p>
Kernel cryptographic framework.  See kcfd(1M) and cryptoadm(1M) for
more information.
</p></li><li><p>uts/common/ctf</p><p>
Code for handling Compact C Type Format data.
</p></li><li><p>uts/common/des</p><p>
Implements the old Data Encryption Standard.  This is used by KCF.
</p></li><li><p>uts/common/disp</p><p>
Dispatcher, thread handling, and scheduling classes.
</p></li><li><p>uts/common/dtrace</p><p>
CPU-independent dtrace(7D) kernel support.
</p></li><li><p>uts/common/exec</p><p>
Code for handling userland binary executable types (a.out, ELF, etc).
</p></li><li><p>uts/common/fs</p><p>
Filesystems.
</p></li><li><p>uts/common/ssapi</p><p>
Generic Security Services API.
</p></li><li><p>uts/common/inet</p><p>
IP networking subsystem, including IPv6.
</p></li><li><p>uts/common/io</p><p>
I/O subsystem.  Most of the code in this directory is device drivers
(and pseudo-device drivers).
</p></li><li><p>uts/common/ipp</p><p>
IP policy framework; includes QoS and other traffic management.
</p></li><li><p>uts/common/kmdb</p><p>
Kernel modular debugger.  See kmdb(1).
</p></li><li><p>uts/common/krtld</p><p>
Kernel runtime linker/loader.  This is responsible for handling
loadable modules and symbol resolution; it is analogous to ld.so.1,
and shares code with it.
</p></li><li><p>uts/common/ktli</p><p>
Kernel TLI (Transport Layer Interface).
</p></li><li><p>uts/common/net</p><p>
Header files; most are shipped in /usr/include/net.
</p></li><li><p>uts/common/netinet</p><p>
Header files; most are shipped in /usr/include/netinet.
</p></li><li><p>uts/common/nfs</p><p>
Network File System headers shipped in /usr/include/nfs.
</p></li><li><p>uts/common/os</p><p>
Core operating system implementation.  This includes such varied
aspects as privileges, zones, timers, the DDI/DKI interfaces, and
high-level locking mechanisms.
</p></li><li><p>uts/common/pcmcia</p><p>
PCMCIA I/O subsystem and drivers.
</p></li><li><p>uts/common/rpc</p><p>
Remote Procedure Call subsystem used by services such as NFS and NIS.
</p></li><li><p>uts/common/rpcsvc</p><p>
Generated RPC header files shipped in /usr/include/rpcsvc.
</p></li><li><p>uts/common/sys</p><p>
Header files shipped in /usr/include/sys.  These same headers are used
to build the kernel as well (if the _KERNEL preprocessor symbol is
defined).
</p></li><li><p>uts/common/syscall</p><p>
System call implementations.  Most syscalls are implemented in files
matching their names.  Note that some system calls are implemented
in os/ or other subdirectories instead.
</p></li><li><p>uts/common/tnf</p><p>
Old tracing subsystem, not related to dtrace(7D).
</p></li><li><p>uts/common/vm</p><p>
Virtual memory subsystem.
</p></li><li><p>uts/common/zmod</p><p>
Compression/decompression library.
</p></li><li><p>uts/i86pc</p><p>
Architecture-dependent files for x86 machines.  The
architecture-dependent directories (i86pc, sun, sun4, sun4u) all have
a set of subdirectories similar to common/ above.
</p></li><li><p>uts/intel</p><p>
ISA-dependent, architecture-independent files for x86 machines.  Note
that all architecture-independent source files are built into objects
in this hierarchy.
</p></li><li><p>uts/sfmmu</p><p>
Code specific to the SpitFire memory management unit (UltraSPARC).
</p></li><li><p>uts/sparc</p><p>
ISA-dependent, architecture-independent files for SPARC machines.
Note that all architecture-independent source files are built into
objects in this hierarchy.
</p></li><li><p>uts/sun</p><p>
Sources common to all Sun implementations.  Currently this contains a
small number of device drivers and some headers shipped in
/usr/include/sys.
</p></li><li><p>uts/sun4</p><p>
Sources common to all sun4* machine architectures.
</p></li><li><p>uts/sun4u</p><p>
Architecture-dependent sources for the sun4u architecture.  Each
system implementation has a subdirectory here:
</p><pre class="programlisting">
* blade		Serverblade1
* chalupa		Sun-Fire-V440
* cherrystone		Sun-Fire-480R
* daktari		Sun-Fire-880
* darwin		Ultra-5_10
* enchilada		Sun-Blade-2500
* ents		Sun-Fire-V250
* excalibur		Sun-Blade-1000
* fjlite		UltraAX-i2
* grover		Sun-Blade-100
* javelin		Ultra-250
* littleneck		Sun-Fire-280R
* lw2plus		Netra-T4
* lw8			Netra-T12
* makaha		UltraSPARC IIe-NetraCT-40, UltraSPARC IIe-NetraCT-60
* montecarlo		UltraSPARC IIi-NetraCT
* mpxu		Sun-Fire-V240
* quasar		Ultra-80
* serengeti		Sun-Fire
* snowbird		Netra-CP2300
* starcat		Sun-Fire-15000
* starfire		Ultra-Enterprise-10000
* sunfire		Ultra-Enterprise
* taco		Sun-Blade-1500
* tazmo		Ultra-4
</pre></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_2_Object_Directories"></a>3.2.2 Object Directories</h3></div></div></div><p>
There are two basic strategies that can be used in the creation of
object files and finished binaries (executables and libraries):
</p><p>
(a) place objects in a dedicated directory hierarchy parallel to the
sources
</p><p>
(b) place objects in the same directories as the sources they are
built from
</p><p>
ON actually uses each of these approaches in different parts of the
tree.  Strategy (a) must be used for all kernel code and many libraries,
is preferred for new code, and will be described in detail here.  There
are several legacy variations on strategy (a) as well as instances in
which strategy (b) is still used; the majority of these are in the cmd
hierarchy.  The entire uts hierarchy has been converted to strategy (a)
as described below, and you will see this same approach used throughout
much of the rest of the tree.
</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_2_1_General_Strategy_for_K"></a>3.2.2.1 General Strategy for Kernel Objects</h4></div></div></div><p>
First, each platform-independent module has zero or one build directory
per architecture.  An architecture in this case can be a machine (sun4u,
i86pc) or a processor architecture (intel, sparc).  The path to this
location is always usr/src/uts/&lt;platform&gt;/&lt;module&gt;.  The module name in
this case is what's found in /kernel/drv or a similar location, and in
the case of device drivers or STREAMS modules should always match the
name of the man page describing that driver or module.
</p><p>
The only files normally present in this directory for a clean tree are
makefiles.  After a build, these directories contain one or more of
obj32, obj64, debug32, and debug64 directories.  These directories
contain the object files and finally linked modules that are later
installed into the kernel directory and other locations in the
prototype.
</p><p>
"Implementation architecture"-independent modules are produced in
individual directories (one per module) under the "instruction-set
architecture" directory (i.e.: sparc). Similarly, "implementation
architecture"-dependent modules are produced in individual directories
under the "implementation architecture" directory (i.e.: sun4, sun4u,
i86pc).
</p><p>
Platform-dependent modules (including "unix") may be built more than
once in different locations.  Platform-dependent modules are discussed
in greater detail in &lt;section&gt;.
</p><p>
The sources are not contained in these build directories.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_2_2_General_Strategy_for_C"></a>3.2.2.2 General Strategy for Command/Library Objects</h4></div></div></div><p>
Most libraries and some commands and daemons are built using makefiles
very similar to those used to build the kernel.  Accordingly,
intermediate objects, shared objects, libraries, and executables are
built by small makefile fragments and placed in dedicated ISA-specific
subdirectories.
</p><p>
Other commands' build systems place objects in the same directories as
the sources.  See sections 3.2.2.3, 3.2.3.2, and 3.2.5 for more information
on how commands are built.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_2_3_Exceptions_in_cmd_and_"></a>3.2.2.3 Exceptions in cmd and lib</h4></div></div></div><p>
Most of the cmd tree is directly based on the original System V
Release 4 source, which uses strategy (b) described above.  Since
most commands and daemons do not need to provide both 32- and 64-bit
versions, or do anything special when building for different
architectures, this strategy is adequate and appropriate for most
commands and has been applied even to new subdirectories.  In
situations in which architecture-dependent build options are needed or
multiple ISA versions of a program must be delivered, this strategy is
unworkable and the more general approach of multiple per-ISA object
directories must be used instead.  This latter approach is similar to
the approach used for kernel modules.
</p><p>
The lib hierarchy is somewhat simpler; nearly all subdirectories must
use per-ISA object file locations and makefiles.
</p><p>
A few directories do not appear to follow any rule or pattern, such as
cmd/cmd-inet and cmd/agents.  These are primarily historical artifacts
of Sun's internal project organization.
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_3_Makefile_Layout"></a>3.2.3 Makefile Layout</h3></div></div></div><p>
This discussion is intended to provide a step-by-step explanation of
what targets exist and how they are built by the makefiles.  I ignore
the platform-specific module architecture because it is unlikely to be
of significant interest except to hardware support engineers.  The three
main subtrees of interest are the kernel (uts), commands and daemons
(cmd), and libraries (lib).  The next three subsections cover these
three subtrees in turn.  There are also a handful of makefiles which
apply to all builds:
</p><div class="itemizedlist"><ul type="disc"><li><p>usr/src/Makefile</p><p>
This is the top-level makefile.  It drives builds for various targets in
each subdirectory.  It is aware of the specific targets that need to be
built in each subdirectory in order to perform a complete build, and
itself knows how to create a skeleton proto area for later use by
install and install_h targets.
</p></li><li><p>usr/src/Makefile.lint</p><p>
All linting from the top level is driven by this makefile.  It contains
long lists of directories known to be <a href="apa.html#_lint">lint</a>-clean and contains simple
recursive rules for rebuilding each subdirectory's lint target.  The
actual linting is driven by the lower-level makefiles.
</p></li><li><p>usr/src/Makefile.master</p></li><li><p>usr/src/Makefile.master.64</p><p>
These two makefiles contain generic definitions, such as build and
installation tools locations, template macros for compilers, linkers,
and other tools to be used by other makefiles in defining rules, and
global definitions such as the ISA and machine names that apply to this
build.  Makefile.master.64 contains definitions specific to 64-bit
builds that override the generic definitions.
</p></li><li><p>usr/src/Makefile.msg.targ</p><p>
Common targets for building message catalogues are defined here. Message
catalogues provide translations of messages for g11n purposes.
</p></li><li><p>usr/src/Makefile.psm</p><p>
This makefile defines the installation locations for platform-specific
modules.  These are analogous to the other kernel module install
locations /kernel and /usr/kernel (see section 3.2.6 below for more
information on kernel module installation).
</p></li><li><p>usr/src/Makefile.psm.targ</p><p>
Installation target definitions for platform-specific modules are
defined here.  This instructs the build system how to install files into
the directories defined by Makefile.psm.
</p></li><li><p>usr/src/Targetdirs</p><p>
This is a set of definitions for the owner, group, and permissions of
each directory that will be created by the installation process. It also
contains information about special symbolic links to be installed for
some 64-bit library versions.
</p></li></ul></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_3_1_Kernel_Makefile_Layout"></a>3.2.3.1 Kernel Makefile Layout</h4></div></div></div><p>
The driving makefile for any module is located in the leaf directory
(build directory) where the module and its component objects are built.
After a 'make clobber' operation, the makefile should be the only file
remaining in that directory.  There are two other types of makefiles in
the tree: suffixed and non-suffixed.  Common definitions and rules
needed by all leaf makefiles are contained in the suffixed makefiles;
these are included by leaf makefiles.  Non-suffixed makefiles generally
invoke multiple lower-level makefiles with the same target so that many
modules can be built with a single make invocation.
</p><div class="itemizedlist"><ul type="disc"><li><p>uts/Makefile</p></li><li><p>uts/sparc/Makefile</p></li><li><p>uts/sun4u/Makefile</p></li><li><p>uts/intel/Makefile</p></li><li><p>uts/intel/ia32/Makefile</p></li><li><p>uts/i86pc/Makefile</p><p>
These makefiles generally are cognizant of the components
made in subdirectories and invoke makefiles in those sub-
directories to perform the actual build. Some targets (or
pseudo-targets) may be directly built at this level (such
as the cscope databases).
</p></li><li><p>uts/Makefile.uts</p><p>
Contains common definitions for all possible architectures.
</p></li><li><p>uts/Makefile.targ</p><p>
Contains common targets for all possible architectures.
</p></li><li><p>uts/common/Makefile.files</p></li><li><p>uts/sun/Makefile.files</p></li><li><p>uts/sparc/Makefile.files</p></li><li><p>uts/sun4/Makefile.files</p></li><li><p>uts/sun4u/Makefile.files</p></li><li><p>uts/intel/Makefile.files</p></li><li><p>uts/intel/ia32/Makefile.files</p></li><li><p>uts/i86pc/Makefile.files</p><p>
These makefiles are divided into two sections. The first
section defines the object lists which comprise each module.
The second section defines the appropriate header search paths
and other machine-specific global build parameters.
</p></li><li><p>uts/common/Makefile.rules</p></li><li><p>uts/sun/Makefile.rules</p></li><li><p>uts/sparc/Makefile.rules</p></li><li><p>uts/sun4/Makefile.rules</p></li><li><p>uts/sun4u/Makefile.rules</p></li><li><p>uts/intel/Makefile.rules</p></li><li><p>uts/intel/ia32/Makefile.rules</p></li><li><p>uts/intel/amd64/Makefile.rules</p></li><li><p>uts/i86pc/Makefile.rules</p><p>
The files provide build rules (targets) which allow make to
function in a multiple directory environment. Each source tree
below the directory containing the makefile has a build rule
in the file.
</p></li><li><p>uts/sun4/Makefile.sun4</p></li><li><p>uts/sun4u/Makefile.sun4u</p></li><li><p>uts/intel/Makefile.intel</p></li><li><p>uts/intel/ia32/Makefile.ia32</p></li><li><p>uts/i86pc/Makefile.i86pc</p><p>
These makefiles contain the definitions specific (defaults) to
the obvious "implementation architecture". These rules can be
overridden in specific leaf node makefiles if necessary.
</p></li><li><p>Makefile.*.shared</p><p>
These makefiles provide settings that are shared between the
open-source makefiles and the closed-source makefiles that are
internal to Sun.  See <a href="ch03s02.html#_3_2_8_Source_Files_not_Include">3.2.8 Source Files not Included</a> for more
details.
</p></li><li><p>uts/sun4u/unix/Makefile</p></li><li><p>uts/i86pc/unix/Makefile</p><p>
Main driving makefile for building unix.
</p></li><li><p>uts/sun4u/MODULE/Makefile (for MODULE in cgsix, cpu, kb, ...)</p><p>
Main driving makefile for building MODULE.
</p></li><li><p>uts/sun4u/genunix/Makefile</p></li><li><p>uts/i86pc/genunix/Makefile</p><p>
Main driving makefile for building genunix.
</p></li></ul></div><p>
Issuing the command 'make' in the uts directory will cause all
supported, modularized kernels and modules to be built.
</p><p>
Issuing the command 'make' in a uts/ARCHITECTURE directory (i.e.:
uts/sparc) will cause all supported, "implementation
architecture"-independent modules for ARCHITECTURE to be built.
</p><p>
Issuing the command 'make' in a uts/MACHINE directory (i.e.:
uts/sun4u) will cause that kernel and all supported, "implementation
architecture"- dependent modules for MACHINE to be built.
</p><p>
The makefiles are verbosely commented. It is desired that they should
stay this way.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_3_2_Command_Makefile_Layou"></a>3.2.3.2 Command Makefile Layout</h4></div></div></div><p>
Most command and daemon subdirectories follow one of two general layout
rules, depending on where object files will be located (see sections
3.2.2.2 and 3.2.2.3).  For ISA-dependent programs, the layout is similar
to that used by the kernel.  Programs which do not need ISA-dependent
build behavior use a simplified makefile layout.  In the description
here, we use the example of a generic command called "foocmd" whose
sources are located in usr/src/cmd/foocmd.  The makefiles relevant to
building foocmd are:
</p><div class="itemizedlist"><ul type="disc"><li><p>usr/src/cmd/Makefile</p><p>
Top-level driving makefile for all commands/daemons.  This is
a simple recursive makefile which is aware of which
subdirectories should be built and will cause the given target
to be rebuilt in each of them.
</p></li><li><p>usr/src/cmd/Makefile.cmd</p><p>
This makefile defines the installation directories and rules
for installing executables into them.
</p></li><li><p>usr/src/cmd/Makefile.cmd.64</p><p>
Additional definitions specific to 64-bit builds are provided
here.
</p></li><li><p>usr/src/cmd/Makefile.cmd.bsm</p><p>
This specialty makefile is used only by auditstat and dminfo.
It provides some generic boilerplate rules.
</p></li><li><p>usr/src/cmd/Makefile.targ</p><p>
Basic target definitions for clobber, lint, and installation.
</p></li><li><p>usr/src/cmd/foocmd/Makefile</p><p>
Driving makefile for foocmd.  Normally defines PROG but otherwise
contains only boilerplate definitions and targets.  This is almost
always copied from another similar makefile.  If foocmd does not require
ISA-dependent build behavior, rules will normally be specified directly,
including those for the install target.  If foocmd does require
ISA-dependent build behavior, this makefile will instead define SUBDIRS
to include the ISA-specific versions that must be built, and define
targets recursively.  This will usually leave the install target
definition for each ISA makefile and cause a link to $(ISAEXEC) to be
created.  See section 3.2.5 for more information on platform
dependencies and $(ISAEXEC).
</p></li><li><p>usr/src/cmd/foocmd/Makefile.com</p><p>
Defines PROG, OBJS, SRCS, and includes Makefile.cmd.  May also
contain additional flags for compilation or linking.  This makefile
normally defines targets for all, $(PROG), clean, and lint; this
portion is usually generic and would be copied from another similar
makefile.
</p></li><li><p>usr/src/cmd/foocmd/*/Makefile</p><p>
ISA-specific makefiles, which may define additional
ISA-specific flags or targets, and will generally include its
own install target to install the ISA-specific program(s) it
builds.
</p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_3_3_Library_Makefile_Layou"></a>3.2.3.3 Library Makefile Layout</h4></div></div></div><p>
Most library subdirectories follow the same general layout, which is
similar to the command layout.  Unlike commands, most libraries are
built for both 32- and 64-bit architecture variants, so ISA-specific
directories will almost always be present.  Therefore, the overall build
structure for each library is similar to that of the kernel.  See
<a href="ch03s03.html#_3_3_3_3_Adding_New_Libraries">3.3.3.3 Adding New Libraries</a> for more detailed information on library
makefiles.
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_4_Makefile_Operation"></a>3.2.4 Makefile Operation</h3></div></div></div><p>
This section describes in detail how make dependencies and rules are
built up, and how each individual makefile contributes to the build
process.  Once you understand how the makefiles work, modifying
existing build rules and creating new ones are mainly an exercise in
copying existing files and making minor modifications to them.  We
begin with the kernel makefiles, then address the very similar command
and library makefiles.
</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_4_1_Kernel_Makefile_Operat"></a>3.2.4.1 Kernel Makefile Operation</h4></div></div></div><p>
There are two parts to the make dependencies: a set of targets and a
set of rules.
</p><p>
The rules are contained in the Makefile.rules files in each directory
under uts.  They cover how to compile a source file in some other
directory (common/io for example) into an object file in the build
directory described above.  They also describe which sources are
needed to build a given object file.  The order in which they are
specified determines which source file is needed if there are multiple
source files matching the same basename.  The key to all this is
understanding that all rules and targets are static and
module-independent, but variables set in each module's build directory
(leaf) makefile define the module-specific build information.
</p><p>
The targets are of two kinds: the first are "make targets," generic
directives you can give make like "all" or "install" which are
executed in each build directory.  The build directory makefiles in
turn include other makefiles that contain rules for building objects
and modules.  The second type of target is more interesting - they are
the actual module names (directories, in fact) that must be built.
These variables are called KMODS and XMODS.
</p><p>
If KMODS contains, for example, "aac ata asy", then for each of the
aac, ata, and asy build directories, the make system will cd to that
directory and rerun make with whatever target (all, install, etc) is
given.  The rules for that module are derived from all the included
makefiles; the crucial variables to look for are of the form XXX_OBJS,
where XXX is the module name.  More than one makefile may contain
definitions adding to each of these object lists, because building a
module may require different objects on each platform.
</p><p>
XMODS is used only for building export versions of the commercial
Solaris product; it is not used in building ON.
</p><p>
So for example we see:
</p><pre class="programlisting">
common/Makefile.files:ASY_OBJS +=      asy.o
</pre><p>
This indicates that the asy.o object is needed to build the ASY
module.  The makefile in the &lt;platform&gt;/asy directory will reference
ASY_OBJS and thus know what to build.  So in intel/asy/Makefile we
see:
</p><pre class="programlisting">
MODULE          = asy
OBJECTS         = $(ASY_OBJS:%=$(OBJS_DIR)/%)
</pre><p>
So, what good is this?  Plenty.  Because our ALL_TARGET is also
defined:
</p><pre class="programlisting">
ALL_TARGET      = $(BINARY) $(SRC_CONFILE)
</pre><p>
Makefile.uts defines BINARY as follows:
</p><pre class="programlisting">
BINARY             = $(OBJS_DIR)/$(MODULE)
</pre><p>
And OBJS_DIR is the individual module build directory I described at
the beginning.  So, make knows we need to build
usr/src/uts/intel/asy/obj32/asy.  Makefile.targ defines the rules for
doing so, too:
</p><pre class="programlisting">
$(BINARY):              $(OBJECTS)
	$(LD) -r $(LDFLAGS) -o $@ $(OBJECTS)
	$(CTFMERGE_UNIQUIFY_AGAINST_GENUNIX)
	$(POST_PROCESS)
	$(ELFSIGN_MOD)
</pre><p>
We're almost there - OBJECTS have to come from somewhere.  We find
this defined in intel/asy/Makefile:
</p><pre class="programlisting">
OBJECTS         = $(ASY_OBJS:%=$(OBJS_DIR)/%)
</pre><p>
And that's that.  We have a module (asy) that has a BINARY (obj32/asy)
which depends on OBJECTS made from ASY_OBJS.  The rules for each entry
in ASY_OBJS is in one of the Makefile.rules files; they look something
like this:
</p><pre class="programlisting">
$(OBJS_DIR)/%.o:                $(UTSBASE)/common/io/%.c
	$(COMPILE.c) -o $@ $&lt;
	$(CTFCONVERT_O)
</pre><p>
Each object is built in accordance with these rules.  The rule for
$(BINARY) then links them into the module.
</p><p>
We can now put it all together.  The extensive use of macros and local
per-module definitions provides much greater flexibility, but in the
example given, the equivalent makefile fragment would look very
familiar:
</p><pre class="programlisting">
KMODS +=	asy
</pre><pre class="programlisting">
all:	$(KMODS)
</pre><pre class="programlisting">
asy:	obj32/asy.o
	$(LD) -r $(LDFLAGS) -o $@ obj32/asy.o
	...
</pre><pre class="programlisting">
obj32/asy.o:	../../common/io/asy.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $@
	...
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_4_2_Command_Makefile_Opera"></a>3.2.4.2 Command Makefile Operation</h4></div></div></div><p>
Command makefiles vary widely, as described above.  Therefore it is
impossible to provide a "representative example" of a command makefile.
However, understanding the material in sections 3.2.4.1 and 3.3.3.3 will
provide you with the necessary knowledge to work with command makefiles.
As always, if you are looking for information about a specific command,
it is usually best to use the mailing lists and other community
resources.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_4_3_Library_Makefile_Opera"></a>3.2.4.3 Library Makefile Operation</h4></div></div></div><p>
Section 3.3.3.3 describes library makefile operation in detail.
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_5_ISA_Dependencies"></a>3.2.5 ISA Dependencies</h3></div></div></div><p>
Most code in OpenSolaris is generic and platform- and ISA-independent;
that is, it is portable code that can be compiled and run on any
system for which a suitable compiler is available.  However, even
portable code must sometimes deal with specific attributes of the
system on which it runs, or must be provided compiled for multiple
supported architectures so that users can run or link with the
architecture-specific version of their choosing.
</p><p>
There are two distinct situations in which multiple
architecture-specific builds must be shipped: commands that, by their
nature, must have visibility into the system's hardware characteristics,
and libraries, which must be built separately for each architecture a
developer may wish to target.  Each case is discussed in its own
subsection below.
</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_5_1_ISA_Dependent_Commands"></a>3.2.5.1 ISA-Dependent Commands</h4></div></div></div><p>
Commands (normally executable programs or daemons) usually do not depend
on the ISA on which they are executed; that is, they will be built and
installed in the same way regardless of the ISA they are built for.
Some commands, however, mainly those which operate on other processes or
manipulate binary objects, must behave differently depending on the
ISA(s) supported by the system and/or their targets.  The
/usr/lib/isaexec wrapper program provides this behavior in the following
way:
</p><p>
First, one or more ISA-specific programs are installed into
ISA-specific directories in the system.  These are subdirectories of
those directories which ordinarily contain executable programs, such
as /usr/bin.  On SPARC systems, ISA subdirectories might include
/usr/bin/sparcv7 and /usr/bin/sparcv9 to contain 32- and 64-bit
binaries, respectively.  Other ISAs may be supported by other systems;
you can find out which your system supports by using isalist(1).
</p><p>
Next, a hard link is installed into the ordinary binary directory
(in the example above, /usr/bin) targeting /usr/lib/isaexec.  This
will cause isaexec to be invoked with the name of the ISA-dependent
program the user has executed.
</p><p>
When this happens, isaexec will select the most appropriate
ISA-specific program installed in the first step and exec(2) it.  This
is transparent, so a user will not notice that a separate program has
been invoked.
</p><p>
A similar mechanism (/usr/lib/platexec) exists for platform-specific
programs; these are much less common even than ISA-specific programs.
</p><p>
Because it needs to interact both with user processes and kernel data
structures, dtrace(1) is an example of a command that must provide
multiple ISA-specific versions.
</p><p>
cmd/dtrace contains two makefiles: Makefile and Makefile.com.  It also
contains a single source file, dtrace.c, and four ISA directories:
amd64, i386, sparc, and sparcv9.  Each contains a single makefile.
The top-level makefiles should look very familiar after our tour of
the uts makefiles; Makefile is mainly boilerplate, customized only to
specify that the program produced is ISA- specific and therefore a
link to the isaexec program needs to be installed into /usr/sbin in
the proto area:
</p><pre class="programlisting">
install:        $(SUBDIRS)
	-$(RM) $(ROOTUSRSBINPROG)
	-$(LN) $(ISAEXEC) $(ROOTUSRSBINPROG)
</pre><p>
Otherwise, it simply leaves all building and installation to the
makefiles in the ISA subdirectories.  Makefile.com is also
boilerplate; it specifies the name of the program to build and the
objects from which it must be built:
</p><pre class="programlisting">
PROG = dtrace
OBJS = dtrace.o
</pre><p>
It then transforms the objects into sources:
</p><pre class="programlisting">
SRCS = $(OBJS:%.o=../%.c)
</pre><p>
and includes the generic top-level Makefile.cmd fragment to pick up
build rules.
</p><p>
Compilation and linkage flags are specified:
</p><pre class="programlisting">
CFLAGS += $(CCVERBOSE)
CFLAGS64 += $(CCVERBOSE)
LDLIBS += -ldtrace -lproc
</pre><p>
and the remainder consists of a handful of generic build rules.  One
feature is noteworthy: an extra ../ is prepended to all paths in this
fragment.  This is because it is always included by makefiles
interpreted from the ISA-specific build directory, which is one level
deeper than Makefile.com itself.
</p><p>
The makefiles in the ISA-specific build directories are even simpler;
they each consist of only two lines:
</p><pre class="programlisting">
include ../Makefile.com
</pre><pre class="programlisting">
install: all $(ROOTUSRSBINPROG32)
</pre><p>
The first line picks up all common definitions in the makefile we just
examined, and the second specifies (indirectly) the location in which
the program is to be installed.  To complete the picture, we need to
briefly examine usr/src/cmd/Makefile.cmd, which defines the various
locations in which programs can be installed.  Since we have not
defined ROOTUSRSBINPROG32, it must be defined there, and indeed it is:
</p><pre class="programlisting">
ROOTUSRSBIN=    $(ROOT)/usr/sbin
ROOTUSRSBINPROG=$(PROG:%=$(ROOTUSRSBIN)/%)
ROOTUSRSBIN32=  $(ROOTUSRSBIN)/$(MACH32)
ROOTUSRSBINPROG32=      $(PROG:%=$(ROOTUSRSBIN32)/%)
</pre><p>
Note that the program is actually installed in /usr/sbin/$(MACH32),
which is not normally in a user's search path.  But remember that we
also created a link from $(ROOTUSRSBINPROG) to $(ISAEXEC); expanding
these variables shows that we will actually install two separate
files:
</p><pre class="programlisting">
$(ROOT)/usr/sbin/dtrace		-&gt; $(ROOT)/usr/lib/isaexec
$(ROOT)/usr/sbin/$(MACH32)/dtrace	(our executable program)
</pre><p>
Since the isaexec program is responsible for selecting an ISA-specific
program from among several options depending on the system's supported
instruction sets, we can see that a typical system will have one or
more dtrace(1) binaries installed and that when dtrace(1) is run by
the user, isaexec will select the appropriate one from those installed
in the ISA-specific subdirectories of /usr/sbin.  As we might expect,
other ISA-specific makefiles under cmd/dtrace install their binaries
into ROOTUSRSBIN64, also defined in usr/src/cmd/Makefile.cmd.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="_3_2_5_2_ISA_Dependent_Librarie"></a>3.2.5.2 ISA-Dependent Libraries</h4></div></div></div><p>
Libraries, unlike commands, must almost always be built for all
supported ISAs and have separate ISA-specific versions installed on,
at minimum, every system that supports that ISA.  In practice,
libraries for each ISA in the system's processor family are installed.
This allows developers on that system to write programs using any
supported ISA and link them with the appropriate system libraries (it
is not possible, for example, to link 32-bit object files and 64-bit
libraries, nor vice versa).
</p><p>
Libraries use a build system very similar to that used by commands
which must provide multiple ISA-specific executable programs.  We
examine here the makefiles used by dtrace(1)'s library counterpart
libdtrace(3LIB) and how they support building and installing multiple
ISA-specific versions of the dtrace library.
</p><p>
lib/libdtrace contains two makefiles: Makefile and Makefile.com.  It
also contains a directory for common code and four ISA directories:
amd64, i386, sparc, and sparcv9.  Each ISA directory contains a single
makefile and in some cases some ISA-specific sources.  The top-level
Makefile should once again look very familiar; is very similar to the
uts and cmd makefiles and is mainly boilerplate.  There are a few
customizations to add a yydebug target and to tell top-level makefiles
that lex and yacc generated files should not have cross-references
built against them.
</p><pre class="programlisting">
yydebug := TARGET = yydebug
...
lint yydebug: $(SUBDIRS)
</pre><p>
and
</p><pre class="programlisting">
XRDIRS = common i386 sparc sparcv9
XRDEL = dt_lex.c dt_grammar.c Makefile*
</pre><p>
Otherwise, it simply leaves all building and installation to the
makefiles in the ISA subdirectories.  Makefile.com is somewhat more
interesting.  It first specifies the name of the library to build (in
static format; shared library names are translated as we shall see
below), and the library version.  These are common to all library
makefiles.  Next, we see long lists of source files used to build the
library, and an OBJECTS specification.  This particular library also has
some unique characteristics, including the D runtime init code, built as
a separate object file (drti.o), and a number of D "header" files which
are installed into a separate directory /usr/lib/dtrace.  You can see
these unique features here:
</p><pre class="programlisting">
DRTISRC = drti.c
DRTIOBJ = $(DRTISRC:%.c=%.o)
</pre><pre class="programlisting">
DLIBSRCS += \
	errno.d \
	io.d \
	procfs.d \
	regs.d \
	sched.d \
	signal.d \
	unistd.d
...
ROOTDLIBDIR = $(ROOT)/usr/lib/dtrace
ROOTDLIBDIR64 = $(ROOT)/usr/lib/dtrace/64
...
$(ROOTDLIBDIR):
	$(INS.dir)
</pre><pre class="programlisting">
$(ROOTDLIBDIR64): $(ROOTDLIBDIR)
	$(INS.dir)
</pre><pre class="programlisting">
$(ROOTDLIBDIR)/%.d: ../common/%.d
	$(INS.file)
</pre><pre class="programlisting">
$(ROOTDLIBDIR)/%.d: ../$(MACH)/%.d
	$(INS.file)
</pre><pre class="programlisting">
$(ROOTDLIBDIR)/%.d: %.d
	$(INS.file)
</pre><p>
Note that some of the D "headers" are in turn generated from other
files; this makefile includes rules for performing these
transformations.
</p><p>
Once the LIBSRCS and OBJECTS have been defined, the generic library
makefile fragment Makefile.lib is included to provide target and
directory definitions.
</p><p>
Binary objects are built in the pics/ subdirectory.  pics stands for
position- independent code(s), referring to the fact that dynamic shared
libraries are built in such a way as to be loaded at any address.  This
is an historical artifact; static linking of system libraries is not
supported by OpenSolaris-based distributions, so the non-PIC objects
which would have been used to build an archive-style library are not
built.  The rules for building are given as:
</p><pre class="programlisting">
pics/%.o: ../$(MACH)/%.c 
	$(COMPILE.c) -o $@ $&lt;
	$(POST_PROCESS_O)
</pre><pre class="programlisting">
pics/%.o: ../$(MACH)/%.s
	$(COMPILE.s) -o $@ $&lt;
	$(POST_PROCESS_O)
</pre><pre class="programlisting">
%.o: ../common/%.c
	$(COMPILE.c) -o $@ $&lt;
	$(POST_PROCESS_O)
</pre><p>
Note that because this makefile fragment is included by each ISA's
makefile, the objects produced will be placed relative to that
makefile, in each ISA directory.  Once again, this also means that
included makefile fragments include an additional ../ component.
</p><p>
The libdtrace Makefile.com also contains a large number of custom
rules to accommodate building a lexer and parser from lex(1) and
yacc(1) definitions; these sources are then compiled specially using
the custom rules and are removed when the clean or clobber target is
executed.
</p><p>
The makefiles in the ISA-specific build directories are once again
very simple.  The SPARC-specific makefile, for example, defines
additional assembler flags, specifies the directory where the library
interface map is located, and then includes the common makefile:
</p><pre class="programlisting">
ASFLAGS += -D_ASM -K PIC -P
</pre><pre class="programlisting">
MAPDIR = ../spec/sparc
include ../Makefile.com
</pre><p>
The makefile may also add a few ISA-specific sources to the build
list; for example, sparc/Makefile includes:
</p><pre class="programlisting">
SRCS += dt_asmsubr.s
OBJECTS += dt_asmsubr.o
</pre><p>
And once again, a separate install target is provided to indicate the
directories where these specific libraries and headers should be
installed:
</p><pre class="programlisting">
install yydebug: all $(ROOTLIBS) $(ROOTLINKS) $(ROOTLINT) \
	$(ROOTDLIBS) $(ROOTDOBJS)
</pre><p>
To support building a separate set of 64-bit objects, sparcv9/Makefile
includes slightly different definitions and a different install
target:
</p><pre class="programlisting">
MAPDIR = ../spec/sparcv9
include ../Makefile.com
include ../../Makefile.lib.64
</pre><pre class="programlisting">
CPPFLAGS += -D_ELF64
...
install yydebug: all $(ROOTLIBS64) $(ROOTLINKS64) $(ROOTLINT64) \
	$(ROOTDLIBS) $(ROOTDOBJS64)
</pre><p>
Note the additional inclusion of Makefile.lib.64 and the additional
flag for 64-bit ELF targets.  Also, the 64-bit-specific versions of
the installation files are used, which as we can see in Makefile.lib
cause them to be installed into /usr/lib/sparcv9:
</p><pre class="programlisting">
ROOTLIBDIR=     $(ROOT)/usr/lib
ROOTLIBDIR64=   $(ROOT)/usr/lib/$(MACH64)
...
ROOTLIBS=       $(LIBS:%=$(ROOTLIBDIR)/%)
ROOTLIBS64=     $(LIBS:%=$(ROOTLIBDIR64)/%)
</pre><p>
The linker (ld(1)) and runtime loader (ld.so.1(1)) know which of these
directories to search for libraries depending on the bitness of the
objects being linked or the program being run, respectively.  For more
information about 32- versus 64-bit linking, consult the Solaris Linkers
and Libraries Guide, which can be found at
<a href="http://docs.sun.com/db/doc/816-1386" target="_top">http://docs.sun.com/db/doc/816-1386</a>.
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_6_Understanding_Kernel_Mod"></a>3.2.6 Understanding Kernel Module Installation</h3></div></div></div><p>
The install target causes binaries and headers to be installed into a
hierarchy called the prototype or proto area (see section 4.4.1 for more
information on the prototype area's contents and purpose).  The root of
the proto area is defined by the environment variable ROOT.  This
variable is used in defining ROOT_MOD_DIR and USR_MOD_DIR in
usr/src/uts/Makefile.uts:
</p><pre class="programlisting">
ROOT_MOD_DIR               = $(ROOT)/kernel
USR_MOD_DIR                = $(ROOT)/usr/kernel
</pre><p>
All modules are installed below one of these directories.  The exact
subdirectory used depends on the definition of ROOTMODULE in the
module build directory, which is discussed below.
</p><p>
Additional files to be installed may be given by the INSTALL_TARGET
definition in this makefile.  For example, the asy makefile
(usr/src/uts/intel/asy/Makefile) specifies:
</p><pre class="programlisting">
INSTALL_TARGET  = $(BINARY) $(ROOTMODULE) $(ROOT_CONFFILE)
</pre><p>
Since this is a common set of installation targets, let's look at how
each component is derived.
</p><p>
$(BINARY) is simply the module itself; we've discussed its
dependencies and rules in detail above.  Including it here requires it
to be fully built before any installation is attempted.
</p><p>
$(ROOTMODULE) is a name transform on the name of the module, relocating it
into the prototype area.  For example, usr/src/uts/intel/asy/Makefile defines:
</p><pre class="programlisting">
ROOTMODULE      = $(ROOT_DRV_DIR)/$(MODULE)
</pre><p>
ROOT_DRV_DIR requires a bit of additional explanation; it is one of
many module installation subdirectories defined in Makefile.uts.
Because the ending location of binary kernel modules depends on the
machine type, specifically its 32 versus 64 bitness, there are really
several definitions.  First, the subdirectory definition for each
64-bit machine type:
</p><pre class="programlisting">
SUBDIR64_sparc          = sparcv9
SUBDIR64_i386           = amd64
SUBDIR64                = $(SUBDIR64_$(MACH))
</pre><p>
Next, the 32- and 64-bit installation directories for each type of
module:
</p><pre class="programlisting">
ROOT_KERN_DIR_32        = $(ROOT_MOD_DIR)
ROOT_DRV_DIR_32         = $(ROOT_MOD_DIR)/drv
ROOT_DTRACE_DIR_32      = $(ROOT_MOD_DIR)/dtrace
ROOT_EXEC_DIR_32        = $(ROOT_MOD_DIR)/exec
...
</pre><pre class="programlisting">
ROOT_KERN_DIR_64        = $(ROOT_MOD_DIR)/$(SUBDIR64)
ROOT_DRV_DIR_64         = $(ROOT_MOD_DIR)/drv/$(SUBDIR64)
ROOT_DTRACE_DIR_64      = $(ROOT_MOD_DIR)/dtrace/$(SUBDIR64)
ROOT_EXEC_DIR_64        = $(ROOT_MOD_DIR)/exec/$(SUBDIR64)
...
</pre><p>
And finally the selection of either the 32- or 64-bit directory based
on the actual bitness of this build:
</p><pre class="programlisting">
ROOT_KERN_DIR           = $(ROOT_KERN_DIR_$(CLASS))
ROOT_DRV_DIR            = $(ROOT_DRV_DIR_$(CLASS))
ROOT_DTRACE_DIR         = $(ROOT_DTRACE_DIR_$(CLASS))
ROOT_EXEC_DIR           = $(ROOT_EXEC_DIR_$(CLASS))
...
</pre><p>
There are similar definitions for USR_XXX_DIR based in
$(ROOT)/usr/kernel.  See usr/src/uts/Makefile.uts for the complete
list of possible ROOT_ and USR_ installation directories.
</p><p>
The rules for installing files into each of these directories are
given in usr/src/uts/Makefile.targ:
</p><pre class="programlisting">
$(ROOT_MOD_DIR)/%:      $(OBJS_DIR)/% $(ROOT_MOD_DIR) FRC
	$(INS.file)
</pre><pre class="programlisting">
$(ROOT_DRV_DIR)/%:      $(OBJS_DIR)/% $(ROOT_DRV_DIR) FRC
	$(INS.file)
...
</pre><p>
These rules install the file currently located in $(OBJS_DIR),
described in detail above, into the appropriate directory in the proto
area.
</p><p>
$(ROOT_CONFFILE) is the module's configuration file (most commonly
used for drivers), transformed into the proto area.  The CONFFILE
variables are defined in usr/src/uts/Makefile.uts:
</p><pre class="programlisting">
CONFFILE                = $(MODULE).conf
SRC_CONFFILE            = $(CONF_SRCDIR)/$(CONFFILE)
ROOT_CONFFILE_32        = $(ROOTMODULE).conf
ROOT_CONFFILE_64        = $(ROOTMODULE:%/$(SUBDIR64)/$(MODULE)=%/$(MODULE)).conf
ROOT_CONFFILE           = $(ROOT_CONFFILE_$(CLASS))
</pre><p>
Each module's Makefile defines CONF_SRCDIR to specify the location of
the configuration file that should be installed on this platform.  The
asy makefile defines:
</p><pre class="programlisting">
CONF_SRCDIR     = $(UTSBASE)/common/io
</pre><p>
which causes usr/src/uts/common/io/asy.conf to be installed in the
proto area as /kernel/drv/asy.conf.  Note that the configuration file
installation directory does not depend on whether this is a 32- or
64-bit build.
</p><p>
Note that although it is confusing, installation targets are always
named ROOTMODULE, ROOT_CONFFILE, and so on, even if they are actually
installed into one of the USR_ directories.  This simplifies the
higher-level makefiles.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_7_Finding_Sources_for_a_Mo"></a>3.2.7 Finding Sources for a Module</h3></div></div></div><p>
As we've seen, the sources are derived from $(XXX_OBJS) and the included
rules.  Now, here's the tricky part - finding where those sources are.
The easiest way by far is to run make from the module's object directory
and observe the compilation commands that are run.  The path to each
source file will be included in the output.  This is the simplest and
recommended way to find which source files are needed to build a module.
However, if this does not work (perhaps the makefile itself is buggy) or
if you want to gain greater understanding, the rest of this section
describes logical processes for finding source files.
</p><p>
Since you know the basenames (they are simply the XXX_OBJS entries with
.o replaced by .c) you can use a simple
</p><pre class="programlisting">
$ find usr/src/uts -name asy.c
</pre><p>
Suppose you find two source files with the same name - which is
actually used?  There are two ways to figure this out.  The lazy way
is to use make -d to show you the exact dependencies being used.
Alternatively, you could reason it out, starting with the fact that
not all source files are used on your platform (i.e.,
usr/src/uts/sparc/* is not used by x86 builds), and then looking at
the specific order of the rules in each Makefile.rules.  The more
specific rules are listed first and take precedence over later rules
(in fact they all add a dependency to the specific object file in
question, but since the rules all use $&lt;, only the first dependency is
actually used).
</p><p>
Non-kernel source files are easier to locate, since the cmd and lib
directories are generally organized with one subdirectory for each
library or command, named accordingly.  The major exceptions are
cmd/sgs, which contains the entire binary tools subsystem, and
cmd/cmd-inet, which contains most of the Berkeley networking commands
and daemons as well as some additional network-related utilities, laid
out in a BSD-style directory structure.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="_3_2_8_Source_Files_not_Include"></a>3.2.8 Source Files not Included</h3></div></div></div><p>
Some sources used to build the branded Solaris product are not included in
OpenSolaris.  There are two main reasons for this:
</p><div class="itemizedlist"><ul type="disc"><li><p>The source could be subject to third-party rights.</p><p>
Sun's lawyers won't let anyone talk about this.  Not even a little bit.
They do love explaining it themselves, though, so you should contact
Sun's legal department and ask there.  We can't help you.  Sorry.
</p></li><li><p>The consolidation may not yet have been released.</p><p>
OpenSolaris does not yet include all consolidations in Solaris, and some
consolidations are still incomplete.  See the program roadmap at
<a href="http://www.opensolaris.org/os/about/roadmap/" target="_top">http://www.opensolaris.org/os/about/roadmap/</a> and the downloads page
at <a href="http://www.opensolaris.org/os/downloads/" target="_top">http://www.opensolaris.org/os/downloads/</a> for information on the
consolidations that interest you.
</p></li></ul></div><p>
To accommodate fully functional builds even though some sources are
missing, a set of closed binaries are available, and the build system
has been modified to make use of them.  The makefile variable
CLOSED_BUILD controls whether the build system will use the prebuilt
closed binaries or look for the closed sources.
</p><p>
CLOSED_BUILD is typically used in makefile lines that build up the
list of modules or subdirectories that are to be built.  Makefile
lines that start with CLOSED_BUILD, e.g.,
</p><pre class="programlisting">
$(CLOSED_BUILD)DCSUBDIRS += \
	$(CLOSED)/cmd/pax
</pre><p>
are for use only when the closed sources are present.
</p><p>
Sometimes a separate closed module list is built up, rather than
adding to the open module list.  This approach is used extensively in
the kernel, as in
</p><pre class="programlisting">
$(CLOSED_BUILD)CLOSED_DRV_KMODS	+= chxge
</pre><p>
Because this approach requires additional variables, the first
approach is usually preferred.  The second approach is used when the
list needs to contain individual component names, rather than paths.
For example, the kernel makefiles use the module names to construct a
series of "-l" clauses for linting; that would be a lot messier if
paths were used instead of module names.
</p><p>
You shouldn't normally need to set CLOSED_BUILD.  Instead, bldenv(1)
and nightly(1) set the environment variable CLOSED_IS_PRESENT, and the
ON makefiles use this to set CLOSED_BUILD.
</p><p>
The kernel provides an additional challenge, which is that many
makefile rules and declarations are practically the same for both
the open and closed source trees.  To avoid duplication of code, the
common text was put in shared makefiles (e.g., Makefile.sun4u.shared).
When used for open code, the makefile variable $(UTSTREE) is set to
$(UTSBASE).  For closed code, it is set to $(UTSCLOSED).
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. The Source Tree </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3.3 Using Your Workspace</td></tr></table></div></body></html>
