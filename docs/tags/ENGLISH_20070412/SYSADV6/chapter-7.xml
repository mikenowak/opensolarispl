<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "docbook.dtd"[
	<!ENTITY % xinclude SYSTEM "xinclude.mod">
	%xinclude;
]>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="prbac-1">



<title>Using Roles and Privileges (Overview)</title>
<toc>
<para>Solaris role-based access control (RBAC) and privileges provide a more secure
alternative to superuser. This chapter provides overview information about RBAC and
about privileges.</para>
<para>The following is a list of the overview information in this chapter.</para>
<itemizedlist>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-7.xml" targetptr="rbac-1">Role-Based Access Control (Overview)</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="internal" targetdoc="chapter-7.xml" targetptr="prbac-2">Privileges (Overview)</olink>
</para>
</listitem>
</itemizedlist>
</toc>
<sect1 xml:id="rbac-1">
<title>Role-Based Access Control (Overview)</title>
<indexterm xml:id="indexterm-995">
<primary>process rights management</primary>
<see>
privileges</see>
</indexterm>
<para>Role-based access control (RBAC) is a security feature for controlling user
access to tasks that would normally be restricted to superuser. By applying security
attributes to processes and to users, RBAC can divide up superuser capabilities among
several administrators. Process rights management is implemented through <firstterm>privileges</firstterm>. User rights management is implemented through RBAC.</para>
<itemizedlist>
<listitem>
<para>For a discussion of process rights management, see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="prbac-2">Privileges (Overview)</olink>.</para>
</listitem>
<listitem>
<para>For information on RBAC tasks, see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-1">Chapter 8, Using Role-Based Access Control (Tasks)</olink>.</para>
</listitem>
<listitem>
<para>For reference information, see <olink remap="external" targetdoc="chapter-9.xml" targetptr="rbacref-1">Chapter 9, Role-Based Access Control (Reference)</olink>.</para>
</listitem>
</itemizedlist>
<sect2 xml:id="rbac-28">
<title>RBAC: An Alternative to the Superuser Model</title>
<indexterm xml:id="indexterm-996">
<primary>role-based access control</primary>
<see>
RBAC</see>
</indexterm>
<indexterm xml:id="indexterm-997">
<primary>RBAC</primary>
<secondary>compared to superuser model</secondary>
</indexterm>
<indexterm xml:id="indexterm-998">
<primary>superuser</primary>
<secondary>compared to RBAC model</secondary>
</indexterm>
<indexterm xml:id="indexterm-999">
<primary>system security</primary>
<secondary>role-based access control (RBAC)</secondary>
</indexterm>
<para>In conventional UNIX systems, the <literal>root</literal> user, also referred
to as superuser, is all-powerful. Programs that run as <literal>root</literal>, or <command>setuid</command> programs, are all-powerful. The <literal>root</literal> user has
the ability to read and write to any file, run all programs, and send kill signals
to any process. Effectively, anyone who can become superuser can modify a site's firewall,
alter the audit trail, read confidential records, and shut down the entire network.
A <command>setuid</command> program that is hijacked can do anything on the system.</para>
<para>
<indexterm xml:id="indexterm-1000">
<primary>roles</primary>
<secondary>recommended roles</secondary>
</indexterm>
<indexterm xml:id="indexterm-1001">
<primary>roles</primary>
<secondary>use in RBAC</secondary>
</indexterm>Role-based access control (RBAC) provides a more secure alternative to
the all-or-nothing superuser model. With RBAC, you can enforce security policy at
a more fine-grained level. RBAC uses the security principle of <firstterm>least privilege</firstterm>. Least privilege means that a user has precisely the amount of privilege
that is necessary to perform a job. Ordinary users have enough privilege to use their
applications, check the status of their jobs, print files, create new files, and so
on. Capabilities beyond ordinary user capabilities are grouped into rights profiles.
Users who are expected to do jobs that require some of the capabilities of superuser
assume a role that includes the appropriate rights profile.</para>
<para>RBAC collects superuser capabilities into <firstterm>rights profiles</firstterm>.
These rights profiles are assigned to special user accounts that are called <emphasis>roles</emphasis>. A user can then assume a role to do a job that requires some of
superuser's capabilities. Predefined rights profiles are supplied with Solaris software.
You create the roles and assign the profiles.</para>
<para>Rights profiles can provide broad capabilities. For example, the Primary Administrator
rights profile is equivalent to superuser. Rights profiles can also be narrowly defined.
For example, the Cron Management rights profile manages <command>at</command> and <command>cron</command> jobs. When you create roles, you can decide to create roles with broad
capabilities, or roles with narrow capabilities, or both.</para>
<para>In the RBAC model, superuser creates one or more roles. The roles are based
on rights profiles. Superuser then assigns the roles to users who are trusted to perform
the tasks of the role. Users log in with their user name. After login, users assume
roles that can run restricted administrative commands and graphical user interface
(GUI) tools. </para>
<para>The flexibility in setting up roles enables a variety of security policies.
Although no roles are shipped with the Solaris Operating System (Solaris OS), three recommended roles can
easily be configured. The roles are based on rights profiles of the same name:</para>
<itemizedlist>
<listitem>
<para>
<indexterm xml:id="indexterm-1002">
<primary>Primary Administrator (RBAC)</primary>
<secondary>recommended role</secondary>
</indexterm>
<emphasis role="strong">Primary Administrator –</emphasis> A powerful role that is equivalent to the <literal>root</literal> user,
or superuser.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1003">
<primary>System Administrator (RBAC)</primary>
<secondary>recommended role</secondary>
</indexterm>
<emphasis role="strong">System Administrator –</emphasis> A less powerful role for administration that is not related to security.
This role can manage file systems, mail, and software installation. However, this
role cannot set passwords.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1004">
<primary>Operator (RBAC)</primary>
<secondary>recommended role</secondary>
</indexterm>
<emphasis role="strong">Operator –</emphasis> A
junior administrator role for operations such as backups and printer management.</para>
</listitem>
</itemizedlist>
<para>These three roles do not have to be implemented. Roles are a function of an
organization's security needs. Roles can be set up for special-purpose administrators
in areas such as security, networking, or firewall administration. Another strategy
is to create a single powerful administrator role along with an advanced user role.
The advanced user role would be for users who are permitted to fix portions of their
own systems.</para>
<para>The superuser model and the RBAC model can co-exist. The following table summarizes
the gradations from superuser to restricted ordinary user that are possible in the
RBAC model. The table includes the administrative actions that can be tracked in both
models. For a summary of the effect of privileges alone on a system, see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="prbac-tbl-1">Table 7–2</olink>.</para>
<table frame="topbot" xml:id="rbac-tbl-7">

<title>Superuser Model Versus RBAC With Privileges
Model</title>
<tgroup cols="3" colsep="0" rowsep="0">
<colspec colwidth="61.14*"/>
<colspec colname="colspec0" colwidth="36.12*"/>
<colspec colwidth="52.74*"/>
<thead>
<row>
<entry rowsep="1">
<para>User Capabilities on a System</para>
</entry>
<entry rowsep="1">
<para>Superuser Model</para>
</entry>
<entry rowsep="1">
<para>RBAC Model</para>
</entry>
</row>
</thead>
<tbody>
<row>
<entry>
<para>Can become superuser with full superuser capability</para>
</entry>
<entry>
<para>Yes</para>
</entry>
<entry>
<para>Yes</para>
</entry>
</row>
<row>
<entry>
<para>Can log in as a user with full user capabilities</para>
</entry>
<entry>
<para>Yes</para>
</entry>
<entry>
<para>Yes</para>
</entry>
</row>
<row>
<entry>
<para>Can become superuser with limited capabilities</para>
</entry>
<entry>
<para>No</para>
</entry>
<entry>
<para>Yes</para>
</entry>
</row>
<row>
<entry>
<para>Can log in as a user, and have superuser capabilities, sporadically</para>
</entry>
<entry>
<para>Yes, with <command>setuid</command> programs only</para>
</entry>
<entry>
<para>Yes, with <command>setuid</command> programs and with RBAC</para>
</entry>
</row>
<row>
<entry>
<para>Can log in as a user with administrative capabilities, but without full superuser
capability</para>
</entry>
<entry>
<para>No</para>
</entry>
<entry>
<para>Yes, with RBAC and with directly-assigned privileges and authorizations</para>
</entry>
</row>
<row>
<entry>
<para>Can log in as a user with fewer capabilities than an ordinary user</para>
</entry>
<entry>
<para>No</para>
</entry>
<entry>
<para>Yes, with RBAC and with removed privileges</para>
</entry>
</row>
<row>
<entry>
<para>Can track superuser actions</para>
</entry>
<entry>
<para>Yes, by auditing the <command>su</command> command</para>
</entry>
<entry>
<para>Yes, by auditing profile shell commands</para>
<para>Also, if <literal>root</literal> user is disabled, the name of the user who
has assumed the <literal>root</literal> role is in the audit trail</para>
</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="rbac-29">
<title>Solaris RBAC Elements and Basic Concepts</title>
<indexterm xml:id="indexterm-1005">
<primary>profiles</primary>
<see>
rights profiles</see>
</indexterm>
<indexterm xml:id="indexterm-1006">
<primary>RBAC</primary>
<secondary>elements</secondary>
</indexterm>
<indexterm xml:id="indexterm-1007">
<primary>components</primary>
<secondary>RBAC</secondary>
</indexterm>
<indexterm xml:id="indexterm-1008">
<primary>RBAC</primary>
<secondary>basic concepts</secondary>
</indexterm>
<para>The RBAC model in the Solaris OS introduces the following elements:</para>
<itemizedlist>
<listitem>
<para>
<indexterm xml:id="indexterm-1009">
<primary>authorizations (RBAC)</primary>
<secondary>description</secondary>
</indexterm>
<emphasis role="strong">Authorization –</emphasis> A
permission that enables a user or role to perform a class of actions that could affect
security. For example, security policy at installation gives ordinary users the <literal>solaris.device.cdrw</literal> authorization. This authorization enables users to read
and write to a CD-ROM device. For a list of authorizations, see the <filename>/etc/security/auth_attr</filename> file.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1010">
<primary>privileges</primary>
<secondary>description</secondary>
</indexterm>
<emphasis role="strong">Privilege –</emphasis> A discrete right
that can be granted to a command, a user, a role, or a system. Privileges enable a
process to succeed. For example, the <literal>proc_exec</literal> privilege allows
a process to call <function>execve
</function>. Ordinary users have basic privileges.
To see your basic privileges, run the <command>ppriv -vl basic</command> command.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1011">
<primary>privileges</primary>
<secondary>description</secondary>
</indexterm>
<emphasis role="strong">Security attributes –</emphasis> An attribute
that enables a process to perform an operation. In a typical UNIX environment, a security
attribute enables a process to perform an operation that is otherwise forbidden to
ordinary users. For example, <command>setuid</command> and <command>setgid</command> programs
have security attributes. In the RBAC model, operations that ordinary users perform
might require security attributes. In addition to <command>setuid</command> and <command>setgid</command> programs, authorizations and privileges are also security attributes
in the RBAC model. For example, a user with the <literal>solaris.device.allocate</literal> authorization
can allocate a device for exclusive use. A process with the <literal>sys_time</literal> privilege
can manipulate system time.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1012">
<primary>privileged application</primary>
<secondary>description</secondary>
</indexterm>
<emphasis role="strong">Privileged application –</emphasis> An
application or command that can override system controls by checking for <firstterm>security attributes</firstterm>. In a typical UNIX environment and in the RBAC model,
programs that use <command>setuid</command> and <command>setgid</command> are privileged
applications. In the RBAC model, programs that require privileges or authorizations
to succeed are also privileged applications. For more information, see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="rbac-30">Privileged Applications and RBAC</olink>.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1013">
<primary>rights profiles</primary>
<secondary>description</secondary>
</indexterm>
<indexterm xml:id="indexterm-1014">
<primary>security attributes</primary>
<secondary>description</secondary>
</indexterm>
<emphasis role="strong">Rights profile –</emphasis> A collection of administrative capabilities that can be assigned to a
role or to a user. A rights profile can consist of authorizations, of commands with
security attributes, and of other rights profiles. Rights profiles offer a convenient
way to group security attributes.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1015">
<primary>roles</primary>
<secondary>summary</secondary>
</indexterm>
<emphasis role="strong">Role –</emphasis> A special identity for
running privileged applications. The special identity can be assumed by assigned users
only. In a system that is run by roles, superuser is unnecessary. Superuser capabilities
are distributed to different roles. For example, in a two-role system, security tasks
would be handled by a security role. The second role would handle system administration
tasks that are not security-related. Roles can be more fine-grained. For example,
a system could include separate administrative roles for handling the cryptographic
framework, printers, system time, file systems, and auditing.</para>
</listitem>
</itemizedlist>
<para>The following figure shows how the RBAC elements work together.</para>
<figure xml:id="rbac-fig-2">

<title>Solaris RBAC Element Relationships</title>
<mediaobject>
<imageobject>
<imagedata fileref="figures/rbac.elems.gif"/>
</imageobject>
<textobject>
<simpara>The following context describes the graphic.</simpara>
</textobject>
</mediaobject>
</figure>
<para>In RBAC, roles are assigned to users. When a user assumes a role, the capabilities
of the role are available. Roles get their capabilities from rights profiles. Rights
profiles can contain authorizations, privileged commands, and other supplementary
rights profiles. Privileged commands are commands that execute with security attributes.</para>
<para>The following figure uses the Operator role, the Operator rights profile, and
the Printer Management rights profile to demonstrate RBAC relationships.</para>
<figure xml:id="rbac-fig-1">

<title>Example of Solaris RBAC Element Relationships</title>
<mediaobject>
<imageobject>
<imagedata fileref="figures/rbac.ex.gif"/>
</imageobject>
<textobject>
<simpara>The following context describes the graphic.</simpara>
</textobject>
</mediaobject>
</figure>
<para>The Operator role is used to maintain printers and to perform media backup.
The role is assigned to the user <literal>jdoe</literal>. <literal>jdoe</literal> can
assume the role by switching to the role, and then supplying the role password.</para>
<para>The Operator rights profile has been assigned to the Operator role. The Operator
rights profile contains two supplementary profiles, Printer Management and Media Backup.
The supplementary profiles reflect the role's primary tasks.</para>
<para>
<indexterm xml:id="indexterm-1016">
<primary>security attributes</primary>
<secondary>Printer management rights profile</secondary>
</indexterm>The Printer Management rights profile is for
managing printers, print daemons, and spoolers. Three authorizations are included
in the Printer Management rights profile: <literal>solaris.admin.printer.read</literal>, <literal>solaris.admin.printer.delete</literal>, and <literal>solaris.admin.printer.modify</literal>. These authorizations enable roles and users to manipulate information
in the printer queue. The Printer Management rights profile also includes a number
of commands with security attributes, such as <command>/usr/sbin/lpshut</command> with <literal>euid=lp</literal> and <command>/usr/ucb/lpq</command> with <literal>euid=0</literal>.</para>
</sect2>
<sect2 xml:id="rbac-32">
<title>RBAC Authorizations</title>
<indexterm xml:id="indexterm-1017">
<primary>authorizations (RBAC)</primary>
<secondary>definition</secondary>
</indexterm>
<indexterm xml:id="indexterm-1018">
<primary>RBAC</primary>
<secondary>authorizations</secondary>
</indexterm>
<para>An <emphasis>authorization</emphasis> is a discrete right that can be granted
to a role or to a user. Authorizations enforce policy at the user application level.
Authorizations can be assigned directly to a role or to a user. Typically, authorizations
are included in a rights profile. The rights profile is then included in a role, and
the role is assigned to a user. For an example, see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="rbac-fig-1">Figure 7–2</olink>.</para>
<para>RBAC-compliant applications can check a user's authorizations prior to granting
access to the application or specific operations within the application. This check
replaces the check in conventional UNIX applications for <literal>UID=0</literal>.
For more information on authorizations, see the following sections:</para>
<itemizedlist>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-9.xml" targetptr="rbacref-28">Authorization Naming and Delegation</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-9.xml" targetptr="rbacref-11">auth_attr Database</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-9.xml" targetptr="rbacref-4">Commands That Require Authorizations</olink>
</para>
</listitem>
</itemizedlist>
</sect2>
<sect2 xml:id="rbac-38">
<title>Authorizations and Privileges</title>
<para>Privileges enforce security policy in the kernel. The difference between authorizations
and privileges concerns the level at which the security policy is enforced. Without
the proper privilege, a process can be prevented from performing privileged operations
by the kernel. Without the proper authorizations, a user might be prevented from using
a privileged application or from performing security-sensitive operations within a
privileged application. For a fuller discussion of privileges, see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="prbac-2">Privileges (Overview)</olink>.</para>
</sect2>
<sect2 xml:id="rbac-30">
<title>Privileged Applications and RBAC</title>
<para>Applications and commands that can override system controls are considered privileged
applications. Security attributes such as <literal>UID=0</literal>, privileges, and
authorizations make an application privileged.</para>
<sect3 xml:id="rbac-35">
<title>Applications That Check UIDs and GIDs</title>
<para>
<indexterm xml:id="indexterm-1019">
<primary>privileged application</primary>
<secondary>ID checking</secondary>
</indexterm>
<indexterm xml:id="indexterm-1020">
<primary>security attributes</primary>
<secondary>checking for</secondary>
</indexterm>Privileged applications that check for <literal>root</literal> (<literal>UID=0</literal>) or some other special UID or GID have long existed in the UNIX environment.
The  rights profile mechanism enables you to isolate commands that require a specific
ID. Instead of changing the ID on a command that anyone can access, you can place
the command with execution security attributes in a rights profile. A user or role
with that rights profile can then run the program without having to become superuser.</para>
<para>
<indexterm xml:id="indexterm-1021">
<primary>security attributes</primary>
<secondary>special ID on commands</secondary>
</indexterm>IDs can be specified as real or effective. Assigning effective
IDs is preferred over assigning real IDs. Effective IDs are equivalent to the <command>setuid</command> feature in the file permission bits. Effective IDs also identify
the UID for auditing. However, because some shell scripts and programs require a real
UID of <literal>root</literal>, real UIDs can be set as well. For example, the <command>pkgadd</command> command requires a real rather than an effective UID. If an effective
ID is not sufficient to run a command, you need to change the ID to a real ID. For
the procedure,  see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-24">How to Create or Change a Rights
Profile</olink>.</para>
</sect3>
<sect3 xml:id="rbac-21">
<title>Applications That Check for Privileges</title>
<para>
<indexterm xml:id="indexterm-1022">
<primary>privileged application</primary>
<secondary>privilege checking</secondary>
</indexterm>
<indexterm xml:id="indexterm-1023">
<primary>privilege checking</primary>
<secondary>in applications</secondary>
</indexterm>
<indexterm xml:id="indexterm-1024">
<primary>security attributes</primary>
<secondary>privileges on commands</secondary>
</indexterm>Privileged applications can
check for the use of privileges. The RBAC rights profile mechanism enables you to
specify the privileges for specific commands. Instead of requiring superuser capabilities
to use an application or command, you can isolate the command with execution security
attributes in a rights profile. A user or role with that rights profile can then run
the command with just the privileges that the command requires to succeed.</para>
<para>
<indexterm xml:id="indexterm-1025">
<primary>commands</primary>
<secondary>that check for privileges</secondary>
</indexterm>Commands that check for privileges include the following:</para>
<itemizedlist>
<listitem>
<para>Kerberos commands, such as <command>kadmin</command>, <command>kprop</command>, and <command>kdb5_util</command>
</para>
</listitem>
<listitem>
<para>Network commands, such as <command>ifconfig</command>, <command>routeadm</command>, and <command>snoop</command>
</para>
</listitem>
<listitem>
<para>File and file system commands, such as <command>chmod</command>, <command>chgrp</command>, and <command>mount</command>
</para>
</listitem>
<listitem>
<para>Commands that control processes, such as <command>kill</command>, <command>pcred</command>, and <command>rcapadm</command>
</para>
</listitem>
</itemizedlist>
<para>To add commands with privileges to a rights profile, see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-24">How to Create or Change a Rights Profile</olink>. To determine what commands check
for privileges in a particular profile, see <olink remap="external" targetdoc="chapter-10.xml" targetptr="privtask-20">Determining
Your Assigned Privileges</olink>.</para>
</sect3>
<sect3 xml:id="rbac-36">
<title>Applications That Check Authorizations</title>
<para>
<indexterm xml:id="indexterm-1026">
<primary>privileged application</primary>
<secondary>authorization checking</secondary>
</indexterm>
<indexterm xml:id="indexterm-1027">
<primary>authorizations (RBAC)</primary>
<secondary>checking in privileged application</secondary>
</indexterm>The Solaris OS additionally
provides commands that check authorizations. By definition, the <literal>root</literal> user
has all authorizations. Therefore, the <literal>root</literal> user can run any application.
Applications that check for authorizations include the following:</para>
<itemizedlist>
<listitem>
<para>The entire Solaris Management Console suite of tools</para>
</listitem>
<listitem>
<para>Audit administration commands, such as <command>auditconfig</command> and <command>auditreduce</command>
</para>
</listitem>
<listitem>
<para>Printer administration commands, such as <command>lpadmin</command> and <command>lpfilter</command>
</para>
</listitem>
<listitem>
<para>The batch job-related commands, such as <command>at</command>, <command>atq</command>, <command>batch</command>, and <command>crontab</command>
</para>
</listitem>
<listitem>
<para>Device-oriented commands, such as <command>allocate</command>, <command>deallocate</command>, <command>list_devices</command>, and <command>cdrw</command>.</para>
</listitem>
</itemizedlist>
<para>To test a script or program for authorizations, see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-12">Example 8–19</olink>. To write a program that requires authorizations, see <olink remap="external" targetdoc="819-2145" targetptr="priv-14">
<citetitle remap="section">About Authorizations</citetitle> in <citetitle remap="book">Solaris Security for Developers Guide</citetitle>
</olink>.</para>
</sect3>
</sect2>
<sect2 xml:id="rbac-33">
<title>RBAC Rights Profiles</title>
<indexterm xml:id="indexterm-1028">
<primary>rights profiles</primary>
<secondary>description</secondary>
</indexterm>
<indexterm xml:id="indexterm-1029">
<primary>RBAC</primary>
<secondary>rights profiles</secondary>
</indexterm>
<para>A <emphasis>rights profile</emphasis> is a collection of system overrides that
can be assigned to a role or user. A rights profile can include authorizations, commands
with assigned security attributes, and other rights profiles. Rights profile information
is split between the <literal>prof_attr</literal> and <literal>exec_attr</literal> databases.
The rights profile name and authorizations are in the <literal>prof_attr</literal> database.
The rights profile name and the commands with assigned security attributes are in
the <literal>exec_attr</literal> database. For more information on rights profiles,
see the following sections:</para>
<itemizedlist>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-9.xml" targetptr="rbacref-26">Contents of Rights Profiles</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-9.xml" targetptr="rbacref-12">prof_attr Database</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-9.xml" targetptr="rbacref-13">exec_attr Database</olink>
</para>
</listitem>
</itemizedlist>
</sect2>
<sect2 xml:id="rbac-31">
<title>RBAC Roles</title>
<indexterm xml:id="indexterm-1030">
<primary>roles</primary>
<secondary>description</secondary>
</indexterm>
<para>A <emphasis>role</emphasis> is a special type of user account from which you
can run privileged applications. Roles are created in the same general manner as user
accounts. Roles have a home directory, a group assignment, a password, and so on.
Rights profiles and authorizations give the role administrative capabilities. Roles
cannot inherit capabilities from other roles or other users. Discrete roles parcel
out superuser capabilities, and thus enable more secure administrative practices.</para>
<para>When a user assumes a role, the role's attributes replace all user attributes.
Role information is stored in the <literal>passwd</literal>, <literal>shadow</literal>,
and <literal>user_attr</literal> databases. Role information can be added to the <literal>audit_user</literal> database. For detailed information on setting up roles, see the
following sections:</para>
<itemizedlist>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-16">How to Plan Your RBAC Implementation</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-22">How to Create a Role From the Command
Line</olink>
</para>
</listitem>
<listitem>
<para>
<olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-23">How to Change the Properties of a Role</olink>
</para>
</listitem>
</itemizedlist>
<para>A role can be assigned to more than one user. All users who can assume the same
role have the same role home directory, operate in the same environment, and have
access to the same files. Users can assume roles from the command line by running
the <command>su</command> command and supplying the role name and password. Users
can also assume a role in the Solaris Management Console tool.</para>
<para>
<indexterm xml:id="indexterm-1031">
<primary>roles</primary>
<secondary>assuming after login</secondary>
</indexterm>
<indexterm xml:id="indexterm-1032">
<primary>
<literal>root</literal> user</primary>
<secondary>replacing in RBAC</secondary>
</indexterm>
<indexterm xml:id="indexterm-1033">
<primary>superuser</primary>
<secondary>eliminating in RBAC</secondary>
</indexterm>A role cannot log in directly. A user logs
in, and then assumes a role. Having assumed a role, the user cannot assume another
role without first exiting their current role. Having exited the role, the user can
then assume another role.</para>
<para>You can prevent anonymous <literal>root</literal> login by changing the <literal>root</literal> user into a role, as shown in  <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-20">How to
Make root User Into a Role</olink>.  If the profile shell command, <command>pfexec</command>, is being audited, the audit trail contains the login user's real UID,
the roles that the user has assumed, and the actions that the role performed. To audit
the system or a particular user for role operations, see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-34">How to Audit Roles</olink>.</para>
<para>No predefined roles are shipped with Solaris software.</para>
<itemizedlist>
<listitem>
<para>To configure the Primary Administrator role, see <olink remap="external" targetdoc="819-2379" targetptr="smcover-95">
<citetitle remap="section">Using the Solaris Management Tools With RBAC (Task Map)</citetitle> in <citetitle remap="book">System Administration Guide: Basic Administration</citetitle>
</olink>.</para>
</listitem>
<listitem>
<para>To configure other roles, see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-32">How to
Create and Assign a Role By Using the GUI</olink>.</para>
</listitem>
<listitem>
<para>To create roles on the command line, see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-10">Managing RBAC (Task Map)</olink>.</para>
</listitem>
</itemizedlist>
</sect2>
<sect2 xml:id="rbac-37">
<title>Profile Shell in RBAC</title>
<indexterm xml:id="indexterm-1034">
<primary>RBAC</primary>
<secondary>profile shells</secondary>
</indexterm>
<indexterm xml:id="indexterm-1035">
<primary>profile shells</primary>
<secondary>description</secondary>
</indexterm>
<indexterm xml:id="indexterm-1036">
<primary>shell</primary>
<secondary>privileged versions</secondary>
</indexterm>
<indexterm xml:id="indexterm-1037">
<primary>Bourne shell</primary>
<secondary>privileged version</secondary>
</indexterm>
<indexterm xml:id="indexterm-1038">
<primary>Korn shell</primary>
<secondary>privileged version</secondary>
</indexterm>
<indexterm xml:id="indexterm-1039">
<primary>C shell</primary>
<secondary>privileged version</secondary>
</indexterm>
<indexterm xml:id="indexterm-1040">
<primary>
<command>sh</command> command</primary>
<secondary>privileged version</secondary>
</indexterm>
<indexterm xml:id="indexterm-1041">
<primary>
<command>csh</command> command</primary>
<secondary>privileged version</secondary>
</indexterm>
<indexterm xml:id="indexterm-1042">
<primary>
<command>ksh</command> command</primary>
<secondary>privileged version</secondary>
</indexterm>
<indexterm xml:id="indexterm-1043">
<primary>
<command>pfsh</command> command</primary>
<secondary>description</secondary>
</indexterm>
<indexterm xml:id="indexterm-1044">
<primary>
<command>pfcsh</command> command</primary>
<secondary>description</secondary>
</indexterm>
<indexterm xml:id="indexterm-1045">
<primary>
<command>pfksh</command> command</primary>
<secondary>description</secondary>
</indexterm>
<indexterm xml:id="indexterm-1046">
<primary>roles</primary>
<secondary>assuming in a terminal window</secondary>
</indexterm>
<para>Roles can run privileged applications from the Solaris Management Console launcher
or from a <emphasis>profile shell</emphasis>. A profile shell is a special shell that
recognizes the security attributes that are included in a rights profile. Profile
shells are launched when the user runs the <command>su</command> command to assume
a role. The profile shells are <command>pfsh</command>, <command>pfcsh</command>,
and <command>pfksh</command>. The shells  correspond to Bourne shell (<command>sh</command>), C shell (<command>csh</command>), and Korn shell (<command>ksh</command>),
respectively.</para>
<para>Users who have been directly assigned a rights profile must invoke a profile
shell to run the commands with security attributes. For usability and security considerations,
see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="rbac-10">Security Considerations When Directly Assigning Security
Attributes</olink>.</para>
<para>All commands that are executed in a profile shell can be audited. For more information,
see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-34">How to Audit Roles</olink>.</para>
</sect2>
<sect2 xml:id="rbac-34">
<title>Name Service Scope and RBAC</title>
<para>
<indexterm xml:id="indexterm-1047">
<primary>name services</primary>
<secondary>scope and RBAC</secondary>
</indexterm>
<indexterm xml:id="indexterm-1048">
<primary>scope (RBAC)</primary>
<secondary>description</secondary>
</indexterm>Name service scope is an important concept for understanding RBAC. The
scope of a role might be limited to an individual host. Alternatively, the scope might
include all hosts that are served by a name service such as NIS, NIS+, or LDAP. The
name service scope for a system is specified in the file <filename>/etc/nsswitch.conf</filename>. A lookup stops at the first match. For example, if a rights profile exists
in two name service scopes, only the entries in the first name service scope are used.
If <literal>files</literal> is the first match, then the scope of the role is limited
to the local host.</para>
</sect2>
<sect2 xml:id="rbac-10">
<title>Security Considerations When Directly Assigning Security
Attributes</title>
<indexterm xml:id="indexterm-1049">
<primary>security attributes</primary>
<secondary>considerations when directly assigning</secondary>
</indexterm>
<para>Typically, a user obtains administrative capabilities through a role. Authorizations
and privileged commands are grouped into a rights profile. The rights profile is included
in a role, and the role is assigned to a user.</para>
<para>Direct assignment of rights profiles and security attributes is also possible:</para>
<itemizedlist>
<listitem>
<para>Rights profiles, privileges, and authorizations can be assigned directly
to users.</para>
</listitem>
<listitem>
<para>Privileges and authorizations can be assigned directly to roles.</para>
</listitem>
</itemizedlist>
<para>However, direct assignment is not a secure practice. Users and roles with a
directly assigned privilege could override security policy wherever this privilege
is required by the kernel. When a privilege is a security attribute of a command in
a  rights profile, that privilege is available only for that command by someone who
has that rights profile. The privilege is not available for other commands that the
user or role might run.</para>
<para>Since authorizations act at the user level, direct assignment of authorizations
can be less dangerous than direct assignment of privileges. However, authorizations
can enable a user to perform highly secure tasks, such as delegate device administration.</para>
<para>A rights profile that is assigned directly to a user presents usability problems
more than security problems. The commands with security attributes in the rights profile
can only succeed in a profile shell. The user must open a profile shell, then type
the commands. A role that is assigned a rights profile gets a profile shell automatically.
Therefore, the commands succeed in the role's shell.</para>
<para>Rights profiles provide an extensible, clean way to group security characteristics
for particular administrative tasks.</para>
</sect2>
</sect1>
<sect1 xml:id="prbac-2">
<title>Privileges (Overview)</title>
<indexterm xml:id="indexterm-1050">
<primary>new features</primary>
<secondary>privileges</secondary>
</indexterm>
<indexterm xml:id="indexterm-1051">
<primary>new features</primary>
<secondary>process rights management</secondary>
</indexterm>
<indexterm xml:id="indexterm-1052">
<primary>superuser</primary>
<secondary>compared to privilege model</secondary>
</indexterm>
<indexterm xml:id="indexterm-1053">
<primary>privileges</primary>
<secondary>compared to superuser model</secondary>
</indexterm>
<indexterm xml:id="indexterm-1054">
<primary>system security</primary>
<secondary>privileges</secondary>
</indexterm>
<para>Process rights management enables processes to be restricted at the command,
user, role, or system level. The Solaris OS implements process rights management through <emphasis>privileges</emphasis>. Privileges decrease the security risk that is associated with
one user or one process having full superuser capabilities on a system. Privileges
and RBAC provide a compelling alternative model to the traditional superuser model.</para>
<itemizedlist>
<listitem>
<para>For information on RBAC, see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="rbac-1">Role-Based
Access Control (Overview)</olink>.</para>
</listitem>
<listitem>
<para>For information on how to administer privileges, see <olink remap="external" targetdoc="chapter-10.xml" targetptr="privtask-1">Chapter 10, Privileges (Tasks)</olink>.</para>
</listitem>
<listitem>
<para>For reference information on privileges, see <olink remap="external" targetdoc="chapter-11.xml" targetptr="privref-1">Chapter 11, Privileges (Reference)</olink>.</para>
</listitem>
</itemizedlist>
<sect2 xml:id="prbac-10">
<title>Privileges Protect Kernel Processes</title>
<para>
<indexterm xml:id="indexterm-1055">
<primary>privileges</primary>
<secondary>protecting kernel processes</secondary>
</indexterm>A privilege is a discrete right that a process requires to
perform an operation. The right is enforced in the kernel. A program that operates
within the bounds of the Solaris <firstterm>basic set</firstterm> of privileges operates
within the bounds of the system security policy. <command>setuid</command> programs
are examples of programs that operate outside the bounds of the system security policy.
By using privileges, programs eliminate the need for calls to <command>setuid</command>.</para>
<para>Privileges discretely enumerate the kinds of operations that are possible on
a system. Programs can be run with the exact privileges that enable the program to
succeed. For example, a program that sets the date and writes the date to an administrative
file might require the <constant>file_dac_write</constant> and <constant>sys_time</constant> privileges. This capability eliminates the need to run any program as <literal>root</literal>.</para>
<para>Historically, systems have not followed the privilege model. Rather, systems
used the superuser model.  In the superuser model, processes run as <literal>root</literal> or as a user. User processes were limited to acting on the user's directories
and files. <literal>root</literal> processes could create directories and files anywhere
on the system. A process that required creation of a directory outside the user's
directory would run with a <literal>UID=0</literal>, that is, as <literal>root</literal>.
Security policy relied on DAC, discretionary access control, to protect system files.
Device nodes were protected by DAC. For example, devices owned by group <literal>sys</literal> could be opened only by members of group <literal>sys</literal>.</para>
<para>However, <command>setuid</command> programs, file permissions, and administrative
accounts are vulnerable to misuse. The actions that a <command>setuid</command> process
is permitted are more numerous than the process requires to complete its operation.
A <command>setuid</command> program can be compromised by an intruder who then runs
as the all-powerful <literal>root</literal> user. Similarly, any user with access
to the <literal>root</literal> password can compromise the entire system.</para>
<para>In contrast, a system that enforces policy with privileges allows a gradation
between user capabilities and <literal>root</literal> capabilities. A user can be
granted privileges to perform activities that are beyond the capabilities of ordinary
users, and <literal>root</literal> can be limited to fewer privileges than <literal>root</literal> currently possesses. With RBAC, a command that runs with privileges
can be isolated in a rights profile and assigned to one user or role. <olink remap="internal" targetdoc="chapter-7.xml" targetptr="rbac-tbl-7">Table 7–1</olink> summarizes the gradation between user capabilities and root
capabilities that the RBAC plus privileges model provides.</para>
<para>The privilege model provides greater security than the superuser model. Privileges
that have been removed from a process cannot be exploited. Process privileges prevent
a program or administrative account from gaining access to all capabilities. Process
privileges can provide an additional safeguard for sensitive files, where DAC protections
alone can be exploited to gain access.</para>
<para>
<indexterm xml:id="indexterm-1056">
<primary>principle of least privilege</primary>
</indexterm>
<indexterm xml:id="indexterm-1057">
<primary>least privilege</primary>
<secondary>principle of</secondary>
</indexterm>Privileges,
then, can restrict programs and processes to just the capabilities that the program
requires. This capability is called the <firstterm>principle of least privilege</firstterm>.
On a system that implements least privilege, an intruder who captures a process has
access to only those privileges that the process has. The rest of the system cannot
be compromised.</para>
</sect2>
<sect2 xml:id="prbac-14">
<title>Privilege Descriptions</title>
<para>
<indexterm xml:id="indexterm-1058">
<primary>privileges</primary>
<secondary>categories</secondary>
</indexterm>
<indexterm xml:id="indexterm-1059">
<primary>privileges</primary>
<secondary>description</secondary>
</indexterm>Privileges
are logically grouped on the basis of the area of the privilege.</para>
<itemizedlist>
<listitem>
<para>
<indexterm xml:id="indexterm-1060">
<primary>files</primary>
<secondary>privileges relating to</secondary>
</indexterm>
<indexterm xml:id="indexterm-1061">
<primary>
<literal>FILE</literal> privileges</primary>
</indexterm>
<literal>FILE</literal> <emphasis role="strong">privileges –</emphasis> Privileges
that begin with the string <literal>file</literal> operate on file system objects.
For example, the <constant>file_dac_write</constant> privilege overrides discretionary
access control when writing to files.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1062">
<primary>System V IPC</primary>
<secondary>privileges</secondary>
</indexterm>
<indexterm xml:id="indexterm-1063">
<primary>
<literal>IPC</literal> privileges</primary>
</indexterm>
<literal>IPC</literal> <emphasis role="strong">privileges –</emphasis> Privileges that
begin with the string <literal>ipc</literal> override IPC object access controls.
For example, the <constant>ipc_dac_read</constant> privilege enables a process to
read remote shared memory that is protected by DAC.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1064">
<primary>network</primary>
<secondary>privileges relating to</secondary>
</indexterm>
<indexterm xml:id="indexterm-1065">
<primary>
<literal>NET</literal> privileges</primary>
</indexterm>
<literal>NET</literal> <emphasis role="strong">privileges –</emphasis> Privileges
that begin with the string <literal>net</literal> give access to specific network
functionality. For example, the <constant>net_rawaccess</constant> privilege enables
a device to connect to the network.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1066">
<primary>process privileges</primary>
</indexterm>
<indexterm xml:id="indexterm-1067">
<primary>
<literal>PROC</literal> privileges</primary>
</indexterm>
<literal>PROC</literal> <emphasis role="strong">privileges –</emphasis> Privileges that begin with the string <literal>proc</literal> allow processes to modify restricted properties of the process itself. <literal>PROC</literal> privileges include privileges that have a very limited effect. For
example, the <constant>proc_clock_highres</constant> privilege enables a process to
use high resolution timers.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1068">
<primary>system properties</primary>
<secondary>privileges relating to</secondary>
</indexterm>
<indexterm xml:id="indexterm-1069">
<primary>
<literal>SYS</literal> privileges</primary>
</indexterm>
<literal>SYS</literal> <emphasis role="strong">privileges –</emphasis> Privileges that begin with the string <literal>sys</literal> give processes
unrestricted access to various system properties. For example, the <constant>sys_linkdir</constant> privilege enables a process to make and break hard links to directories.</para>
</listitem>
</itemizedlist>
<para>Some privileges have a limited effect on the system, and some have a broad effect.
The definition of the <constant>proc_taskid</constant> privilege indicates its limited
effect:</para>
<screen>proc_taskid
        Allows a process to assign a new task ID to the calling process.</screen>
<para>The definition of the <constant>file_setid</constant> privilege indicates its
broad effect:</para>
<screen>net_rawaccess
        Allow a process to have direct access to  the  network layer.</screen>
<para>
<indexterm xml:id="indexterm-1070">
<primary>
<filename>privileges</filename> file</primary>
<secondary>description</secondary>
</indexterm>The <olink remap="external" targetdoc="819-2252" targetptr="privileges-5">
<citerefentry>
<refentrytitle>privileges</refentrytitle>
<manvolnum>
5
</manvolnum>
</citerefentry>
</olink> man
page provides descriptions of every privilege. The command <command>ppriv -lv</command> prints
a description of every privilege to standard out.</para>
</sect2>
<sect2 xml:id="prbac-16">
<title>Administrative Differences on a System With Privileges</title>
<para>
<indexterm xml:id="indexterm-1071">
<primary>superuser</primary>
<secondary>differences from privilege model</secondary>
</indexterm>
<indexterm xml:id="indexterm-1072">
<primary>privileges</primary>
<secondary>differences from superuser model</secondary>
</indexterm>
<indexterm xml:id="indexterm-1073">
<primary>administering</primary>
<secondary>without privileges</secondary>
</indexterm>A system that has privileges
has several visible differences from a system that does not have privileges. The following
table lists some of the differences.</para>
<table frame="topbot" xml:id="prbac-tbl-1" pgwide="1">

<title>Visible Differences Between
a System With Privileges and a System Without Privileges</title>
<tgroup cols="3" colsep="0" rowsep="0">
<colspec colname="colspec0" colwidth="13.80*"/>
<colspec colname="colspec1" colwidth="33.39*"/>
<colspec colname="colspec2" colwidth="51.81*"/>
<thead>
<row rowsep="1">
<entry>
<para>Feature</para>
</entry>
<entry>
<para>No Privileges</para>
</entry>
<entry>
<para>Privileges</para>
</entry>
</row>
</thead>
<tbody>
<row>
<entry>
<para>Daemons</para>
</entry>
<entry>
<para>Daemons run as <literal>root</literal>.</para>
</entry>
<entry>
<para>
<indexterm xml:id="indexterm-1074">
<primary>daemons</primary>
<secondary>running with privileges</secondary>
</indexterm>Daemons run as the user <literal>daemon</literal>.</para>
<para>For example, the following daemons have been assigned appropriate privileges
and run as <literal>daemon</literal>: <command>lockd</command>, <command>mountd</command>, <command>nfsd</command>, and <command>rpcbind</command>.</para>
</entry>
</row>
<row>
<entry>
<para>Log File Ownership</para>
</entry>
<entry>
<para>Log files are owned by <literal>root</literal>.</para>
</entry>
<entry>
<para>Log files are now owned by <literal>daemon</literal>, who created the log file.
The <literal>root</literal> user does not own the file.</para>
</entry>
</row>
<row>
<entry>
<para>Error Messages</para>
</entry>
<entry>
<para>Error messages refer to superuser.</para>
<para>For example, <computeroutput>chroot: not superuser</computeroutput>.</para>
</entry>
<entry>
<para>Error messages reflect the use of privileges.</para>
<para>For example, the equivalent error message for <command>chroot</command> failure
is <computeroutput>chroot: exec failed</computeroutput>.</para>
</entry>
</row>
<row>
<entry>
<para>
<command>setuid</command> Programs</para>
</entry>
<entry>
<para>Programs use <command>setuid</command> to complete tasks that ordinary users
are not allowed to perform.</para>
</entry>
<entry>
<para>Many <command>setuid</command> programs have been changed to run with privileges.</para>
<para>For example, the following utilities use privileges: <command>ufsdump</command>, <command>ufsrestore</command>, <command>rsh</command>, <command>rlogin</command>, <command>rcp</command>, <command>rdist</command>, <command>ping</command>, <command>traceroute</command>, and <command>newtask</command>.</para>
</entry>
</row>
<row>
<entry>
<para>File Permissions</para>
</entry>
<entry>
<para>Device permissions are controlled by DAC. For example, members of the group <literal>sys</literal> can open <filename>/dev/ip</filename>.</para>
</entry>
<entry>
<para>File permissions (DAC) do not predict who can open a device. Devices are protected
with DAC <emphasis>and</emphasis> device policy.</para>
<para>For example, the <filename>/dev/ip</filename> file has <literal>666</literal> permissions,
but the device can only be opened by a process with the appropriate privileges. Raw
sockets are still protected by DAC.</para>
</entry>
</row>
<row>
<entry>
<para>Audit Events</para>
</entry>
<entry>
<para>Auditing the use of the <command>su</command> command covers many administrative
functions.</para>
</entry>
<entry>
<para>Auditing the use of privileges covers most administrative functions. The <literal>pm</literal> and <literal>as</literal> audit classes include audit events that configure
device policy and audit events that set privileges.</para>
</entry>
</row>
<row>
<entry>
<para>Processes</para>
</entry>
<entry>
<para>Processes are protected by who owns the process.</para>
</entry>
<entry>
<para>Processes are protected by privileges. Process privileges and process flags
are visible as a new entry in the <filename>/proc/&lt;pid&gt;
</filename> directory, <filename>priv</filename>.</para>
</entry>
</row>
<row>
<entry>
<para>Debugging</para>
</entry>
<entry>
<para>No reference to privileges in core dumps.</para>
</entry>
<entry>
<para>The ELF note section of core dumps includes information about process privileges
and flags in the <literal>NT_PRPRIV</literal> and <literal>NT_PRPRIVINFO</literal> notes.</para>
<para>The <command>ppriv</command> utility and other utilities show the proper number
of properly sized sets. The utilities correctly map the bits in the bit sets to privilege
names.</para>
</entry>
</row>
</tbody>
</tgroup>
</table>
</sect2>
<sect2 xml:id="prbac-17">
<title>How Privileges Are Implemented</title>
<para>
<indexterm xml:id="indexterm-1075">
<primary>privileges</primary>
<secondary>implemented in sets</secondary>
</indexterm>Every process has four sets of privileges that determine whether a process
can use a particular privilege. The kernel automatically calculates the <firstterm>effective set</firstterm> of privileges. You can modify the initial <firstterm>inheritable
set</firstterm> of privileges. A program that is coded to use privileges can reduce
the program's <firstterm>permitted set</firstterm> of privileges. You can shrink the <firstterm>limit set</firstterm> of privileges.</para>
<itemizedlist>
<listitem>
<para>
<indexterm xml:id="indexterm-1076">
<primary>effective privilege set</primary>
</indexterm>
<indexterm xml:id="indexterm-1077">
<primary>privilege sets</primary>
<secondary>effective</secondary>
</indexterm>
<emphasis role="strong">Effective  privilege set, or E –</emphasis> Is the set of privileges
that is currently in effect. A process can add privileges that are in the permitted
set to the effective set. A process can also remove privileges from E.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1078">
<primary>permitted privilege set</primary>
</indexterm>
<indexterm xml:id="indexterm-1079">
<primary>privilege sets</primary>
<secondary>permitted</secondary>
</indexterm>
<emphasis role="strong">Permitted  privilege set, or P –</emphasis> Is the set of privileges
that is available for use. Privileges can be available to a program from inheritance
or through assignment. An execution profile is one way to assign privileges to a program.
The <command>setuid</command> command assigns all privileges that <literal>root</literal> has
to a program. Privileges can be removed from the permitted set, but privileges cannot
be added to the set. Privileges that are removed from P are automatically removed
from E.</para>
<para>
<indexterm xml:id="indexterm-1080">
<primary>programs</primary>
<secondary>privilege-aware</secondary>
</indexterm>A <firstterm>privilege-aware</firstterm> program removes the
privileges that a program never uses from the program's permitted set. In this way,
unnecessary privileges cannot be exploited by the program or a malicious process.
For more information on privilege-aware programs, see <olink remap="external" targetdoc="819-2145" targetptr="ch3priv-18281">Chapter 2, <citetitle remap="chapter">Developing Privileged Applications,</citetitle> in <citetitle remap="book">Solaris Security for Developers Guide</citetitle>
</olink>.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1081">
<primary>inheritable privilege set</primary>
</indexterm>
<indexterm xml:id="indexterm-1082">
<primary>privilege sets</primary>
<secondary>inheritable</secondary>
</indexterm>
<emphasis role="strong">Inheritable  privilege set, or I –</emphasis> Is the set of privileges
that a process can inherit across a call to <command>exec</command>. After the call
to <command>exec</command>, the permitted and the effective sets are equal, except
in the special case of a <command>setuid</command> program.</para>
<para>For a <command>setuid</command> program, after the call to <command>exec</command>, the inheritable
set is first restricted by the limit set. Then, the set of privileges that were inherited
(I), minus any privileges that were in the limit set (L), are assigned to P and E
for that process.</para>
</listitem>
<listitem>
<para>
<indexterm xml:id="indexterm-1083">
<primary>limit privilege set</primary>
</indexterm>
<indexterm xml:id="indexterm-1084">
<primary>privilege sets</primary>
<secondary>limit</secondary>
</indexterm>
<emphasis role="strong">Limit  privilege set, or L –</emphasis> Is the outside limit of
what privileges are available to a process and its children. By default, the limit
set is all privileges. Processes can shrink the limit set but can never extend the
limit set. L is used to restrict I. Consequently, L restricts P and E at the time
of <command>exec</command>.</para>
<para>If a user has been assigned a profile that
includes a program that has been assigned privileges, the user can usually run that
program. On an unmodified system, the program's assigned privileges are within the
user's limit set. The privileges that have been assigned to the program become part
of the user's permitted set. To run the program that has been assigned privileges,
the user must run the program from a profile shell.</para>
</listitem>
</itemizedlist>
<para>
<indexterm xml:id="indexterm-1085">
<primary>basic privilege set</primary>
</indexterm>
<indexterm xml:id="indexterm-1086">
<primary>privilege sets</primary>
<secondary>basic</secondary>
</indexterm>
<indexterm xml:id="indexterm-1087">
<primary>users</primary>
<secondary>initial inheritable privileges</secondary>
</indexterm>The
kernel recognizes a <emphasis>basic privilege set</emphasis>. On an unmodified system,
each user's initial inheritable set equals the basic set at login. You can modify
the user's initial inheritable set. You cannot modify the basic set.</para>
<para>
<indexterm xml:id="indexterm-1088">
<primary>users</primary>
<secondary>basic privilege set</secondary>
</indexterm>
<indexterm xml:id="indexterm-1089">
<primary>logging in</primary>
<secondary>users' basic privilege set</secondary>
</indexterm>
<indexterm xml:id="indexterm-1090">
<primary>privilege sets</primary>
<secondary>listing</secondary>
</indexterm>On an unmodified system, a user's privilege sets at
login would appear similar to the following:</para>
<screen>E (Effective): basic
I (Inheritable): basic
P (Permitted): basic
L (Limit): all</screen>
<para>Therefore, at login, all users have the basic set in their inheritable set,
their permitted set, and their effective set. A user's limit set contains all privileges.
To put more privileges in the user's effective set, you must assign a rights profile
to the user. The rights profile would include commands to which you have added privileges.
You can also assign privileges directly to the user or role, though such privilege
assignment can be risky. For a discussion of the risks, see <olink remap="internal" targetdoc="chapter-7.xml" targetptr="rbac-10">Security Considerations When Directly Assigning Security
Attributes</olink>.</para>
</sect2>
<sect2 xml:id="prbac-19">
<title>How Processes Get Privileges</title>
<para>
<indexterm xml:id="indexterm-1091">
<primary>privileges</primary>
<secondary>inherited by processes</secondary>
</indexterm>
<indexterm xml:id="indexterm-1092">
<primary>obtaining</primary>
<secondary>privileges</secondary>
</indexterm>Processes can inherit privileges. Or, processes can be assigned privileges.
A process inherits privileges from its parent process. At login, the user's initial
inheritable set of privileges determines what privileges are available to the user's
processes. All child processes of the user's initial login inherit that set.</para>
<para>
<indexterm xml:id="indexterm-1093">
<primary>privileges</primary>
<secondary>processes with assigned privileges</secondary>
</indexterm>You can also directly assign privileges to programs, users,
and roles. When a program requires privileges, you assign the privileges to the program's
executable in a rights profile. Users or roles that are permitted to run the program
are assigned the profile that includes the program. At login or when a profile shell
is entered, the program runs with privilege when the program's executable is typed
in the profile shell. For example, a role that includes the Object Access Management
profile is able to run the <command>chmod</command> command with the <constant>file_chown</constant> privilege.</para>
<para>When a role or user runs a program that has been directly assigned an additional
privilege, the assigned privilege is added to the role or user's inheritable set.
Child processes of the program that was assigned privileges inherit the privileges
of the parent. If the child process requires more privileges than the parent process,
the child process must be directly assigned those privileges.</para>
<para>
<indexterm xml:id="indexterm-1094">
<primary>privileges</primary>
<secondary>programs aware of privileges</secondary>
</indexterm>
<indexterm xml:id="indexterm-1095">
<primary>programs</primary>
<secondary>privilege-aware</secondary>
</indexterm>Programs that are coded to use privileges are called privilege-aware
programs. A privilege-aware program turns on the use of privilege and turns off the
use of privilege during program execution. To succeed in a production environment,
the program must be assigned the privileges that the program turns on and off.</para>
<para>For examples of privilege-aware code, see <olink remap="external" targetdoc="819-2145" targetptr="ch3priv-18281">Chapter 2, <citetitle remap="chapter">Developing Privileged Applications,</citetitle> in <citetitle remap="book">Solaris Security for Developers Guide</citetitle>
</olink>. To assign
privileges to a program that requires privileges, see <olink remap="external" targetdoc="chapter-10.xml" targetptr="privtask-7">How to Add Privileges to a Command</olink>.</para>
</sect2>
<sect2 xml:id="prbac-21">
<title>Assigning Privileges</title>
<para>
<indexterm xml:id="indexterm-1096">
<primary>privileges</primary>
<secondary>assigning to a command</secondary>
</indexterm>
<indexterm xml:id="indexterm-1097">
<primary>commands</primary>
<secondary>that assign privileges</secondary>
</indexterm>
<indexterm xml:id="indexterm-1098">
<primary>obtaining</primary>
<secondary>privileges</secondary>
</indexterm>You, in your capacity as system administrator, are responsible
for assigning privileges. Typically, you assign the privilege to a command in a rights
profile. The rights profile is then assigned to a role or to a user. The Solaris Management
Console provides the graphical user interface (GUI) to assign privileges. Privileges
can also be assigned by using commands such as <command>smuser</command> and <command>smrole</command>. For more information on how to use the GUI to assign privileges,
see <olink remap="external" targetdoc="chapter-8.xml" targetptr="rbactask-1">Chapter 8, Using Role-Based Access Control (Tasks)</olink>.</para>
<para>
<indexterm xml:id="indexterm-1099">
<primary>privileges</primary>
<secondary>assigning to a user</secondary>
</indexterm>Privileges can also be assigned directly to a user. If you trust a subset
of users to use a privilege responsibly throughout their sessions, you can assign
the privilege directly. Good candidates for direct assignment are privileges that
have a limited effect, such as <constant>proc_clock_highres</constant>. Poor candidates
for direct assignment are privileges that have far-reaching effects, such as <constant>file_dac_write</constant>.</para>
<para>Privileges can also be denied to a user or to a system. Care must be taken when
removing privileges from the initial inheritable set or the limit set of a user or
a system.</para>
<sect3 xml:id="prbac-11">
<title>Expanding a User or Role's Privileges</title>
<para>Users and roles have an inheritable set of privileges, and a limit set of privileges.
The limit set cannot be expanded, since the limit set is initially all privileges.
The initial inheritable set can be expanded for users, roles, and systems. A privilege
that is not in the inheritable set can also be assigned to a process.</para>
<para>The assignment of privileges per process is the most precise way to add privileges.
You can expand the number of privileged operations that a user can perform by enabling
the user to assume a role. The role would be assigned profiles that include commands
with added privileges. When the user assumes the role, the user gets the role's profile
shell. By typing in the role's shell, the commands in the role's profiles execute
with the added privileges.</para>
<para>
<indexterm xml:id="indexterm-1100">
<primary>privileges</primary>
<secondary>executing commands with privilege</secondary>
</indexterm>You can also assign a profile to the user rather than to a
role that the user assumes. The profile would include commands with added privileges.
When the user opens a profile shell, such as <command>pfksh</command>, the user can
execute the commands in the user's profile with privilege. In a regular shell, the
commands do not execute with privilege. The privileged process can only execute in
a privileged shell.</para>
<para>
<indexterm xml:id="indexterm-1101">
<primary>privilege sets</primary>
<secondary>adding privileges to</secondary>
</indexterm>To expand the initial inheritable set of privileges for users,
roles, or systems is a riskier way to assign privileges. All privileges in the inheritable
set are in the permitted and effective sets. All commands that the user or role types
in a shell can use the directly assigned privileges. Directly assigned privileges
enable a user or role to easily perform operations that can be outside the bounds
of their administrative responsiblities.</para>
<para>When you add to the initial inheritable set of privileges on a system, all users
who log on to the system have a larger set of basic privileges. Such direct assignment
enables all users of the system to easily perform operations that are probably outside
the bounds of ordinary users.</para>
</sect3>
<sect3 xml:id="prbac-15">
<title>Restricting a User or Role's Privileges</title>
<para>
<indexterm xml:id="indexterm-1102">
<primary>privileges</primary>
<secondary>removing from a user</secondary>
</indexterm>
<indexterm xml:id="indexterm-1103">
<primary>privilege sets</primary>
<secondary>removing privileges from</secondary>
</indexterm>By removing privileges, you can prevent users and roles
from performing particular tasks. You can remove privileges from the initial inheritable
set, and from the limit set. You should carefully test removal of privileges before
you distribute an initial inheritable set or a limit set that is smaller than the
default  set. By removing privileges from the initial inheritable set, you might prevent
users from logging in. When privileges are removed from the limit set, a legacy <command>setuid</command> program might fail because the program requires a privilege that
was removed.</para>
</sect3>
<sect3 xml:id="prbac-12">
<title>Assigning Privileges to a Script</title>
<para>
<indexterm xml:id="indexterm-1104">
<primary>privileges</primary>
<secondary>assigning to a script</secondary>
</indexterm>
<indexterm xml:id="indexterm-1105">
<primary>scripts</primary>
<secondary>running with privileges</secondary>
</indexterm>Scripts are executables, like commands. Therefore, in a rights
profile, you can add privileges to a script just as you can add privileges to a command.
The script runs with the added privileges when a user or role who has been assigned
the profile executes the script in a profile shell. If the script contains commands
that require privileges, the commands with added privileges should also be in the
profile.</para>
<para>Privilege-aware programs can restrict privileges per process. Your job with
a privilege-aware program is to assign the executable just the privileges that the
program needs. You then test the program to see that the program succeeds in performing
its tasks. You also check that the program does not abuse its use of privileges.</para>
</sect3>
</sect2>
<sect2 xml:id="prbac-23">
<title>Privileges and Devices</title>
<indexterm xml:id="indexterm-1106">
<primary>devices</primary>
<secondary>privilege model and</secondary>
</indexterm>
<indexterm xml:id="indexterm-1107">
<primary>devices</primary>
<secondary>superuser model and</secondary>
</indexterm>
<indexterm xml:id="indexterm-1108">
<primary>privileges</primary>
<secondary>devices and</secondary>
</indexterm>
<para>The privilege model uses privileges to protect system interfaces that are protected
by file permissions alone in the superuser model. In a system with privileges, file
permissions are too weak to protect the interfaces. A privilege such as <constant>proc_owner</constant> could override file permissions and then give full access to
all of the system.</para>
<para>Therefore, ownership of the device directory is not sufficient to open a device.
For example, members of the group <literal>sys</literal> are no longer automatically
allowed to open the <filename>/dev/ip</filename> device. The file permissions on <filename>/dev/ip</filename> are <literal>0666</literal>, but the <constant>net_rawaccess</constant> privilege
is required to open the device.</para>
<para>Device policy is controlled by privileges. The <command>getdevpolicy</command> command
displays the device policy for every device. The device configuration command, <command>devfsadm</command>, installs the device policy. The <command>devfsadm</command> command
binds privilege sets with <command>open</command> for reading or writing of devices.
For more information, see the <olink remap="external" targetdoc="819-2240" targetptr="getdevpolicy-1m">
<citerefentry>
<refentrytitle>getdevpolicy</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> and <olink remap="external" targetdoc="819-2240" targetptr="devfsadm-1m">
<citerefentry>
<refentrytitle>devfsadm</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man pages.</para>
<para>Device policy allows you more flexibility in granting permission to open devices.You
can require different privileges or more privileges than the default device policy.
The privilege requirements can be modified for the device policy and for the driver
proper. You can modify the privileges when installing, adding, or updating a device
driver.</para>
<para>The <command>add_drv</command> and <command>update_drv</command> commands can
modify device policy entries and driver-specific privileges. You must be running a
process with the full set of privileges to change the device policy. For more information,
see the <olink remap="external" targetdoc="819-2240" targetptr="add-drv-1m">
<citerefentry>
<refentrytitle>add_drv</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> and <olink remap="external" targetdoc="819-2240" targetptr="update-drv-1m">
<citerefentry>
<refentrytitle>update_drv</refentrytitle>
<manvolnum>
1M
</manvolnum>
</citerefentry>
</olink> man pages.</para>
</sect2>
<sect2 xml:id="privtask-12">
<title>Privileges and Debugging</title>
<indexterm xml:id="indexterm-1109">
<primary>privileges</primary>
<secondary>debugging</secondary>
</indexterm>
<para>The Solaris OS provides tools to debug privilege failure. The <command>ppriv</command> command
and the <command>truss</command> command provide debugging output. For examples, see
the <olink remap="external" targetdoc="819-2239" targetptr="ppriv-1">
<citerefentry>
<refentrytitle>ppriv</refentrytitle>
<manvolnum>
1
</manvolnum>
</citerefentry>
</olink> man page. For a procedure,
see <olink remap="external" targetdoc="chapter-10.xml" targetptr="privtask-6">How to Determine Which Privileges a Program Requires</olink>.</para>
</sect2>
</sect1>
</chapter>
