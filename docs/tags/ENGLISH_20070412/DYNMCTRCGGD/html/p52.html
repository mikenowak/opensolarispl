<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- GenHTML@17046-->
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<title><tt>mib</tt> Provider - Solaris Dynamic Tracing Guide</title>
<meta name="robots" content="index,follow">
<meta name="robots" content="index,follow">
<meta name="date" content="2005-09-01">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/ipg.css">
</head>

<body leftmargin="0" topmargin="0" marginheight="0" marginwidth="0" bgcolor="#ffffff"  class="a0v0">
<!--stopindex-->

<a name="top"></a>

<!-- BEGIN A1 COMPONENT V.0 -->
<div class="a1">
<div class="a1v0">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com">sun.com</a>
<a href="http://docs.sun.com/" class="dividelink">docs.sun.com</a>
</span>
</td><td align="right" nowrap="nowrap">
<span class="toolbarlinks">
<a href="http://www.sun.com/MySun/">My Sun</a>
<a href="http://www.sun.com/worldwide/" class="dividelink">Worldwide Sites</a>
</span>
</td></tr>
</table>
</div>
</div>
<!-- END A1 COMPONENT V.0 -->

<!-- BEGIN A2 COMPONENT V.0 -->
<div class="a2" id="a2v0">
<div class="cornerTL">
<div class="cornerTR">
<div class="cornerBL">
<div class="cornerBR">
<div class="a2topiclinks">
<table cellpadding="1" cellspacing="0" border="0">
<tr valign="bottom">
<td><a href="http://www.sun.com/" title="Home Page"><img src="css/a.gif" alt="Home Page" width="104" height="58" border="0" class="sunlogo"></a></td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip1"></td>
<td class="navlinks" id="navlink1">
<div>
<a id="glink1" href="http://www.sun.com/products/">Products</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip2"></td>
<td class="navlinks" id="navlink2">
<div>
<a id="glink2" href="http://www.sun.com/downloads/">Downloads</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip3"></td><td class="navlinks" id="navlink3">
<div>
<a id="glink3" href="http://www.sun.com/service/">Service &amp; Solutions</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip4"></td><td class="navlinks" id="navlink4">
<div>
<a id="glink4" href="http://www.sun.com/support/">Support</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip5"></td><td class="navlinks" id="navlink5">
<div>
<a id="glink5" href="http://www.sun.com/training/">Training</a>
</div>
</td><td><img src="css/a.gif" alt="" width="1" height="1" border="0" id="ip6"></td><td class="navlinks" id="navlink6">
<div>
<a id="glink6" href="http://research.sun.com/">Research</a>
</div>
</td>
</tr>
</table>
</div>

</div></div></div></div>
</div>
<!-- END A2 COMPONENT V.0 -->

<!-- BEGIN BREADCRUMB -->
<div id="breadcrumb">
<?GenHTML ReferencePage >Solaris Dynamic Tracing Guide<?GenHTML /ReferencePage>
</div><br />
<!-- END BREADCRUMB -->

<!-- BEGIN WRAPPER TABLE, 1 COLUMN, MAIN -->
<table border="0" cellpadding="0" cellspacing="10" width="100%">
<tr valign="bottom"><td width="100%" valign="top">
<!-- BEGIN CENTRAL COLUMN COMPONENTS -->

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr><td colspan="5"></td></tr>
<tr>
<td></td>
<td style="width: 60%">&nbsp;</td>
<td><a href="p51.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p53.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->

</td></tr>
<tr><td width="100%" valign="top">
<a name="skip2content"> </a>

<!--startindex-->
<div class="maincontent">
<a name="chp-mib"></a>Chapter&nbsp;28<h3><tt>mib</tt> Provider</h3><p>The <tt>mib</tt> provider makes available probes that correspond to counters in the Solaris management information bases (MIBs). MIB counters are used by the simple network management protocol (SNMP) that allow remote monitoring of heterogeneous networking entities. You can also view the counters with the <tt>kstat</tt>(1M) and <tt>netstat</tt>(1M) commands. The <tt>mib</tt> provider facilitates quick exploration of aberrant networking behavior that is observed using either remote or local networking monitors.</p>
<a name="chp-mib-probes"></a><h3>Probes</h3>
<p><a name="indexterm-415"></a><a name="indexterm-416"></a>The <tt>mib</tt> provider makes available probes for counters from several MIBs. The protocols that export MIBs instrumented by the <tt>mib</tt> provider are listed in <a href="p52.html#tbl-mib-mibs">Table 28-1</a>. The table includes a reference to documentation that specifies some or all of the MIB, the name of the kernel statistic that may be used to access the running counts (using the <tt>kstat</tt>(1M) <tt>-n</tt> <i>statistic</i><tt></tt> option), and a reference to the table that has a complete definition of the probes. All MIB counters are also available through the <tt>-s</tt> option to <tt>netstat</tt>(1M).</p>
<a name="tbl-mib-mibs"></a>Table 28-1 <tt>mib</tt> probes<table><tr><th><p>Protocol</p>
</th><th><p>MIB Description</p>
</th><th><p>Kernel Statistic</p>
</th><th><p><tt>mib</tt> Probes Table</p>
</th></tr>
<tr><td><p>ICMP</p>
</td><td><p>RFC 1213</p>
</td><td><p><tt>icmp</tt></p>
</td><td><p><a href="p52.html#tbl-mib-icmp">Table 28-2</a></p>
</td></tr>
<tr><td><p>IP</p>
</td><td><p>RFC 1213</p>
</td><td><p><tt>ip</tt></p>
</td><td><p><a href="p52.html#tbl-mib-ip">Table 28-3</a></p>
</td></tr>
<tr><td><p>IPsec</p>
</td><td><p>&mdash;</p>
</td><td><p><tt>ip</tt></p>
</td><td><p><a href="p52.html#tbl-mib-ipsec">Table 28-4</a></p>
</td></tr>
<tr><td><p>IPv6</p>
</td><td><p>RFC 2465</p>
</td><td><p>&mdash;</p>
</td><td><p><a href="p52.html#tbl-mib-ipv6">Table 28-5</a></p>
</td></tr>
<tr><td><p>SCTP</p>
</td><td><p>&ldquo;SCTP MIB&rdquo; (Internet draft)</p>
</td><td><p><tt>sctp</tt></p>
</td><td><p><a href="p52.html#tbl-mib-sctp">Table 28-7</a></p>
</td></tr>
<tr><td><p>TCP</p>
</td><td><p>RFC 1213</p>
</td><td><p><tt>tcp</tt></p>
</td><td><p><a href="p52.html#tbl-mib-tcp">Table 28-8</a></p>
</td></tr>
<tr><td><p>UDP</p>
</td><td><p>RFC 1213</p>
</td><td><p><tt>udp</tt></p>
</td><td><p><a href="p52.html#tbl-mib-udp">Table 28-9</a></p>
</td></tr>
</table><a name="tbl-mib-icmp"></a>Table 28-2 ICMP <tt>mib</tt> Probes<table><tr><td><p><tt>icmpInAddrMaskReps</tt></p>
</td><td><p>Probe that fires whenever an ICMP Address Mask Reply message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInAddrMasks</tt></p>
</td><td><p>Probe that fires whenever an ICMP Address Mask Request message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInBadRedirects</tt></p>
</td><td><p>Probe that fires whenever an ICMP Redirect message is received that is determined to be malformed in some way (unknown ICMP code, sender or target off-link, and the like).</p>
</td></tr>
<tr><td><p><tt>icmpInCksumErrs</tt></p>
</td><td><p>Probe that fires whenever an ICMP message with a bad checksum is received.</p>
</td></tr>
<tr><td><p><tt>icmpInDestUnreachs</tt></p>
</td><td><p>Probe that fires whenever an ICMP Destination Unreachable message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInEchoReps</tt></p>
</td><td><p>Probe that fires whenever an ICMP Echo Reply message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInEchos</tt></p>
</td><td><p>Probe that fires whenever an ICMP Echo request message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInErrors</tt></p>
</td><td><p>Probe that fires whenever an ICMP message is received that is determined to have an ICMP-specific error (bad ICMP checksum, bad length, etc.).</p>
</td></tr>
<tr><td><p><tt>icmpInFragNeeded</tt></p>
</td><td><p>Probe that fires whenever an ICMP Destination Unreachable (Fragmentation Needed) message is received, indicating that a sent packet was lost because it was larger than some MTU and the Don't Fragment flag was set.</p>
</td></tr>
<tr><td><p><tt>icmpInMsgs</tt></p>
</td><td><p>Probe that fires whenever an ICMP message is received. Whenever this probe fires, the <tt>icmpInErrors</tt> probe may also fire if the message is determined to have an ICMP-specific error.</p>
</td></tr>
<tr><td><p><tt>icmpInOverflows</tt></p>
</td><td><p>Probe that fires whenever an ICMP message is received, but the message is subsequently dropped due to lack of buffer space.</p>
</td></tr>
<tr><td><p><tt>icmpInParmProbs</tt></p>
</td><td><p>Probe that fires whenever an ICMP Parameter Problem message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInRedirects</tt></p>
</td><td><p>Probe that fires whenever an ICMP Redirect message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInSrcQuenchs</tt></p>
</td><td><p>Probe that fires whenever an ICMP Source Quench message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInTimeExcds</tt></p>
</td><td><p>Probe that fires whenever an ICMP Time Exceeded message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInTimestampReps</tt></p>
</td><td><p>Probe that fires whenever an ICMP Timestamp Reply message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInTimestamps</tt></p>
</td><td><p>Probe that fires whenever an ICMP Timestamp request message is received.</p>
</td></tr>
<tr><td><p><tt>icmpInUnknowns</tt></p>
</td><td><p>Probe that fires whenever an ICMP message of unknown type is received.</p>
</td></tr>
<tr><td><p><tt>icmpOutAddrMaskReps</tt></p>
</td><td><p>Probe that fires whenever an ICMP Address Mask Reply message is sent.</p>
</td></tr>
<tr><td><p><tt>icmpOutDestUnreachs</tt></p>
</td><td><p>Probe that fires whenever an ICMP Destination Unreachable message is sent.</p>
</td></tr>
<tr><td><p><tt>icmpOutDrops</tt></p>
</td><td><p>Probe that fires whenever an outbound ICMP message is dropped for some reason (such as memory allocation failure, broadcast/multicast source or destination, and the like).</p>
</td></tr>
<tr><td><p><tt>icmpOutEchoReps</tt></p>
</td><td><p>Probe that fires whenever an ICMP Echo Reply message is sent.</p>
</td></tr>
<tr><td><p><tt>icmpOutErrors</tt></p>
</td><td><p>Probe that fires whenever an ICMP message is not sent due to problems discovered within ICMP, such as a lack of buffers. This probe will not fire if errors are discovered outside the ICMP layer, such as the inability of IP to route the resulting datagram.</p>
</td></tr>
<tr><td><p><tt>icmpOutFragNeeded</tt></p>
</td><td><p>Probe that fires whenever an ICMP Destination Unreachable (Fragmentation Needed) message is sent.</p>
</td></tr>
<tr><td><p><tt>icmpOutMsgs</tt></p>
</td><td><p>Probe that fires whenever an ICMP message is sent. Whenever this probe fires, the <tt>icmpOutErrors</tt> probe might also fire if the message is determined to have ICMP-specific errors.</p>
</td></tr>
<tr><td><p><tt>icmpOutParmProbs</tt></p>
</td><td><p>Probe that fires whenever an ICMP Parameter Problem message is sent.</p>
</td></tr>
<tr><td><p><tt>icmpOutRedirects</tt></p>
</td><td><p>Probe that fires whenever an ICMP Redirect message is sent. For a host, this probe will never fire, because hosts do not send redirects.</p>
</td></tr>
<tr><td><p><tt>icmpOutTimeExcds</tt></p>
</td><td><p>Probe that fires whenever an ICMP Time Exceeded message is sent.</p>
</td></tr>
<tr><td><p><tt>icmpOutTimestampReps</tt></p>
</td><td><p>Probe that fires whenever an ICMP Timestamp Reply message is sent.</p>
</td></tr>
</table><a name="tbl-mib-ip"></a>Table 28-3 IP <tt>mib</tt> Probes<table><tr><td><p><tt>ipForwDatagrams</tt></p>
</td><td><p>Probe that fires whenever a datagram is received that does not have this machine as its final IP destination, and an attempt is made to find a route to forward the datagram to that final destination. On machines that do not act as IP gateways, this probe will only fire for those packets that are source-routed through this machine, and for which the source-route option processing was successful.</p>
</td></tr>
<tr><td><p><tt>ipForwProhibits</tt></p>
</td><td><p>Probe that fires whenever a datagram is received that does not have this machine as its final IP destination, but because the machine is not permitted to act as a router, no attempt is made to find a route to forward the datagram to that final destination.</p>
</td></tr>
<tr><td><p><tt>ipFragCreates</tt></p>
</td><td><p>Probe that fires whenever an IP datagram fragment is generated as a result of fragmentation.</p>
</td></tr>
<tr><td><p><tt>ipFragFails</tt></p>
</td><td><p>Probe that fires whenever an IP datagram is discarded because it could not be fragmented, for example, because fragmentation was required and the Don't Fragment flag was set.</p>
</td></tr>
<tr><td><p><tt>ipFragOKs</tt></p>
</td><td><p>Probe that fires whenever an IP datagram has been successfully fragmented.</p>
</td></tr>
<tr><td><p><tt>ipInCksumErrs</tt></p>
</td><td><p>Probe that fires whenever an input datagram is discarded due to a bad IP header checksum.</p>
</td></tr>
<tr><td><p><tt>ipInDelivers</tt></p>
</td><td><p>Probe that fires whenever an input datagram is successfully delivered to IP user protocols, including ICMP.</p>
</td></tr>
<tr><td><p><tt>ipInDiscards</tt></p>
</td><td><p>Probe that fires whenever an input IP datagram is discarded for reasons unrelated to the packet (for example, for lack of buffer space). This probe does not fire for any datagram discarded while awaiting reassembly.</p>
</td></tr>
<tr><td><p><tt>ipInHdrErrors</tt></p>
</td><td><p>Probe that fires whenever an input datagram is discarded due to an error in its IP header, including a version number mismatch, a format error, an exceeded time-to-live, an error discovered in processing IP options, and the like.</p>
</td></tr>
<tr><td><p><tt>ipInIPv6</tt></p>
</td><td><p>Probe that fires whenever an IPv6 packet erroneously arrives on an IPv4 queue.</p>
</td></tr>
<tr><td><p><tt>ipInReceives</tt></p>
</td><td><p>Probe that fires whenever a datagram is received from an interface, even if that datagram is received in error.</p>
</td></tr>
<tr><td><p><tt>ipInUnknownProtos</tt></p>
</td><td><p>Probe that fires whenever a locally addressed datagram is received successfully but subsequently discarded because of an unknown or unsupported protocol.</p>
</td></tr>
<tr><td><p><tt>ipOutDiscards</tt></p>
</td><td><p>Probe that fires whenever an output IP datagram is discarded for reasons unrelated to the packet (for example, for lack of buffer space). This probe will fire for a packet counted in the <tt>ipForwDatagrams</tt> MIB counter if the packet meets such a (discretionary) discard criterion.</p>
</td></tr>
<tr><td><p><tt>ipOutIPv6</tt></p>
</td><td><p>Probe that fires whenever an IPv6 packet is sent over an IPv4 connection.</p>
</td></tr>
<tr><td><p><tt>ipOutNoRoutes</tt></p>
</td><td><p>Probe that fires whenever an IP datagram is discarded because no route could be found to transmit it to its destination. This probe will fire for a packet counted in the <tt>ipForwDatagrams</tt> MIB counter if the packet meets this &ldquo;no-route&rdquo; criterion. This probe will also fire for any datagrams which cannot be routed because all default gateways are down.</p>
</td></tr>
<tr><td><p><tt>ipOutRequests</tt></p>
</td><td><p>Probe that fires whenever an IP datagram is supplied to IP for transmission from local IP user protocols (include ICMP). Note that this probe will not fire for any packet counted in the <tt>ipForwDatagrams</tt> MIB counter.</p>
</td></tr>
<tr><td><p><tt>ipOutSwitchIPv6</tt></p>
</td><td><p>Probe that fires whenever a connection changes from using IPv4 to using IPv6 as its IP protocol.</p>
</td></tr>
<tr><td><p><tt>ipReasmDuplicates</tt></p>
</td><td><p>Probe that fires whenever the IP reassembly algorithm determines that an IP fragment contains <b>only</b> previously received data.</p>
</td></tr>
<tr><td><p><tt>ipReasmFails</tt></p>
</td><td><p>Probe that fires whenever any failure is detected by the IP reassembly algorithm. This probe does not necessarily fire for every discarded IP fragment because some algorithms, notably the algorithm in RFC 815, can lose track of fragments by combining them as they are received.</p>
</td></tr>
<tr><td><p><tt>ipReasmOKs</tt></p>
</td><td><p>Probe that fires whenever an IP datagram is successfully reassembled.</p>
</td></tr>
<tr><td><p><tt>ipReasmPartDups</tt></p>
</td><td><p>Probe that fires whenever the IP reassembly algorithm determines that an IP fragment contains both some previously received data and some new data.</p>
</td></tr>
<tr><td><p><tt>ipReasmReqds</tt></p>
</td><td><p>Probe that fires whenever an IP fragment is received that needs to be reassembled.</p>
</td></tr>
</table><a name="tbl-mib-ipsec"></a>Table 28-4 IPsec <tt>mib</tt> Probes<table><tr><td><p><tt>ipsecInFailed</tt></p>
</td><td><p>Probe that fires whenever a received packet is dropped because it fails to match the specified IPsec policy.</p>
</td></tr>
<tr><td><p><tt>ipsecInSucceeded</tt></p>
</td><td><p>Probe that fires whenever a received packet matches the specified IPsec policy and processing is allowed to continue.</p>
</td></tr>
</table><a name="tbl-mib-ipv6"></a>Table 28-5 IPv6 <tt>mib</tt> Probes<table><tr><td><p><tt>ipv6ForwProhibits</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagram is received that does not have this machine as its final IPv6 destination, but because the machine is not permitted to act as a router, no attempt is made to find a route to forward the datagram to that final destination.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpBadHoplimit</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 neighbor discovery protocol message is received that is found to have a Hop Limit less than the defined maximum. Such messages might not have originated from a neighbor, and are therefore discarded.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInAdminProhibs</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Destination Unreachable (Communication Administratively Prohibited) message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInBadNeighborAdvertisements</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Neighbor Advertisement message is received that is malformed in some way.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInBadNeighborSolicitations</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Neighbor Solicit message is received that is malformed in some way.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInBadRedirects</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Redirect message is received that is malformed in some way.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInDestUnreachs</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Destination Unreachable message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInEchoReplies</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Echo Reply message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInEchos</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Echo request message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInErrors</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 message is received that is determined to have an ICMPv6-specific error (such as bad ICMPv6 checksum, bad length, and the like).</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInGroupMembBadQueries</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Query message is received that is malformed in some way.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInGroupMembBadReports</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Report message is received that is malformed in some way.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInGroupMembOurReports</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Report message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInGroupMembQueries</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Query message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInGroupMembReductions</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Reduction message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInGroupMembResponses</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Response message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInGroupMembTotal</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 multicast listener discovery message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInMsgs</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 message is received. When this probe fires, the <tt>ipv6IfIcmpInErrors</tt> probe might also fire if the message has an ICMPv6-specific error.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInNeighborAdvertisements</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Neighbor Advertisement message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInNeighborSolicits</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Neighbor Solicit message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInOverflows</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 message is received, but that message is subsequently dropped due to lack of buffer space.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInParmProblems</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Parameter Problem message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInRedirects</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Redirect message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInRouterAdvertisements</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Router Advertisement message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInRouterSolicits</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Router Solicit message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpInTimeExcds</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Time Exceeded message is received.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutAdminProhibs</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Destination Unreachable (Communication Administratively Prohibited) message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutDestUnreachs</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Destination Unreachable message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutEchoReplies</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Echo Reply message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutEchos</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Echo message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutErrors</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 message is not sent due to problems discovered within ICMPv6, such as a lack of buffers. This probe will not fire if errors are discovered outside the ICMPv6 layer, such as the inability of IPv6 to route the resulting datagram.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutGroupMembQueries</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Query message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutGroupMembReductions</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Reduction message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutGroupMembResponses</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Group Membership Response message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutMsgs</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 message is sent. When this probe fires, the <tt>ipv6IfIcmpOutErrors</tt> probe might also fire if the message has ICMPv6-specific errors.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutNeighborAdvertisements</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Neighbor Advertisement message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutNeighborSolicits</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Neighbor Solicitation message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutParmProblems</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Parameter Problem message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutPktTooBigs</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Packet Too Big message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutRedirects</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Redirect message is sent. For a host, this probe will never fire, because hosts do not send redirects.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutRouterAdvertisements</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Router Advertisement message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutRouterSolicits</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Router Solicit message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6IfIcmpOutTimeExcds</tt></p>
</td><td><p>Probe that fires whenever an ICMPv6 Time Exceeded message is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6InAddrErrors</tt></p>
</td><td><p>Probe that fires whenever an input datagram is discarded because the IPv6 address in their IPv6 header's destination field is not a valid address to be received by this entity. This probe will fire for invalid addresses (for example, ::0) and for unsupported addresses (for example, addresses with unallocated prefixes). For machines that are not configured to act as IPv6 routers and therefore do not forward datagrams, this probe will fire for datagrams discarded because the destination address was not a local address.</p>
</td></tr>
<tr><td><p><tt>ipv6InDelivers</tt></p>
</td><td><p>Probe that fires whenever an input datagram is successfully delivered to IPv6 user-protocols (including ICMPv6).</p>
</td></tr>
<tr><td><p><tt>ipv6InDiscards</tt></p>
</td><td><p>Probe that fires whenever an input IPv6 datagram is discarded for reasons unrelated to the packet (for example, for lack of buffer space). This probe does not fire for any datagram discarded while awaiting reassembly.</p>
</td></tr>
<tr><td><p><tt>ipv6InHdrErrors</tt></p>
</td><td><p>Probe that fires whenever an input datagram is discarded due to an error in its IPv6 header, including a version number mismatch, a format error, an exceeded hop count, an error discovered in processing IPv6 options, and the like.</p>
</td></tr>
<tr><td><p><tt>ipv6InIPv4</tt></p>
</td><td><p>Probe that fires whenever an IPv4 packet erroneously arrives on an IPv6 queue.</p>
</td></tr>
<tr><td><p><tt>ipv6InMcastPkts</tt></p>
</td><td><p>Probe that fires whenever a multicast IPv6 packet is received.</p>
</td></tr>
<tr><td><p><tt>ipv6InNoRoutes</tt></p>
</td><td><p>Probe that fires whenever a routed IPv6 datagram is discarded because no route could be found to transmit it to its destination. This probe will <b>only</b> fire for packets that have originated externally.</p>
</td></tr>
<tr><td><p><tt>ipv6InReceives</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagram is received from an interface, even if that datagram is received in error.</p>
</td></tr>
<tr><td><p><tt>ipv6InTooBigErrors</tt></p>
</td><td><p>Probe that fires whenever a fragment is received that is larger than the maximum fragment size.</p>
</td></tr>
<tr><td><p><tt>ipv6InTruncatedPkts</tt></p>
</td><td><p>Probe that fires whenever an input datagram is discarded because the datagram frame didn't carry enough data.</p>
</td></tr>
<tr><td><p><tt>ipv6InUnknownProtos</tt></p>
</td><td><p>Probe that fires whenever a locally-addressed IPv6 datagram is received successfully but subsequently discarded because of an unknown or unsupported protocol.</p>
</td></tr>
<tr><td><p><tt>ipv6OutDiscards</tt></p>
</td><td><p>Probe that fires whenever an output IPv6 datagram is discarded for reasons unrelated to the packet (for example, for lack of buffer space). This probe will fire for a packet counted in the <tt>ipv6OutForwDatagrams</tt> MIB counter if the packet meets such a (discretionary) discard criterion.</p>
</td></tr>
<tr><td><p><tt>ipv6OutForwDatagrams</tt></p>
</td><td><p>Probe that fires whenever a datagram is received that does not have this machine as its final IPv6 destination, and an attempt is made to find a route to forward the datagram to that final destination. On a machine that does not act as an IPv6 router, this probe will only fire for those packets that are source-routed through the machine, and for which the source-route option processing was successful.</p>
</td></tr>
<tr><td><p><tt>ipv6OutFragCreates</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagram fragment is generated as a result of fragmentation.</p>
</td></tr>
<tr><td><p><tt>ipv6OutFragFails</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagram is discarded because it could not be fragmented, for example, because its Don't Fragment flag was set.</p>
</td></tr>
<tr><td><p><tt>ipv6OutFragOKs</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagrams has been successfully fragmented.</p>
</td></tr>
<tr><td><p><tt>ipv6OutIPv4</tt></p>
</td><td><p>Probe that fires whenever an IPv6 packet is sent over an IPv4 connection.</p>
</td></tr>
<tr><td><p><tt>ipv6OutMcastPkts</tt></p>
</td><td><p>Probe that fires whenever a multicast packet is sent.</p>
</td></tr>
<tr><td><p><tt>ipv6OutNoRoutes</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagram is discarded because no route could be found to transmit it to its destination. This probe will <b>not</b> fire for packets that have originated externally.</p>
</td></tr>
<tr><td><p><tt>ipv6OutRequests</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagram is supplied to IPv6 for transmission from local IPv6 user protocols (including ICMPv6). This probe will not fire for any packet counted in the <tt>ipv6ForwDatagrams</tt> MIB counter.</p>
</td></tr>
<tr><td><p><tt>ipv6OutSwitchIPv4</tt></p>
</td><td><p>Probe that fires whenever a connection changes from using IPv6 to using IPv4 as its IP protocol.</p>
</td></tr>
<tr><td><p><tt>ipv6ReasmDuplicates</tt></p>
</td><td><p>Probe that fires whenever the IPv6 reassembly algorithm determines that an IPv6 fragment contains <b>only</b> previously received data.</p>
</td></tr>
<tr><td><p><tt>ipv6ReasmFails</tt></p>
</td><td><p>Probe that fires whenever a failure is detected by the IPv6 reassembly algorithm. This probe does not necessarily fire for every discarded IPv6 fragment since some algorithms can lose track of fragments by combining them as they are received.</p>
</td></tr>
<tr><td><p><tt>ipv6ReasmOKs</tt></p>
</td><td><p>Probe that fires whenever an IPv6 datagram is successfully reassembled.</p>
</td></tr>
<tr><td><p><tt>ipv6ReasmPartDups</tt></p>
</td><td><p>Probe that fires whenever the IPv6 reassembly algorithm determines that an IPv6 fragment contains both some previously received data and some new data.</p>
</td></tr>
<tr><td><p><tt>ipv6ReasmReqds</tt></p>
</td><td><p>Probe that fires whenever an IPv6 fragment is received that needs to be reassembled.</p>
</td></tr>
</table><a name="tbl-mib-rawip"></a>Table 28-6 Raw IP <tt>mib</tt> Probes<table><tr><td><p><tt>rawipInCksumErrs</tt></p>
</td><td><p>Probe that fires whenever a raw IP packet is received that has a bad IP checksum.</p>
</td></tr>
<tr><td><p><tt>rawipInDatagrams</tt></p>
</td><td><p>Probe that fires whenever a raw IP packet is received.</p>
</td></tr>
<tr><td><p><tt>rawipInErrors</tt></p>
</td><td><p>Probe that fires whenever a raw IP packet is received that is malformed in some way.</p>
</td></tr>
<tr><td><p><tt>rawipInOverflows</tt></p>
</td><td><p>Probe that fires whenever a raw IP packet is received, but that packet is subsequently dropped due to lack of buffer space.</p>
</td></tr>
<tr><td><p><tt>rawipOutDatagrams</tt></p>
</td><td><p>Probe that fires whenever a raw IP packet is sent.</p>
</td></tr>
<tr><td><p><tt>rawipOutErrors</tt></p>
</td><td><p>Probe that fires whenever a raw IP packet is not sent due to some error condition, typically because the raw IP packet was malformed in some way.</p>
</td></tr>
</table><a name="tbl-mib-sctp"></a>Table 28-7 SCTP <tt>mib</tt> Probes<table><tr><td><p><tt>sctpAborted</tt></p>
</td><td><p>Probe that fires whenever an SCTP association has made a direct transition to the CLOSED state from any state using the ABORT primitive, denoting ungraceful termination of the association.</p>
</td></tr>
<tr><td><p><tt>sctpActiveEstab</tt></p>
</td><td><p>Probe that fires whenever an SCTP association has made a direct transition to the ESTABLISHED state from the COOKIE-ECHOED state, denoting that the upper layer has initiated the association attempt.</p>
</td></tr>
<tr><td><p><tt>sctpChecksumError</tt></p>
</td><td><p>Probe that fires whenever an SCTP packet is received from peers with an invalid checksum.</p>
</td></tr>
<tr><td><p><tt>sctpCurrEstab</tt></p>
</td><td><p>Probe that fires whenever an SCTP association is tallied as a part of reading the <tt>sctpCurrEstab</tt> MIB counter. An SCTP association is tallied if its current state is ESTABLISHED, SHUTDOWN-RECEIVED, or SHUTDOWN-PENDING.</p>
</td></tr>
<tr><td><p><tt>sctpFragUsrMsgs</tt></p>
</td><td><p>Probe that fires whenever a user message has to be fragmented because of the MTU.</p>
</td></tr>
<tr><td><p><tt>sctpInClosed</tt></p>
</td><td><p>Probe that fires whenever data is received on a closed SCTP association.</p>
</td></tr>
<tr><td><p><tt>sctpInCtrlChunks</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpInCtrlChunks</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpInDupAck</tt></p>
</td><td><p>Probe that fires whenever a duplicate ACK is received.</p>
</td></tr>
<tr><td><p><tt>sctpInInvalidCookie</tt></p>
</td><td><p>Probe that fires whenever an invalid cookie is received.</p>
</td></tr>
<tr><td><p><tt>sctpInOrderChunks</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpInOrderChunks</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpInSCTPPkts</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpInSCTPPkts</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpInUnorderChunks</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpInUnorderChunks</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpListenDrop</tt></p>
</td><td><p>Probe that fires whenever an incoming connection is dropped for any reason.</p>
</td></tr>
<tr><td><p><tt>sctpOutAck</tt></p>
</td><td><p>Probe that fires whenever a selective acknowledgement is sent.</p>
</td></tr>
<tr><td><p><tt>sctpOutAckDelayed</tt></p>
</td><td><p>Probe that fires whenever delayed acknowledgement processing is performed for an SCTP association. Any acknowledgements sent as a part of delayed acknowledgement processing will cause the <tt>sctpOutAck</tt> probe to fire.</p>
</td></tr>
<tr><td><p><tt>sctpOutCtrlChunks</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpOutCtrlChunks</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpOutOfBlue</tt></p>
</td><td><p>Probe that fires whenever an otherwise correct SCTP packet is received for which the receiver is not able to identify the association to which the packet belongs.</p>
</td></tr>
<tr><td><p><tt>sctpOutOrderChunks</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpOutOrderChunks</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpOutSCTPPkts</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpOutSCTPPkts</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpOutUnorderChunks</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpOutUnorderChunks</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpOutWinProbe</tt></p>
</td><td><p>Probe that fires whenever a window probe is sent.</p>
</td></tr>
<tr><td><p><tt>sctpOutWinUpdate</tt></p>
</td><td><p>Probe that fires whenever a window update is sent.</p>
</td></tr>
<tr><td><p><tt>sctpPassiveEstab</tt></p>
</td><td><p>Probe that fires whenever SCTP associations have made a direct transition to the ESTABLISHED state from the CLOSED state. The remote endpoint has initiated the association attempt.</p>
</td></tr>
<tr><td><p><tt>sctpReasmUsrMsgs</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpReasmUsrMsgs</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpRetransChunks</tt></p>
</td><td><p>Probe that fires whenever the <tt>sctpRetransChunks</tt> MIB counter is updated, either because the MIB counter is explicitly queried or because an SCTP connection is closed. The value by which the MIB counter is to be increased is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>sctpShutdowns</tt></p>
</td><td><p>Probe that fires whenever an SCTP association makes the direct transition to the CLOSED state from either the SHUTDOWN-SENT state or the SHUTDOWN-ACK-SENT state, denoting graceful termination of the association.</p>
</td></tr>
<tr><td><p><tt>sctpTimHeartBeatDrop</tt></p>
</td><td><p>Probe that fires whenever an SCTP association is aborted due to failure to receive a heartbeat acknowledgement.</p>
</td></tr>
<tr><td><p><tt>sctpTimHeartBeatProbe</tt></p>
</td><td><p>Probe that fires whenever an SCTP heartbeat is sent.</p>
</td></tr>
<tr><td><p><tt>sctpTimRetrans</tt></p>
</td><td><p>Probe that fires whenever timer-based retransmit processing is performed on an association.</p>
</td></tr>
<tr><td><p><tt>sctpTimRetransDrop</tt></p>
</td><td><p>Probe that fires whenever prolonged failure to perform timer-based retransmission results in the association being aborted.</p>
</td></tr>
</table><a name="tbl-mib-tcp"></a>Table 28-8 TCP <tt>mib</tt> Probes<table><tr><td><p><tt>tcpActiveOpens</tt></p>
</td><td><p>Probe that fires whenever a TCP connection makes a direct transition from the CLOSED state to the SYN_SENT state.</p>
</td></tr>
<tr><td><p><tt>tcpAttemptFails</tt></p>
</td><td><p>Probe that fires whenever a TCP connection makes a direct transition to the CLOSED state from either the SYN_SENT state or the SYN_RCVD state and whenever a TCP connection makes a direct transition to the LISTEN state from the SYN_RCVD state.</p>
</td></tr>
<tr><td><p><tt>tcpCurrEstab</tt></p>
</td><td><p>Probe that fires whenever a TCP connection is tallied as a part of reading the <tt>tcpCurrEstab</tt> MIB counter. A TCP connection is tallied if its current state is either ESTABLISHED or CLOSE_WAIT.</p>
</td></tr>
<tr><td><p><tt>tcpEstabResets</tt></p>
</td><td><p>Probe that fires whenever a TCP connection makes the direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE_WAIT state.</p>
</td></tr>
<tr><td><p><tt>tcpHalfOpenDrop</tt></p>
</td><td><p>Probe that fires whenever a connection is dropped due to a full queue of connections in the SYN_RCVD state.</p>
</td></tr>
<tr><td><p><tt>tcpInAckBytes</tt></p>
</td><td><p>Probe that fires whenever an ACK is received for previously sent data. The number of bytes acknowledged is passed in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInAckSegs</tt></p>
</td><td><p>Probe that fires whenever an ACK is received for a previously sent segment.</p>
</td></tr>
<tr><td><p><tt>tcpInAckUnsent</tt></p>
</td><td><p>Probe that fires whenever an ACK is received for an unsent segment.</p>
</td></tr>
<tr><td><p><tt>tcpInClosed</tt></p>
</td><td><p>Probe that fires whenever data was received for a connection in a closing state.</p>
</td></tr>
<tr><td><p><tt>tcpInDataDupBytes</tt></p>
</td><td><p>Probe that fires whenever a segment is received such that all data in the segment has been previously received. The number of bytes in the duplicated segment is passed in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInDataDupSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is received such that all data in the segment has been previously received. The number of bytes in the duplicated segment is passed in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInDataInorderBytes</tt></p>
</td><td><p>Probe that fires whenever data is received such that <b>all</b> data prior to the new data's sequence number has been previously received. The number of bytes received in-order is passed in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInDataInorderSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is received such that <b>all</b> data prior to the new segment's sequence number has been previously received.</p>
</td></tr>
<tr><td><p><tt>tcpInDataPartDupBytes</tt></p>
</td><td><p>Probe that fires whenever a segment is received such that some of the data in the segment has been previously received, but some of the data in the segment is new. The number of duplicate bytes is passed in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInDataPartDupSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is received such that some of the data in the segment has been previously received, but some of the data in the segment is new. The number of duplicate bytes is passed in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInDataPastWinBytes</tt></p>
</td><td><p>Probe that fires whenever data is received that lies past the current receive window. The number of bytes is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInDataPastWinSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is received that lies past the current receive window.</p>
</td></tr>
<tr><td><p><tt>tcpInDataUnorderBytes</tt></p>
</td><td><p>Probe that fires whenever data is received such that some data prior to the new data's sequence number is missing. The number of bytes received unordered is passed in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpInDataUnorderSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is received such that some data prior to the new data's sequence number is missing.</p>
</td></tr>
<tr><td><p><tt>tcpInDupAck</tt></p>
</td><td><p>Probe that fires whenever a duplicate ACK is received.</p>
</td></tr>
<tr><td><p><tt>tcpInErrs</tt></p>
</td><td><p>Probe that fires whenever a TCP error (for example, a bad TCP checksum) is found on a received segment.</p>
</td></tr>
<tr><td><p><tt>tcpInSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is received, even if that segment is later found to have an error that prevents further processing.</p>
</td></tr>
<tr><td><p><tt>tcpInWinProbe</tt></p>
</td><td><p>Probe that fires whenever a window probe is received.</p>
</td></tr>
<tr><td><p><tt>tcpInWinUpdate</tt></p>
</td><td><p>Probe that fires whenever a window update is received.</p>
</td></tr>
<tr><td><p><tt>tcpListenDrop</tt></p>
</td><td><p>Probe that fires whenever an incoming connection is dropped due to a full listen queue.</p>
</td></tr>
<tr><td><p><tt>tcpListenDropQ0</tt></p>
</td><td><p>Probe that fires whenever a connection is dropped due to a full queue of connections in the SYN_RCVD state.</p>
</td></tr>
<tr><td><p><tt>tcpOutAck</tt></p>
</td><td><p>Probe that fires whenever an ACK is sent.</p>
</td></tr>
<tr><td><p><tt>tcpOutAckDelayed</tt></p>
</td><td><p>Probe that fires whenever an ACK is sent after having been initially delayed.</p>
</td></tr>
<tr><td><p><tt>tcpOutControl</tt></p>
</td><td><p>Probe that fires whenever a SYN, FIN, or RST is sent.</p>
</td></tr>
<tr><td><p><tt>tcpOutDataBytes</tt></p>
</td><td><p>Probe that fires whenever data is sent. The number of bytes sent is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpOutDataSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is sent.</p>
</td></tr>
<tr><td><p><tt>tcpOutFastRetrans</tt></p>
</td><td><p>Probes that fires whenever a segment is retransmitted as part of the fast retransmit algorithm.</p>
</td></tr>
<tr><td><p><tt>tcpOutRsts</tt></p>
</td><td><p>Probe that fires whenever a segment is sent with the RST flag set.</p>
</td></tr>
<tr><td><p><tt>tcpOutSackRetransSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is retransmitted on a connection that has selective acknowledgement enabled.</p>
</td></tr>
<tr><td><p><tt>tcpOutSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is sent that contains at least one non-retransmitted byte.</p>
</td></tr>
<tr><td><p><tt>tcpOutUrg</tt></p>
</td><td><p>Probe that fires whenever a segment is sent with the URG flag set, and with a valid urgent pointer.</p>
</td></tr>
<tr><td><p><tt>tcpOutWinProbe</tt></p>
</td><td><p>Probe that fires whenever a window probe is sent.</p>
</td></tr>
<tr><td><p><tt>tcpOutWinUpdate</tt></p>
</td><td><p>Probe that fires whenever a window update is sent.</p>
</td></tr>
<tr><td><p><tt>tcpPassiveOpens</tt></p>
</td><td><p>Probe that fires whenever a TCP connections have made a direct transition to the SYN_RCVD state from the LISTEN state.</p>
</td></tr>
<tr><td><p><tt>tcpRetransBytes</tt></p>
</td><td><p>Probe that fires whenever data is retransmitted. The number of bytes retransmitted is in <tt>args[0]</tt>.</p>
</td></tr>
<tr><td><p><tt>tcpRetransSegs</tt></p>
</td><td><p>Probe that fires whenever a segment is sent that contains one or more retransmitted bytes.</p>
</td></tr>
<tr><td><p><tt>tcpRttNoUpdate</tt></p>
</td><td><p>Probe that fires whenever data was received, but there was no timestamp information available with which to update the RTT.</p>
</td></tr>
<tr><td><p><tt>tcpRttUpdate</tt></p>
</td><td><p>Probe that fires whenever data was received containing the timestamp information necessary to update the RTT.</p>
</td></tr>
<tr><td><p><tt>tcpTimKeepalive</tt></p>
</td><td><p>Probe that fires whenever timer-based keep-alive processing is performed on a connection.</p>
</td></tr>
<tr><td><p><tt>tcpTimKeepaliveDrop</tt></p>
</td><td><p>Probe that fires whenever keep-alive processing results in termination of a connection.</p>
</td></tr>
<tr><td><p><tt>tcpTimKeepaliveProbe</tt></p>
</td><td><p>Probe that fires whenever a keep-alive probe is sent out as a part of keep-alive processing.</p>
</td></tr>
<tr><td><p><tt>tcpTimRetrans</tt></p>
</td><td><p>Probe that fires whenever timer-based retransmit processing is performed on a connection.</p>
</td></tr>
<tr><td><p><tt>tcpTimRetransDrop</tt></p>
</td><td><p>Probe that fires whenever prolonged failure to perform timer-based retransmission results in termination of the connection.</p>
</td></tr>
</table><a name="tbl-mib-udp"></a>Table 28-9 UDP <tt>mib</tt> Probes<table><tr><td><p><tt>udpInCksumErrs</tt></p>
</td><td><p>Probe that fires whenever a datagram is discarded due to a bad UDP checksum.</p>
</td></tr>
<tr><td><p><tt>udpInDatagrams</tt></p>
</td><td><p>Probe that fires whenever a UDP datagram is received.</p>
</td></tr>
<tr><td><p><tt>udpInErrors</tt></p>
</td><td><p>Probe that fires whenever a UDP datagram is received, but is discarded due to either a malformed packet header or the failure to allocate an internal buffer.</p>
</td></tr>
<tr><td><p><tt>udpInOverflows</tt></p>
</td><td><p>Probe that fires whenever a UDP datagram is received, but subsequently dropped due to lack of buffer space.</p>
</td></tr>
<tr><td><p><tt>udpNoPorts</tt></p>
</td><td><p>Probe that fires whenever a UDP datagram is received on a port to which no socket is bound.</p>
</td></tr>
<tr><td><p><tt>udpOutDatagrams</tt></p>
</td><td><p>Probe that fires whenever a UDP datagram is sent.</p>
</td></tr>
<tr><td><p><tt>udpOutErrors</tt></p>
</td><td><p>Probe that fires whenever a UDP datagram is not sent due to some error condition, typically because the datagram was malformed in some way.</p>
</td></tr>
</table><a name="chp-mib-1"></a><h3>Arguments</h3>
<p><a name="indexterm-417"></a>The sole argument for each <tt>mib</tt> probe has the same semantics: <tt>args[0]</tt> contains the value with which the counter is to be incremented. For most <tt>mib</tt> probes, <tt>args[0]</tt> always contains the value <tt>1</tt>, but for some probes <tt>args[0]</tt> may take arbitrary positive values. For these probes, the meaning of <tt>args[0]</tt> is noted in the probe description.</p>
<a name="chp-mib-stability"></a><h3>Stability</h3>
<p><a name="indexterm-418"></a><a name="indexterm-419"></a>The <tt>mib</tt> provider uses DTrace's stability mechanism to describe its stabilities, as shown in the following table. For more information about the stability mechanism, see <a href="p64.html">Chapter&nbsp;39, Stability</a>.</p>
<table><tr><th><p>Element</p>
</th><th><p>Name stability</p>
</th><th><p>Data stability</p>
</th><th><p>Dependency class</p>
</th></tr>
<tr><td><p>Provider</p>
</td><td><p>Evolving</p>
</td><td><p>Evolving</p>
</td><td><p>ISA</p>
</td></tr>
<tr><td><p>Module</p>
</td><td><p>Private</p>
</td><td><p>Private</p>
</td><td><p>Unknown</p>
</td></tr>
<tr><td><p>Function</p>
</td><td><p>Private</p>
</td><td><p>Private</p>
</td><td><p>Unknown</p>
</td></tr>
<tr><td><p>Name</p>
</td><td><p>Evolving</p>
</td><td><p>Evolving</p>
</td><td><p>ISA</p>
</td></tr>
<tr><td><p>Arguments</p>
</td><td><p>Evolving</p>
</td><td><p>Evolving</p>
</td><td><p>ISA</p>
</td></tr>
</table>
</div>
<!--stopindex-->

<!-- END CENTRAL COLUMN COMPONENTS -->
</td></tr>

<!-- BEGIN SPACER ROW -->
<tr><td><img src="css/a.gif" width="780" height="1" border="0" alt="" /></td></tr>
<!-- END SPACER ROW -->

<tr><td>

<!-- BEGIN PAGE CONTROL ROW -->
<table border="0" cellpadding="5" cellspacing="0" width="100%">
<tr valign="bottom">
<td></td>
<td style="width: 60%"></td>
<td><a href="p51.html"><img style="padding-right: 3px" src="graphics/prev.gif" border="0">Previous</a></td>
<td><a href="toc.html">Contents</a></td>
<td><a href="idx-1.html">Index</a></td>
<td><a href="p53.html">Next<img style="padding-left: 3px" src="graphics/next.gif" border="0"></a></td>
</tr>
</table>
<!-- END PAGE CONTROL ROW -->
</td></tr>

</table>
<!-- END WRAPPER TABLE, 1 COLUMN, MAIN -->


<!-- BEGIN A5 COMPONENT V.0 -->
<div class="a5" id="a5v0">
<span class="footerlinks">
<a href="http://www.sun.com/company/">Company Info</a>
<a href="http://www.sun.com/contact/">Contact</a>
<a href="http://www.sun.com/share/text/termsofuse.html">Terms of Use</a>
<a href="http://www.sun.com/privacy/">Privacy</a>

<span class="footercopy">Copyright 1994-2007 Sun Microsystems, Inc.</span>
</span>
</div>
<!-- END A5 COMPONENT V.0 -->

</body>
</html>

