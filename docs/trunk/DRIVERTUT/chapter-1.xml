<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN"
"docbook.dtd" [
<!ENTITY % xinclude SYSTEM "xinclude.mod">
%xinclude;
]>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xml:id="drivertut1">
  <title>Wprowadzenie do sterowników urządzeń</title>

  <toc>
    <para>Poniżej znajduje się przegląd jądra oraz systemu operacyjnego
    Solaris. Przedstawiono również środowisko i narzędzia służące do tworzenia
    sterowników.</para>
  </toc>

  <sect1 xml:id="fcaof">
    <title>Definicja systemu operacyjnego Solaris</title>

    <para><indexterm xml:id="indexterm-1">
        <primary>kernel</primary>
      </indexterm> <indexterm xml:id="indexterm-2">
        <primary>kernel mode</primary>
      </indexterm> <indexterm xml:id="indexterm-3">
        <primary>protected mode</primary>
      </indexterm> <indexterm xml:id="indexterm-4">
        <primary>user mode</primary>
      </indexterm> <indexterm xml:id="indexterm-5">
        <primary>restricted mode</primary>
      </indexterm>System operacyjny Solaris (Solaris OS) jest zaimplementowany
    jako plik wykonywalny uruchamiany podczas rozruchu komputera. Solaris OS
    nazywa się też <emphasis>jądrem</emphasis>. Jądro zawiera wszystkie
    funkcje i procedury wymagane do tego, aby system mógł działać. Ze względu
    na fundamentalne znaczenie jądra dla pracy komputera, pracuje ono w
    specjalnym chornionym trybie zwanym <emphasis>trybem jądra (ang. kernel
    mode)</emphasis>. Aplikacje przestrzeni użytkownika pracują w trybie
    ograniczonym (ang. restricted mode) zwanym <emphasis>trybem użytkownika
    (ang. user mode</emphasis>), który nie ma dostępu do instrukcji ani
    przestrzeni adresowej jądra. Sterowniki urządzeń pracują w trybie jądra i
    nie mają bezpośredniego dostępu do precesów trybu użytkownika.</para>
  </sect1>

  <sect1 xml:id="emjjp">
    <title>Przegląd jądra</title>

    <para>Jądro zarządza zasobami systemowymi, w tym systemami plików,
    procesami i urządzeniami fizycznymi. Jądro zapewnia aplikacjom usługi
    systemowe, takie jak zarządzanie I/O, pamięć wirtualna i planowanie. Jądro
    koordynuje współpracę wszystkich procesów użytkownika i zasobów
    systemowych. Przypisuje priorytety, obsługuje żądania dostępu do zasobów
    systemowych oraz sprzętowe przrwania i wyjątki. Planuje i przełącza wątki,
    strony pamięci i zamienia procesy.</para>

    <sect2 xml:id="emjjr">
      <title>Różnice między modułami jądra a programami przestrzeni
      użytkownika</title>

      <para>W podrozdziale przedstawiono ważne różnice między modułami jądra a
      programami przestrzeni użytkownika.</para>

      <sect3 xml:id="emqpr">
        <title>Różnice wykonywania między modułami jądra a programami
        przestrzeni użytkownika</title>

        <itemizedlist>
          <para>Poniższa charakterystyka modułów jądra podkreśla ważne różnice
          między wykonywaniem modułów jądra a programów użytkownika:</para>

          <listitem>
            <para><indexterm xml:id="indexterm-6">
                <primary>kernel</primary>

                <secondary>address space</secondary>
              </indexterm> <emphasis role="strong">Moduły jądra mają odrębną
            przestrzeń adresową.</emphasis> Moduł działa w
            <emphasis>przestrzeni jądra</emphasis>. Program działa w
            <emphasis>przestrzeni użytkownika</emphasis>. Oprogramowanie
            systemowe jest chronione przed programami użytkownika. Przestrzeń
            jądra i prrzestrzeń użytkownika mają własne, odrębne przestrzenie
            adresowe. Więcej informacji o przestrzeniach adresowych w <olink
            remap="internal" targetdoc="chapter-1.xml" targetptr="eoqob">User
            and Kernel Address Spaces on x86 and SPARC
            Machines</olink>.</para>
          </listitem>

          <listitem>
            <para><indexterm xml:id="indexterm-7">
                <primary>kernel</primary>

                <secondary>privilege</secondary>

                <seealso>kernel mode</seealso>
              </indexterm> <emphasis role="strong">Moduły jądra mają wyższy
            przywilej.</emphasis> Kod działający w przestrzeni jądra ma wyższy
            przywilej, niż kod działający w przestrzeni użytkownika.
            Sterowniki urządzeń mają możliwość większego oddziaływania na
            system, niż programy użytkowników. Kod sterowników musi być
            dokładnie przetestowany, aby uniknąć niegatywnego wpłuwy na
            system. Więcej informacji w <olink remap="external"
            targetdoc="chapter-4.xml" targetptr="fdlbq">Device Driver Testing
            Tips</olink>.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra nie są wykonywane
            sekwencyjnie.</emphasis> Program użytkownika zazwyczaj wykonywany
            jest sekwencyjnie i wykonuje jedno zadanie od początku do końca.
            Moduł jądra nie jest wykonywany sekwencyjnie. Moduł jądra
            rejestruje się w celu obsługi późniejszych żądań.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Działanie modułu jądra podlega
            przerwaniom.</emphasis> Więcej niż jeden proces może żądać
            działania od sterownika urządzenia. Obsługa przerwań może zarządać
            działania od sterownika w tym samym momencie, gdy obsługue on już
            jakieś żądanie. W środowisku równoczesnego wykonywania
            wieloprocesorowego (SMP) sterownik może być wykonywany
            równocześnie na wielu procesorach.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduł jądra musi dać się
            wywłaszczać.</emphasis> Nawet jeśli kod sterownika nie zakłada
            blokad, nie można założyć, że jest bezpieczny. Sterowniki należy
            projektować z założeniem, że mogą być wywłaszczane.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra mogą współdzielić
            dane.</emphasis> Odrębne wątki wykonywanego programu zazwyczaj nie
            daje współdzielą danych. Natomiast struktury danych i podprogramy,
            które składają się na sterownik urządzenia są współdzielone przez
            wszystkie wątki, które użytkują sterownik. Sterownik musi więc
            obsłużyć problemy ze spójnością wynikłe z wielu równoczesnych
            żądań. Struktury danych muszą być projektowane bardzo ostrożnie,
            aby utrzymać rozłączność wykonywanych równocześnie wątków. Kod
            sterownika musi obsługiwać współdzielone dane bez niszczenia lub
            psucia ich. Więcej informacji w <olink remap="external"
            targetdoc="819-3196" targetptr="mt-17026">Chapter 3, <citetitle
            remap="chapter">Multithreading,</citetitle> in <citetitle
            remap="book">Writing Device Drivers</citetitle> </olink> i <olink
            remap="external" targetdoc="816-5137"> <citetitle
            remap="book">Multithreaded Programming Guide</citetitle>
            </olink>.</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 xml:id="emqqh">
        <title>Różnice strukturalne między modułami jądra a programami
        użytkownika</title>

        <itemizedlist>
          <para>Poniższa charakterystyka modułów jądra podkreśla ważne różnice
          w strukturze modułów jądra a programów użytkownika:</para>

          <listitem>
            <para><indexterm xml:id="indexterm-8">
                <primary>device drivers</primary>

                <secondary>entry points</secondary>

                <seealso>entry points</seealso>
              </indexterm> <emphasis role="strong">Moduły jądra nie mają
            części main.</emphasis> Moduły jądra, włącznie ze sterownikami
            urządzeń, nie mają funkcji <function>main</function>. Moduł jest
            zbiorem funkcji i struktur danych. Sterownik jest modułem jądra,
            który zapewnia programowy interfejs I/O urządzenia. Funkcje
            sterownika zapewaniają <emphasis>punkty wejścia</emphasis> do
            urządzenia. Jądro używa numeru urządzenia do zlokalizowania
            funkcji <function>open</function> oraz innych funkcji właściwych
            dla sterownika urządzenia. Więcej informacji o punktach wejścia w
            <olink remap="internal" targetdoc="chapter-1.xml"
            targetptr="emjjs">Device Drivers</olink>. Więcej informacji o
            numerach urządzeń w <olink remap="internal"
            targetdoc="chapter-1.xml" targetptr="fgove">Device
            Numbers</olink>.</para>
          </listitem>

          <listitem>
            <para><indexterm xml:id="indexterm-9">
                <primary>linking</primary>
              </indexterm> <indexterm xml:id="indexterm-10">
                <primary>commands</primary>

                <secondary><command>ld</command></secondary>
              </indexterm> <indexterm xml:id="indexterm-11">
                <primary><command>ld</command> command</primary>
              </indexterm> <emphasis role="strong">Moduły jądra są
            konsolidowane (ang. linked) tylko z jądrem.</emphasis> Moduły
            jądra nie są konsolidowane z tymi samymi bibliotekami, z którymi
            konsolidowane są programy użytkownika. JEdynymi funkcjami, które
            może wywołać moduł jądra są funkcje eksportowane przez jądro.
            Jeśli sterownik odwołuje się do funkcji niezdefiniowanych w
            jądrze, skompiluje się, ale nie da się załadować. Sterowniki
            Solaris OS powinny używać interfejsów DDI/DKI (Device Driver
            Interface, Driver-Kernel Interface). Używanie tych interfejsów
            pozwala na migrację do nowej platformy lub uaktualnienie systemu
            bez rekompilowania sterownika. Więcej informacji o DDI w <olink
            remap="external" targetdoc="819-3196"
            targetptr="kernelovr-40"><citetitle remap="section">DDI/DKI
            Interfaces</citetitle> in <citetitle remap="book">Writing Device
            Drivers</citetitle> </olink>. Moduły jądra mogą zależeć od innych
            modułów. Wskazuje się to opcją <option>N</option> podczas
            edytowania konsolidacji. Więcej informacji na ten temat w
            podręczniku man <olink remap="external" targetdoc="819-2239"
            targetptr="ld-1"> <citerefentry>
                <refentrytitle>ld</refentrytitle>

                <manvolnum>1</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra używają innych plików
            nagłówkowych.</emphasis> Moduły jądra wymagają innych plików
            nagłówkowych niż programy użytkownika. Wymagane pliki nagłówkowe
            wydrukowane są na stronach man odpowiednich funkcji. Więcej
            informacji o funckjach DDI/DKI w <olink remap="external"
            targetdoc="819-2256"> <citetitle remap="book">man pages section 9:
            DDI and DKI Kernel Functions</citetitle> </olink>, o punktach
            wejścia <olink remap="external" targetdoc="819-2255"> <citetitle
            remap="book">man pages section 9: DDI and DKI Driver Entry
            Points</citetitle> </olink> i o strukturach <olink
            remap="external" targetdoc="819-2257"> <citetitle remap="book">man
            pages section 9: DDI and DKI Properties and Data
            Structures</citetitle> </olink>. Moduły jądra mogą włączać pliki
            nagłówkowe współdzielone z programami użytkownika, jeśli
            interfejscy jądra i użytkownika w tych plikach są definiowane
            conditional za pomocą makra <literal>_KERNEL</literal>.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra powinny unikać
            zmiennych globalnych.</emphasis> Unikanie zmiennych globalnych w
            modułach jądra jest jeszcze ważniejsze, niż ich unikanie w
            programach użytkownika. Jeśli to tylko możliwe symbole należy
            deklarować jako <literal>static</literal>. Jeśli użycie symboli
            globalnych jest nieuniknione, należy nadać im prefiks unikalny w
            całym jądrze. Używanie prefiksów również w prywatnej przestrzeni
            modułu jest dobrym zwyczajem.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra mogą być dostosowywane
            do sprzętu. </emphasis>Moduły jądra mogą przekazywać rejestry
            procesów konkretnym rolom. Kod jądra może być optymalizowany dla
            konkretnego procesora.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra mogą być ładowane
            dynamicznie.</emphasis> Zespół funkcji i struktur danych tworzący
            sterownik urządzdenia może być skompilowany w jeden plik obiektowy
            ładowany przez jądro. Moduł może być wtedy statycznie lub
            dynamicznie łączony z jądrem i odłączany od niego. Dzięki temu
            można dodawać do jądra nowe opcje i testować nowe wersje modułu
            bez restartu systemu.</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 xml:id="emqpt">
        <title>Różnice w przesyłaniu danych między modułami jądra i programami
        użytkowymi</title>

        <para>Przesył danych między urządzeniem a systemem jest zazwyczaj
        wolniejszy od przesyłu danych wewnątrz CPU. W związku z tym sterownik
        zazwyczaj zawiesza wykonanie wywołującego wątku aź do zakończenia
        przesyłania danych. Dopóki wątek wywołujący sterownik jest zawieszony,
        CPU może wykonywać inne wątki. Kiedy przesył danych się zakończy,
        sterownik dostaje przerwanie od urządzenia i obsługuje je, a później
        nakazuje procesorowi dalsze wykonywanie zawieszonego wątku. Więcej
        informacji w <olink remap="external" targetdoc="819-3196"
        targetptr="interrupt-15678">Chapter 8, <citetitle
        remap="chapter">Interrupt Handlers,</citetitle> in <citetitle
        remap="book">Writing Device Drivers</citetitle> </olink>.</para>

        <para>Sterowniki muszą pracować z adresami (wirtualnymi) procesów
        użytkownika, adresami (jądra) systemowymi i adresami szyny I/O.
        Sterowniki czasami kopiują dane między przestrzeniami adresowymi, a
        czasami manipulują tablicami mapującymi adresy. Węcej informacji w
        <olink remap="external" targetdoc="819-3196" targetptr="hwovr-18">
        <citetitle remap="section">Bus Architectures</citetitle> in <citetitle
        remap="book">Writing Device Drivers</citetitle> </olink>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="eoqob">
      <title>Przestrzenie adresowe jądra i użytkownika na platformach SPARC i
      x86</title>

      <indexterm xml:id="indexterm-12">
        <primary>x86</primary>

        <secondary>address space</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-13">
        <primary>SPARC</primary>

        <secondary>address space</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-14">
        <primary>kernel</primary>

        <secondary>address space</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-15">
        <primary><function>ddi_copyin </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-16">
        <primary>kernel functions</primary>

        <secondary><function>ddi_copyin </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-17">
        <primary><function>ddi_copyout </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-18">
        <primary>kernel functions</primary>

        <secondary><function>ddi_copyout </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-19">
        <primary><function>devmap </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-20">
        <primary>entry points</primary>

        <secondary><function>devmap </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-21">
        <primary><function>mmap </function> system call</primary>
      </indexterm>

      <indexterm xml:id="indexterm-22">
        <primary>system calls</primary>

        <secondary><function>mmap </function></secondary>
      </indexterm>

      <para>Na komputerach z rodziny SPARC system panikuje, jeśli moduł jądra
      próbuje bezpośrednio sięgnąć do przestrzeni adresowej użytkownika.
      Należy upewnić się, że sterownik nie sięga bezpośrednio do przestrzeni
      adresowej użytkownika.</para>

      <para>Na komputerach z rodziny x86 podczas próby bezpośredniego
      sięgnięcia do przestrzeni adresowej użytkownika nie pjawia się żaden
      błąd sprzętowy. Nadal jednak należy upewnić się, że sterownik nie sięga
      bezpośrednio do przestrzeni adresowej użytkownika. Sterowniki powinny
      być tak przenośne, jak to tylko możliwe. Każdy sterownik sięgający
      bezpośrednio do przestrzeni użytkownika jest źle napisany.</para>

      <caution>
        <para>Sterownik działający na maszynie z rodziny x86 może nie działać
        na maszynie z rodziny SPARC, ponieważ sięga do niewłaściwego
        adresu.</para>
      </caution>

      <para>Nie należy bezpośrednio pracować na danych użytkownika. Sterownik,
      który tak robi został źle napisany, jest nieprzenośny i nieutrzymywalny.
      Do przenoszenia danych między przestrzeniami jądra i użytkownika służą
      funkcje <olink remap="external" targetdoc="819-2256"
      targetptr="ddi-copyin-9f"> <citerefentry>
          <refentrytitle>ddi_copyin</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> i <olink remap="external"
      targetdoc="819-2256" targetptr="ddi-copyout-9f"> <citerefentry>
          <refentrytitle>ddi_copyout</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink>. Te dwie funkcje to jedyne utrzymywane
      interfejsy do dostępu do przestrzeni użytkownika. Przykłady użycia tych
      funkcji w sterowniku: <olink remap="external" targetdoc="chapter-3.xml"
      targetptr="ffdqq">Modifying Data Stored in Kernel Memory</olink>.</para>

      <para>The <olink remap="external" targetdoc="819-2241"
      targetptr="mmap-2"> <citerefentry>
          <refentrytitle>mmap</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> </olink> system call maps pages of memory between a
      process's address space and a file or shared memory object. In response
      to an <citerefentry>
          <refentrytitle>mmap</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> system call, the system calls the <olink
      remap="external" targetdoc="819-2255" targetptr="devmap-9e">
      <citerefentry>
          <refentrytitle>devmap</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> </olink> entry point to map device memory into user
      space. This information is then available for direct access by user
      applications.</para>
    </sect2>

    <sect2 xml:id="emjjs">
      <title>Sterowniki urządzeń</title>

      <indexterm xml:id="indexterm-23">
        <primary>device drivers</primary>
      </indexterm>

      <indexterm xml:id="indexterm-24">
        <primary>drivers</primary>

        <see>device drivers</see>
      </indexterm>

      <indexterm xml:id="indexterm-25">
        <primary>device drivers</primary>

        <secondary>entry points</secondary>

        <seealso>entry points</seealso>
      </indexterm>

      <indexterm xml:id="indexterm-26">
        <primary>device drivers</primary>

        <secondary>structures</secondary>

        <see>driver structures</see>
      </indexterm>

      <indexterm xml:id="indexterm-27">
        <primary><literal>dev_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-28">
        <primary>driver structures</primary>

        <secondary><literal>dev_ops</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-29">
        <primary><literal>cb_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-30">
        <primary>driver structures</primary>

        <secondary><literal>cb_ops</literal></secondary>
      </indexterm>

      <para>Sterownik urządzenia jest ładowalnym modułem jądra zarządzającym
      wymianą danych między urządzeniem a systemem operacyjnym. Moduły
      ładowalne są ładowane do jądra w trakcie startu systemu lub na żądanie i
      usuwane z jądra na żądanie. Sterownik jest zbiorem funkcji i struktur
      danych w języku C osiągalnych dla innych modułów jądra. Funkcje te muszą
      używać standardowych interfejsów nazywanych <emphasis>punktami wejścia
      (ang. entry points)</emphasis>. Dzięki użyciu punktów wejścia moduły
      wywołujące są oddzielone od wewnzetrznych mechanizmów sterownia. Więcej
      o punktach wejścia w <olink remap="external" targetdoc="819-3196"
      targetptr="eqbqy"> <citetitle remap="section">Device Driver Entry
      Points</citetitle> in <citetitle remap="book">Writing Device
      Drivers</citetitle> </olink>.</para>

      <para>Sterownik deklaruje swoje ogólne punkty wejścia w strukturze
      <olink remap="external" targetdoc="819-2257" targetptr="dev-ops-9s">
      <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink>. Punkty wejścia dla funkcji związanych z
      urządzeniami znakowymi lub blokowymi są deklarowane w strukturze <olink
      remap="external" targetdoc="819-2257" targetptr="cb-ops-9s">
      <citerefentry>
          <refentrytitle>cb_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink>. Niektóre z najpowszechniejszych punktów
      wejścia pokazane są na diagramie poniżej.</para>

      <figure xml:id="feowi">
        <title>Typical Device Driver Entry Points</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/epoints.common.gif"></imagedata>
          </imageobject>

          <textobject>
            <simpara>Diagram pokazuje punkty wejścia najczęściej spotykane w
            sterownikach urządzeń oraz ich przeznaczenie.</simpara>
          </textobject>
        </mediaobject>
      </figure>

      <para><indexterm xml:id="indexterm-31">
          <primary>device drivers</primary>

          <secondary>entry points</secondary>
        </indexterm>System operacyjny Solaris ma dużo puntów wejścia
      sterowników. Różne typy urządzeń wymagają różnych punktów wejścia w
      sterowniku. Poniższy diagram pokazuje niektóre dostępne punkty wejścia
      pogrupowanych według typu sterownika. Żaden pojedynczy sterownik nie
      używa wszystkich tych punktów.</para>

      <figure xml:id="fevyr">
        <title>Entry Points for Different Types of Drivers</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/epoints.block.gif"></imagedata>
          </imageobject>

          <textobject>
            <simpara>Diagram pokazuje podzbiór punktów wejścia używanych przez
            różne typy sterowników urządzeń.</simpara>
          </textobject>
        </mediaobject>
      </figure>

      <para><indexterm xml:id="indexterm-32">
          <primary>devices</primary>

          <secondary>pseudo</secondary>
        </indexterm> <indexterm xml:id="indexterm-33">
          <primary>devices</primary>

          <secondary>nexus</secondary>
        </indexterm> <indexterm xml:id="indexterm-34">
          <primary>devices</primary>

          <secondary>ramdisk</secondary>
        </indexterm>W systemie operacyjnym Solaris sterowniki mogą zarządzać
      fizycznymi urządzeniami (na przykład dyskami twardymi) lub programowymi
      (pseudo)urządzeniami (na przykład urządzeniami zbiorczymi szyny danych
      lub ramdyskami). W przypadku urządzeń sprzętowych sterownik komunikuje
      się ze sprzętowym kontrolerem zarządzającym urządzeniem. Sterownik
      oddziela aplikacje użytkowe od wewnętrznych szczegółów różnych urządzeń,
      dzięki czemu wywołania systemowe lub kod aplikacji mogą być niezależne
      od urządzenia.</para>

      <itemizedlist>
        <para><indexterm xml:id="indexterm-35">
            <primary>device drivers</primary>

            <secondary>how used</secondary>
          </indexterm>Sterowniki są wywoływane w następujących
        sytuacjach:</para>

        <listitem>
          <para><emphasis role="strong">Inicjalizacja systemu.</emphasis>
          Jądro wywołuje sterowniki urządzeń podczas uruchamiania systemu, aby
          znależć i przygotować do pracy dostępne urządzenia.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Wywołania systemowe z procesów
          użytkownika. </emphasis>Jądro wywołuje sterownik urządzenia aby
          wykonać operacje I/O na urządzeniu, takie jak <citerefentry>
              <refentrytitle>open</refentrytitle>

              <manvolnum>2</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>2</manvolnum>
            </citerefentry> i <citerefentry>
              <refentrytitle>ioctl</refentrytitle>

              <manvolnum>2</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Żądania z przestrzeni
          użytkownika.</emphasis> Jądro wywołuje sterownik urządzenia aby
          obsłużyć żądania komend takich jak <citerefentry>
              <refentrytitle>prtconf</refentrytitle>

              <manvolnum>1M</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Przerwania z urządzeń.</emphasis>
          Jądro wywołuje sterownik urządzenia aby obsłużyć przerwania
          wygenerowane przez urządzenie.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Reset szyny danych.</emphasis> Jądro
          wywołuje sterownik urządzenia aby do reinicjalizacji sterownika,
          urządzenia lub obu, kiedy zresetowano szynę danych. Szyna danych to
          ścieżka od CPU do urządzenia.</para>
        </listitem>
      </itemizedlist>

      <para>Poniższy diagram ilustruje interakcję sterownika urządzenia z
      resztą systemu.</para>

      <figure xml:id="feowj">
        <title>Typical Device Driver Interactions</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/driver.overview.gif"></imagedata>
          </imageobject>

          <textobject>
            <simpara>Diagram obrazuje typową współpracę systemu i sterownika
            urządzenia.</simpara>
          </textobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2 xml:id="fgomm">
      <title>Organizacja katalogu sterowników</title>

      <indexterm xml:id="indexterm-36">
        <primary>device drivers</primary>

        <secondary>directories</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-37">
        <primary>commands</primary>

        <secondary><command>kernel</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-38">
        <primary><command>kernel</command> command</primary>
      </indexterm>

      <indexterm xml:id="indexterm-39">
        <primary>files</primary>

        <secondary><filename>system</filename></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-40">
        <primary><filename>system</filename> configuration information
        file</primary>
      </indexterm>

      <para>Sterowniki urządzeń i inne moduły jądra są uporządkowane w
      następujacej hierarchii katalogów w systemie operacyjnyjm Solaris.
      Więcej informacji o organizacji jądra i dodawaniu katalogów do ścieżki
      wyszukiwania w jądrze w <olink remap="external" targetdoc="819-2240"
      targetptr="kernel-1m"> <citerefentry>
          <refentrytitle>kernel</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> and <olink remap="external"
      targetdoc="819-2251" targetptr="system-4"> <citerefentry>
          <refentrytitle>system</refentrytitle>

          <manvolnum>4</manvolnum>
        </citerefentry> </olink> .</para>

      <variablelist>
        <varlistentry>
          <term><filename>/kernel</filename></term>

          <listitem>
            <para>Moduły wspólne dla większości platform. Moduły wymagane do
            startu startu i inicjalizacji systemu muszą znależć się w tym
            katalogu.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>/platform/`uname -i`/kernel</filename></term>

          <listitem>
            <para>Moduły specyficzne dla platform identyfikowane przez
            <literal>uname -i</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>/platform/`uname -m`/kernel</filename></term>

          <listitem>
            <para>Moduły specyficzne dla platform identyfikowanych przez
            <literal>uname -m</literal>. Są związane z platformą sprzętową,
            ale bardziej ogólne niż te w katalogu <literal>uname
            -i</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <indexterm xml:id="indexterm-41">
            <primary><literal>/usr/kernel</literal> directory</primary>
          </indexterm>

          <term>
            <filename>/usr/kernel</filename>
          </term>

          <listitem>
            <para>Moduły użytkownika. Moduły niewymagane podczas startu i
            inicjalizacji systemu. Ten podręcznik instruuje, aby umieszczać
            własny kod w katalogu <filename>/usr/kernel</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><indexterm xml:id="indexterm-42">
          <primary>device drivers</primary>

          <secondary>loading</secondary>
        </indexterm> <indexterm xml:id="indexterm-43">
          <primary>commands</primary>

          <secondary><command>boot</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-44">
          <primary><command>boot</command> command</primary>
        </indexterm>Zaletą takiego zorganizowania sterowników jest możliwość
      ładowania wybranych grup sterowników podczas startu systemu, jak to
      pokazano poniżej. Więcej informacji w <olink remap="external"
      targetdoc="819-2240" targetptr="boot-1m"> <citerefentry>
          <refentrytitle>boot</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>.</para>

      <screen>Type    b [file-name] [boot-flags] &lt;ENTER&gt;      to boot with options
or      i &lt;ENTER&gt;                               to enter boot interpreter
or      &lt;ENTER&gt;                                 to boot with defaults

                  &lt;&lt;&lt; timeout in 5 seconds &gt;&gt;&gt;

Select (b)oot or (i)nterpreter: <userinput>b -a</userinput>
bootpath: /pci@0,0/pci8086,2545@3/pci8086,
Enter default directory for modules [/platform/i86pc/kernel /kernel 
/usr/kernel]: <userinput>/platform/i86pc/kernel /kernel</userinput>
</screen>

      <para><indexterm xml:id="indexterm-45">
          <primary><literal>/usr/kernel</literal> directory</primary>
        </indexterm> <indexterm xml:id="indexterm-46">
          <primary><literal>moddir</literal> kernel variable</primary>
        </indexterm> <indexterm xml:id="indexterm-47">
          <primary>device drivers</primary>

          <secondary>directories</secondary>

          <tertiary>adding</tertiary>
        </indexterm>W poniższym przykładzie pominięto katalog
      <literal>/usr/kernel</literal> w liście katalogów przeszukiwania modułów
      do ładowania. Można tak robić, jeśli w katalogu
      <literal>/usr/kernel</literal> znajduje się moduł powodujący panikę
      systemu podczas startu systemu lub podłączania sterownika. Lepszą metodą
      jest jednak umieszczenie modułu w osobnym katalogu. Za pomocą zmiennej
      jądra <literal>moddir</literal> należy dodać katalog do ścieżki
      przeszukiwania jądra. Zmienna <literal>moddir</literal> opisana jest w
      <citerefentry>
          <refentrytitle>kernel</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>system</refentrytitle>

          <manvolnum>4</manvolnum>
        </citerefentry>. Inna metoda pracy ze sterownikami, ktorę mogą
      powodwać problemy podczas startu systemu opisana jest w <olink
      remap="external" targetdoc="chapter-4.xml" targetptr="fdlbq">Device
      Driver Testing Tips</olink>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="fgomr">
    <title>Urządzenia jako pliki</title>

    <indexterm xml:id="indexterm-48">
      <primary>special files</primary>
    </indexterm>

    <indexterm xml:id="indexterm-49">
      <primary>devices</primary>

      <secondary>special files</secondary>
    </indexterm>

    <indexterm xml:id="indexterm-50">
      <primary>devices</primary>

      <secondary>block</secondary>
    </indexterm>

    <indexterm xml:id="indexterm-51">
      <primary>devices</primary>

      <secondary>character</secondary>
    </indexterm>

    <para>W systemach UNIX niemal wszystko można traktować jak plik. Programy
    użytkownika odwołują się do urządzeń tak, jakby były one plikami. Pliki
    reprezentujące urządzenia nazywane są <emphasis>plikami
    specjalnymi</emphasis> lub <emphasis>node'ami urządzeń (ang. device
    nodes)</emphasis>. Pliki specjalne urządzeń podzielone są na dwie klasy:
    <emphasis>urządzenia blokowe (ang. block</emphasis> devices) i
    <emphasis>urządzenia znakowe (ang. character devices)</emphasis>. Więcej w
    <olink remap="internal" targetdoc="chapter-1.xml"
    targetptr="fgoue">Character and Block Devices</olink>.</para>

    <para><indexterm xml:id="indexterm-52">
        <primary><function>read </function> system call</primary>
      </indexterm> <indexterm xml:id="indexterm-53">
        <primary>system calls</primary>

        <secondary><function>read </function></secondary>
      </indexterm>Każde żądanie I/O wstępnie odnosi się do nazwy pliku.
    Większość operacji czytających i zapisujących dane działają równie dobrze
    na plikach zwykłych i specjalnych. Na przykład to samo wywołanie systemowe
    <olink remap="external" targetdoc="819-2241" targetptr="read-2">
    <citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry> </olink> czyta bajty zarówno z pliku utworzonego
    edytorem tekstowym jak i z urządzenia terminala.</para>

    <para><indexterm xml:id="indexterm-54">
        <primary><function>ioctl </function> entry point</primary>
      </indexterm> <indexterm xml:id="indexterm-55">
        <primary>entry points</primary>

        <secondary><function>ioctl </function></secondary>
      </indexterm>Sygnały kontrolne są również obsługiwane jak pliki.
    Sygnałami kontrolnymi zarządza się za pomocą <olink remap="external"
    targetdoc="819-2255" targetptr="ioctl-9e"> <citerefentry>
        <refentrytitle>ioctl</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry> </olink>.</para>

    <sect2 xml:id="emjjv">
      <title>Katalogi urządzeń</title>

      <indexterm xml:id="indexterm-56">
        <primary>devices</primary>

        <secondary>directories</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-57">
        <primary><literal>/dev</literal> directory</primary>
      </indexterm>

      <indexterm xml:id="indexterm-58">
        <primary><literal>/devices</literal> directory</primary>
      </indexterm>

      <para>system operacyjny Solaris ma katalogi <literal>/dev</literal> i
      <literal>/devices</literal>. Niemal wszystkie sterowniki w katalogu
      <literal>/dev</literal> są odnośnikami do katalogu
      <literal>/devices</literal>. Katalog <literal>/dev</literal> jest
      standardem UNIX-owym. Katalog <literal>/devices</literal> jest
      specyficzny dla Solaris OS.</para>

      <para><indexterm xml:id="indexterm-59">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-60">
          <primary><command>prtconf</command> command</primary>
        </indexterm>Zgodnie z konwencją nazwy w katalogu
      <literal>/dev</literal> są czytelniejsze dla człowieka. Na przykład w
      katalogu <literal>/dev</literal> mogą znajdować się pliki o nazwach
      <literal>kdb</literal> i <literal>mouse</literal> będące odnośnikami do
      plików <literal>/devices/pseudo/conskbd@0:kbd</literal> i
      <literal>/devices/pseudo/consms@0:mouse</literal>. Komenda <olink
      remap="external" targetdoc="819-2240" targetptr="prtconf-1m">
      <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> drukuje nazwy podobne do tych w katalogu
      <literal>/devices</literal>. W poniższym przykładzie pokazano tylko
      fragment wydruku tej komendy.</para>

      <screen>% <userinput>prtconf -P</userinput>
        conskbd, instance #0
        consms, instance #0</screen>

      <para><indexterm xml:id="indexterm-61">
          <primary>commands</primary>

          <secondary><command>mknod</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-62">
          <primary><command>mknod</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-63">
          <primary><function>mknod </function> system call</primary>
        </indexterm> <indexterm xml:id="indexterm-64">
          <primary>system calls</primary>

          <secondary><function>mknod </function></secondary>
        </indexterm> <indexterm xml:id="indexterm-65">
          <primary>devices</primary>

          <secondary>numbers</secondary>
        </indexterm> <indexterm xml:id="indexterm-66">
          <primary>major number</primary>
        </indexterm> <indexterm xml:id="indexterm-67">
          <primary>minor number</primary>
        </indexterm>Pozycje w <literal>/dev</literal> niebędące odnośnikami do
      katalogu <literal>/devices</literal> są node'ami urządzeń lub plikami
      specjalnymi stworzonymi przez <olink remap="external"
      targetdoc="819-2240" targetptr="mknod-1m"> <citerefentry>
          <refentrytitle>mknod</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> lub <olink remap="external"
      targetdoc="819-2241" targetptr="mknod-2"> <citerefentry>
          <refentrytitle>mknod</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> </olink>. Są to pliki o zerowej długości, które mają
      tylko starszy i młodszy numer. Preferowane jest tworzenie odnośników do
      urządzeń w katalogu <literal>/devices</literal> zamiast używania
      <citerefentry>
          <refentrytitle>mknod</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry>.</para>

      <para><indexterm xml:id="indexterm-68">
          <primary><literal>/devices</literal> directory</primary>
        </indexterm>W wersjach Soalris OS wcześniejszych niż 10
      <literal>/devices</literal> był systemem plików na dysku składającym się
      z katalogów i plików. Począwszy od wersji 10 <literal>/devices</literal>
      jest wirtualnym systemem plików tworzącym katalogi i pliki na
      żądanie.</para>

      <para><indexterm xml:id="indexterm-69">
          <primary><literal>devfs</literal> devices file system</primary>
        </indexterm> <indexterm xml:id="indexterm-70">
          <primary>devices</primary>

          <secondary>file system</secondary>

          <tertiary><literal>devfs</literal></tertiary>
        </indexterm>Więcej infrormacji o sysmie plików urządzeń w <olink
      remap="external" targetdoc="819-2254" targetptr="devfs-7fs">
      <citerefentry>
          <refentrytitle>devfs</refentrytitle>

          <manvolnum>7FS</manvolnum>
        </citerefentry> </olink>.</para>
    </sect2>

    <sect2 xml:id="eoqof">
      <title>Drzewo urządzeń</title>

      <indexterm xml:id="indexterm-71">
        <primary>device tree</primary>
      </indexterm>

      <indexterm xml:id="indexterm-72">
        <primary>devices</primary>

        <secondary>device tree</secondary>
      </indexterm>

      <para>Pliki urządzeń w katalogu <literal>/devices</literal> nazywane są
      <emphasis>drzewem urządzeń (ang. device tree</emphasis>).</para>

      <para><indexterm xml:id="indexterm-73">
          <primary>nexus device</primary>
        </indexterm> <indexterm xml:id="indexterm-74">
          <primary>devices</primary>

          <secondary>nexus</secondary>
        </indexterm>Drzewo urządzeń obrazuje związki między urządzedniami. W
      drzewie urządzeń katalog reprezentuje <emphasis>splot (ang.
      nexus)</emphasis> urządzeń. Splot jest urządzeniem, które może być
      rodzicem innych urządzeń. W poniższym przykładzie
      <literal>pci@1f,0</literal> jest splotem. Tylko fragment wydruku komendy
      został zamieszczony poniżej.</para>

      <screen># <userinput>ls -l /devices</userinput>
drwxr-xr-x   4 root     sys          512 <replaceable>date</replaceable> <replaceable>time</replaceable> pci@1f,0/
crw-------   1 root     sys      111,255 <replaceable>date</replaceable> <replaceable>time</replaceable> pci@1f,0:devctl</screen>

      <para><indexterm xml:id="indexterm-75">
          <primary><command>prtconf</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-76">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-77">
          <primary><command>prtpicl</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-78">
          <primary>commands</primary>

          <secondary><command>prtpicl</command></secondary>
        </indexterm>Graficzną reprezentację drzewa urządzeń drukują komendy
      <olink remap="external" targetdoc="819-2240" targetptr="prtconf-1m">
      <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> i <olink remap="external"
      targetdoc="819-2240" targetptr="prtpicl-1m"> <citerefentry>
          <refentrytitle>prtpicl</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>. Więcej informacji w <olink remap="external"
      targetdoc="819-3196" targetptr="kernelovr-64300"> <citetitle
      remap="section">Overview of the Device Tree</citetitle> in <citetitle
      remap="book">Writing Device Drivers</citetitle> </olink>.</para>
    </sect2>

    <sect2 xml:id="fgoue">
      <title>Urządzenia znakowe i blokowe</title>

      <indexterm xml:id="indexterm-79">
        <primary>character device</primary>
      </indexterm>

      <indexterm xml:id="indexterm-80">
        <primary>devices</primary>

        <secondary>character</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-81">
        <primary>block device</primary>
      </indexterm>

      <indexterm xml:id="indexterm-82">
        <primary>devices</primary>

        <secondary>block</secondary>
      </indexterm>

      <para>Plik w drzewie plików niebędący katalogiem reprezentuje albo
      <emphasis>urządzenie znakowe</emphasis>, albo <emphasis>urządzenie
      blokowe</emphasis>.</para>

      <para><indexterm xml:id="indexterm-83">
          <primary><literal>/devices/pseudo</literal> directory</primary>
        </indexterm>Urządzenie blokowe może zawierać dane adresowalne i
      używalne wielokrotnie. Przykładem takiego urządzenia jest system plików.
      Dowolne urządzenie może być urządzeniem znakowym. Większość urządzeń
      blokowych ma znakowe interfejsy. Dyski mają interfejsy blokowe i
      znakowe. W katalogu <filename>/devices/pseudo</filename> Mogą znajdować
      się urządzenia podobne do poniższych:</para>

      <programlisting>brw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,blk
crw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,raw
brw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,blk
crw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,raw
brw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,blk
crw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,raw</programlisting>

      <para><indexterm xml:id="indexterm-84">
          <primary><literal>blk</literal> device</primary>
        </indexterm> <indexterm xml:id="indexterm-85">
          <primary>devices</primary>

          <secondary><literal>blk</literal></secondary>
        </indexterm> <indexterm xml:id="indexterm-86">
          <primary><literal>raw</literal> device</primary>
        </indexterm> <indexterm xml:id="indexterm-87">
          <primary>devices</primary>

          <secondary><literal>raw</literal></secondary>
        </indexterm>Urządzenia blokowe mają w trybie pliku znak
      <literal>b</literal> jako pierwszy znak. Urządzenia znakowe mają znak
      <literal>c</literal>. W powyższym wydruku urządzenia blokowe zawierają w
      nazwie <literal>blk</literal> a urządzenia znakowe zawierają w nazwie
      <literal>raw</literal>.</para>

      <para><indexterm xml:id="indexterm-88">
          <primary>metadevice</primary>
        </indexterm> <indexterm xml:id="indexterm-89">
          <primary>devices</primary>

          <secondary><literal>md</literal> metadevice</secondary>
        </indexterm>Urządzenie <olink remap="external" targetdoc="819-2254"
      targetptr="md-7d"> <citerefentry>
          <refentrytitle>md</refentrytitle>

          <manvolnum>7D</manvolnum>
        </citerefentry> </olink> jest metaurządzeniem dostarczającym usług
      dyskowych. Urządzenia blokowe używają dysku za pośrednictwem
      standardowych mechanizmów buforujących w systemie. Urządzenia znakowe
      zezwalają na bezpośredni dostęp do urządzenia buforom zapisu i odczytu
      użytkownika.</para>
    </sect2>

    <sect2 xml:id="fgovo">
      <title>Nazwy urządzeń</title>

      <indexterm xml:id="indexterm-90">
        <primary>devices</primary>

        <secondary>names</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-91">
        <primary>devices</primary>

        <secondary>directories</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-92">
        <primary><literal>/dev</literal> directory</primary>
      </indexterm>

      <indexterm xml:id="indexterm-93">
        <primary><command>devfsadmd</command> devices file system
        administration command</primary>
      </indexterm>

      <indexterm xml:id="indexterm-94">
        <primary>devices</primary>

        <secondary>file system</secondary>

        <tertiary><command>devfsadmd</command></tertiary>
      </indexterm>

      <para>Za chwilę wyjaśnione zostanie znaczenie poszczególnych elementów
      skomplikowanych i długich nazw urządzeń w <filename>/dev</filename> oraz
      w <filename>/devices</filename>. W przykładzie użyto nazwy wycinka (ang.
      slice) dysku:</para>

      <screen>/dev/dsk/c0t0d0s7 -&gt; ../../devices/pci@1c,600000/scsi@2/sd@0,0:h</screen>

      <para>Jako pierwsza zostanie wyjaśniona nazwa urządzenia w katalogu
      <filename>/dev</filename>. Nazwami tymi zarządza daemon <olink
      remap="external" targetdoc="819-2240" targetptr="devfsadmd-1m">
      <citerefentry>
          <refentrytitle>devfsadmd</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>.</para>

      <variablelist>
        <varlistentry>
          <term><literal>c0</literal></term>

          <listitem>
            <para>Kontroler 0</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>t0</literal></term>

          <listitem>
            <para>Cel 0. Na kontrolerach SCSI jest to numer dysku.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>d0</literal></term>

          <listitem>
            <para>SCSI LUN. Wskazuje wirtualne partycje na fizyczneym
            celu.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>s7</literal></term>

          <listitem>
            <para>Wycinek numer 7 na dysku docelowym numer 0.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><indexterm xml:id="indexterm-95">
          <primary><literal>/devices</literal> directory</primary>
        </indexterm>To samo urządzenie ma swój odpowiednik w katalogu
      <filename>/devices</filename>. Te nazwy pokazują fizyczną strukturę i
      prawdziwe nazwy urządzeń. Niektóre części nazwy urządzenia w katalogu
      <filename>/devices</filename> same są katalogami.</para>

      <variablelist>
        <varlistentry>
          <term><literal>pci@1c,600000</literal></term>

          <listitem>
            <para>Szyna PCI o adresie <literal>1c,600000</literal>. Adresy te
            mają znaczenie tylko dla urządzenia-rodzica.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>scsi@2</literal></term>

          <listitem>
            <para>Kontroler SCSI o adresie 2 na szynie PCI o adresie
            <literal>1c,600000</literal>. Ta część jest równoważna
            <literal>c0</literal> w nazwie
            <filename>/dev/dsk/c0t0d0s7</filename>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sd@0,0</literal></term>

          <listitem>
            <para>Dysk SCSI o adresie <literal>0,0</literal> na kontrolerze
            SCSI o adresie <literal>2</literal>. Nazwa ta oznacza cel 0, LUN 0
            i odpowiada części <literal>t0d0</literal> w nazwie
            <filename>/dev/dsk/c0t0d0s7</filename>. Nazwa i sterownik
            <literal>sd</literal> mogą odnosić się również do napędu IDE
            CD-ROM.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sd@0,0:h</literal></term>

          <listitem>
            <para>Młodszy node <literal>h</literal> na dysku SCSI o adresie
            <literal>0,0</literal>. Jest to część równoważna fragmentowi
            <literal>s7</literal> z zapisu
            <filename>/dev/dsk/c0t0d0s7</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="fgove">
      <title>Numery urządzeń</title>

      <indexterm xml:id="indexterm-96">
        <primary>device number</primary>
      </indexterm>

      <indexterm xml:id="indexterm-97">
        <primary>devices</primary>

        <secondary>numbers</secondary>
      </indexterm>

      <para><emphasis>Numer urządzenia (ang. device number)</emphasis>
      identyfikuje dane urządzenie i młodszy node w drzewie urządzeń.
      Parametr<literal> dev_t</literal> wymagany w wielu funkcjach DDI/DKI to
      jest właśnie ten numer urządzenia.</para>

      <para><indexterm xml:id="indexterm-98">
          <primary>major number</primary>
        </indexterm> <indexterm xml:id="indexterm-99">
          <primary>minor number</primary>
        </indexterm>Każde urządznie ma starszy numer (ang. major number) i
      młodszy numer (ang. minor number). Numer urządzenia to para
      <replaceable>starszy</replaceable>,<replaceable>młodszy</replaceable>. W
      liście z długimi nazwami para ta drukowana jest w kolumnie, w której
      zazwyczaj drukowana jest wielkość pliku. W przykładzie numer urządzenia
      to 86,255. Starzy numer to 86, młodszy numer to 255.</para>

      <screen>% <userinput>ls -l /devices/pci@0,0:devctl</userinput>
crw-------   1 root     sys       86,255 <replaceable>date</replaceable> <replaceable>time</replaceable> /devices/pci@0,0:devctl</screen>

      <para>W systemie Solaris starszy numer jest wybierany automatycznie
      podczas instalacji sterownika, aby zapobiec konfliktom z innymi
      starszymi numerami. Jądro używa tego numeru do powiązania żądań I/O z
      kodem sterownika. Na tej podstawie jądro decyduje, który sterownik
      wykonać, kiedy użytkownik wykonuje odczyt lub zapis do urządzenia.
      Wszystkie urządzenia i ich starsze numery wydrukowane są w pliku
      <filename>/etc/name_to_major</filename>.</para>

      <screen>% <userinput>grep 86 /etc/name_to_major</userinput>
pci 86</screen>

      <para><indexterm xml:id="indexterm-100">
          <primary>instance number</primary>
        </indexterm> <indexterm xml:id="indexterm-101">
          <primary>devices</primary>

          <secondary>instances</secondary>
        </indexterm>Młodszy numer przydzielany jest w sterowniku. Młodszy
      numer musi przyporządkować każdemu urządzeniu jego sterownik. Numery te
      zazwyczaj odpowiadają podurządzeniom. Na przykład sterownik dysku może
      komunikować się z kontrolerem dysku, do którego podłączono kilka dysków.
      Młodsze numery niekoniecznie mają swoje fizyczne odpowiedniki.</para>

      <para>Poniższy przykład pokazuje instancje 0, 1 i 2 urządzenia
      <literal>md</literal>. Numery 0, 1 i 2 są młodszymi numerami.</para>

      <programlisting>brw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,blk
crw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,raw
brw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,blk
crw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,raw
brw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,blk
crw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,raw</programlisting>

      <para>W nazwie <filename>sd@0,0:h,</filename>młodszy numer
      reprezentowany jest przez <literal>h</literal>. Kiedy sterownik
      otrzymuje żądanie dla młodszego node'u <literal>h</literal>, tak
      naprawdę otrzymuje odpowiedni młodszy numer. Sterownik node'u
      <literal>sd</literal> tłumaczy ten numer na odpowiedni wycinek partycji,
      czyli na przykład 7. zamontowany na <filename>/export</filename>.</para>

      <para><indexterm xml:id="indexterm-102">
          <primary><function>ddi_get_instance </function> kernel
          function</primary>
        </indexterm> <indexterm xml:id="indexterm-103">
          <primary>kernel functions</primary>

          <secondary><function>ddi_get_instance </function></secondary>
        </indexterm> <olink remap="external" targetdoc="chapter-2.xml"
      targetptr="eoqrt">Chapter 2, Template Driver Example</olink> opisuje
      funkcję <olink remap="external" targetdoc="819-2256"
      targetptr="ddi-get-instance-9f"> <citerefentry>
          <refentrytitle>ddi_get_instance</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> wykorzystywaną w sterowniku do uzyskania
      numeru instancji w sterowniku.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="frymm">
    <title>Środowisko i narzędzia deweloperskie</title>

    <para>W tym podrozdziale przestawiono proces tworzenia sterowników i kilka
    wskazówek odnośnie źródeł. Więcej informacji w <olink remap="external"
    targetdoc="819-3196" targetptr="fcaqh"> <citetitle remap="section">Driver
    Development Summary</citetitle> in <citetitle remap="book">Writing Device
    Drivers</citetitle> </olink>.</para>

    <para>Sun oferuje szkolenia związane z wnętrznościami systemu Solaris,
    analizą crash dumpów, pisaniem sterowników, DTrace, Sun Studio i innymi
    tematami przydatnymi deweloperom Solarisów.</para>

    <orderedlist>
      <para>Uogólniony proces pisania sterowników wygląda tak:</para>

      <listitem>
        <para>Stworzenie pliku źródłowego <literal>.c</literal> przy użyciu
        interfejsów i struktur zdefiniowanych na stronach podręczników man w
        sekcjach <literal>9E</literal>, <literal>9F</literal> i
        <literal>9S</literal>. Większość potrzebnych plików nagłówkowych
        znajduje się w <literal>/usr/include/sys</literal>. Strony man funkcji
        i struktur informują, które pliki nagłówkowe są dla nich
        wymagane.</para>
      </listitem>

      <listitem>
        <para>Zdefiniowanie właściwości sterownika w pliku konfiguracji
        sprzętowej <literal>.conf</literal> .</para>
      </listitem>

      <listitem>
        <para>Kompilacja i konsolidacja. Podczas kompilacji sterownika dla
        jądra systemu Solaris należy zawsze używać opcji<option>
        D_KERNEL</option>. Domyślnie produkowany jest plik 32bitowy. Aby
        uzyskać plik 64bitowy należy wskazać odpowiednią opcję, jak to opisano
        w <olink remap="internal" targetdoc="chapter-1.xml"
        targetptr="fgouv">Building a Driver</olink>.</para>
      </listitem>

      <listitem>
        <para>Skopiowanie pliku binarnego ze sterownikiem i pliku konfiguracji
        sterownika do właściwego katalogu
        <filename>[<replaceable>platform</replaceable>]/kernel</filename>.
        Więcej w <olink remap="internal" targetdoc="chapter-1.xml"
        targetptr="fgomm">Driver Directory Organization</olink>.</para>
      </listitem>

      <listitem>
        <para>Załadowanie sterownika komendą <citerefentry>
            <refentrytitle>add_drv</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry>. Po załadowaniu sterownika powinien pojawić się w
        katalogach <filename>/dev</filename> i <filename>/devices</filename>.
        Odpowiedni wpis pojawi się również w pliku
        <filename>/etc/name_to_major</filename>.</para>
      </listitem>
    </orderedlist>

    <sect2 xml:id="fsujc">
      <title>Pisanie sterownika</title>

      <para>Sterownik składa się z pliku żródłowego napisane w języku C i
      pliku konfiguracji sprzętu.</para>

      <sect3 xml:id="ganag">
        <title>Pisanie modułu sterownika</title>

        <para>Kod C sterownika to zbiór funkcji i struktur danych
        definiujących moduł jądra. Jak zauważono w punkcie <olink
        remap="internal" targetdoc="chapter-1.xml" targetptr="emqqh">Różnice
        strukturalne między modułami jądra a programami użytkownika</olink>,
        sterownik nie ma funkcji <function>main</function>. Wiele z funkcji
        sterownika to specjalne funkcje zwane punktami weścia. Więcej
        informacji w <olink remap="internal" targetdoc="chapter-1.xml"
        targetptr="emjjs">Device Drivers</olink>.</para>

        <para>Strony man funkcji zwierają zarówno deklaracje funkcji
        potrzebnych w terowniku oraz listę plików nagłówkowych, które trzeba
        włączyć do kodu. Uwaga: podczas czytania stron man należy sprawdzić,
        czy wyświetlana jest właściwa strona. Na przykład poniższa komenda
        wyświetli stronę <command>ioctl</command>(2), ale wywołanie systemowe
        <command>ioctl</command>(2) nie może być użyte w sterowniku
        urządzenia.</para>

        <screen>% <userinput>man ioctl</userinput>
</screen>

        <para>Poniższa komenda wyświetli stronę man
        <command>ioctl</command>(9E) opisującą funkcję
        <command>ioctl</command>(9E), będącą punktem wejścia sterownika
        urządzenia.</para>

        <screen>% <userinput>man ioctl.9e</userinput>
% <userinput>man -s 9e ioctl</userinput>
</screen>

        <para><indexterm xml:id="indexterm-104">
            <primary>prefixes</primary>
          </indexterm> <indexterm xml:id="indexterm-105">
            <primary>devices</primary>

            <secondary>prefixes</secondary>
          </indexterm>Konwencja nakazuje, aby nazwy funkcji i danych
        unikalnych dla danego sterownika zaczynały się wspólnym prefiksem.
        Prefiks jest nazwą lub skrótem nazwy sterownika i używa się go do
        wszystkich nazw właściwych dla danego sterownika. Ułatwia to szukanie
        i usuwanie błędów. Zamiast komunikatu o błędzie związanym z jakąś
        funkcją <function>attach</function>, błąd będzie dotyczył funkcji
        <function>mydriver_attach </function>lub
        <function>newdriver_attach</function>.</para>

        <para><indexterm xml:id="indexterm-106">
            <primary>data model</primary>

            <secondary>converting</secondary>
          </indexterm> <indexterm xml:id="indexterm-107">
            <primary><function>ddi_model_convert_from </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-108">
            <primary>kernel functions</primary>

            <secondary><function>ddi_model_convert_from
            </function></secondary>
          </indexterm>64bitowy system może wykonywać programy użytkownia
        64bitowe i 32bitowe. System 64bitowy wykonuje 32bitowe programy
        konwertując dane między tymi dwoma modelami danych. Jądro 64bitowe
        obsługuje dane użytkownia w obydwóch modelach: 64bitowym i 32bitowym.
        Gdy 64bitowy sterownik kopiuje dane między przestrzenią jądra a
        przestrzenią użytkownika, używa funkcji <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-model-convert-from-9f">
        <citerefentry>
            <refentrytitle>ddi_model_convert_from</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do ustalenia konieczności konwersji między
        modelami 32bitowym i 64bitowym. Przykład dostępny jest w <olink
        remap="external" targetdoc="chapter-3.xml" targetptr="fgham">Reporting
        and Setting Device Size and Re-initializing the Device</olink>.</para>

        <para>Sun Studio IDE zawiera trzy edytory plików źródłowych: GVIM,
        XEmacs i wbudowany edytor NetBeans. IDE zwiera pomoc dla każdego z
        tych edytorów. Edytory GVIM i Emacs można też wywołać z wiersza
        poleceń. Więcej w <command>vim</command>(1) i
        <command>xemacs</command>(1).</para>

        <itemizedlist>
          <para>Więcej informacji:</para>

          <listitem>
            <para>Więcej informacji o pisaniu sterowników urządzeń w <olink
            remap="external" targetdoc="chapter-4.xml"
            targetptr="fdlbn">Device Driver Coding Tips</olink> i <olink
            remap="external" targetdoc="819-3196"> <citetitle
            remap="book">Writing Device Drivers</citetitle> </olink>.</para>
          </listitem>

          <listitem>
            <para>Przykładowe pliki źródłowe są w <olink remap="external"
            targetdoc="chapter-2.xml" targetptr="eoqrt">Chapter 2, Template
            Driver Example</olink> i <olink remap="external"
            targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
            Writing Data in Kernel Memory</olink>.</para>
          </listitem>

          <listitem>
            <para>Źródła produkcyjnych sterowników są w <link
            xlink:href="http://www.opensolaris.org/" xlink:type="url"
            xmlns:xlink="http://www.w3.org/1999/xlink">[ FIXME]</link> w
            zakładce “Source Browser.”</para>
          </listitem>

          <listitem>
            <para>Więcej źródeł i dokumentacji można znaleźć na stronach
            społeczności sterowników urządzeńOpenSolarisa pod adresem [FIXME]
            oraz stronie deweloperów sterowników Solarisa na stronie Sun
            Developer Network (SDN) pod adresem [FIXME].</para>
          </listitem>

          <listitem>
            <para>Porady oraz przykłady wielu rozwiązań i tematów związanych z
            tworzeniem sterowników znajdują się w Driver Development <link
            xlink:href="http://developers.sun.com/solaris/developer/support/driver/faqs.html"
            xlink:type="text"
            xmlns:xlink="http://www.w3.org/1999/xlink">FAQ</link> (Frequently
            Asked Questions - często zadawane pytania).</para>
          </listitem>

          <listitem>
            <para>Więcej pomocy na forum Driver Development Solaris lub forum
            Kernel [FIXME] adresy www [/FIXME]. Wszystkie tematy można
            przejrzeć pod adresem [FIXME].</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 xml:id="ganar">
        <title>Pisanie pliku konfiguracyjnego</title>

        <para><indexterm xml:id="indexterm-109">
            <primary>configuration files</primary>
          </indexterm> <indexterm xml:id="indexterm-110">
            <primary>devices</primary>

            <secondary>properties</secondary>
          </indexterm> <indexterm xml:id="indexterm-111">
            <primary>devices</primary>

            <secondary>configuration files</secondary>
          </indexterm> <indexterm xml:id="indexterm-112">
            <primary><function>ddi_prop_get_int </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-113">
            <primary>kernel functions</primary>

            <secondary><function>ddi_prop_get_int </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-114">
            <primary><function>ddi_prop_lookup </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-115">
            <primary>kernel functions</primary>

            <secondary><function>ddi_prop_lookup </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-116">
            <primary><literal>driver.conf</literal> file</primary>
          </indexterm> <indexterm xml:id="indexterm-117">
            <primary>files</primary>

            <secondary><literal>driver.conf</literal></secondary>
          </indexterm>Sterownik, który nie jest samoidentyfikujący musi mieć
        plik konfiguracyjny o nazwie <replaceable>nazwa_node'a</replaceable>
        <literal>.conf</literal>, gdzie
        <replaceable>nazwa_node'a</replaceable> jest prefiksem dla urządzenia.
        Samoidentyfikujący się sterownik to taki, który umie uzyskać wszystkie
        właściwości i informacje z interfejsów właściwości DDI, takich jak
        <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-prop-get-int-9f"> <citerefentry>
            <refentrytitle>ddi_prop_get_int</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-prop-lookup-9f"> <citerefentry>
            <refentrytitle>ddi_prop_lookup</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Minimalna ilość informacji w pliku
        konfiguracyjnym to nazwa node'u urządzenia oraz nazwa lub typ rodzica
        urządzenia.</para>

        <para>Więcej informacji o plikach konfiguracyjnych sterowników
        urządzeń w <olink remap="external" targetdoc="819-2251"
        targetptr="driver.conf-4"> <citerefentry>
            <refentrytitle>driver.conf</refentrytitle>

            <manvolnum>4</manvolnum>
          </citerefentry> </olink>. Przykładowy plik konfiguracyjny <olink
        remap="external" targetdoc="chapter-2.xml" targetptr="eoxzw">Writing
        the Device Configuration File</olink>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="fgouv">
      <title>Budowanie sterownika</title>

      <para><indexterm xml:id="indexterm-118">
          <primary>device drivers</primary>

          <secondary>compiling</secondary>
        </indexterm> <indexterm xml:id="indexterm-119">
          <primary>compiling</primary>
        </indexterm> <indexterm xml:id="indexterm-120">
          <primary>SPARC</primary>

          <secondary>compiling</secondary>
        </indexterm> <indexterm xml:id="indexterm-121">
          <primary>x86</primary>

          <secondary>compiling</secondary>
        </indexterm> <indexterm xml:id="indexterm-122">
          <primary>device drivers</primary>

          <secondary>linking</secondary>
        </indexterm> <indexterm xml:id="indexterm-123">
          <primary>linking</primary>
        </indexterm> <indexterm xml:id="indexterm-124">
          <primary>path environment variable</primary>
        </indexterm>W tym podrozdziale napisane jest jak skompilować i
      skonsolidować sterownik dla różnych architektur.</para>

      <para>Make sure you have installed the Solaris OS at the Developer level
      or above. Follow the instructions in <olink remap="external"
      targetdoc="819-2393" targetptr="webstart-91">Chapter 2, <citetitle
      remap="chapter">Installing With the Solaris Installation Program
      (Tasks),</citetitle> in <citetitle remap="book">Solaris Express
      Installation Guide: Basic Installations</citetitle> </olink>. Select
      Custom Install, and select the Developer cluster or above.</para>

      <para>In your path environment variable, include
      <filename>/opt/SUNWspro/bin</filename> followed by
      <filename>/usr/ccs/bin</filename>.</para>

      <para>A 64-bit kernel cannot use a 32-bit driver. A 64-bit kernel can
      use only 64-bit drivers. All parts of any particular program must use
      the same data model. A device driver is not a complete program. The
      kernel is a complete program. A driver is a part of the kernel program.
      If you want your device to work with the Solaris OS in 32-bit mode and
      with the Solaris OS in 64-bit mode, then you must provide both a 32-bit
      driver and a 64-bit driver.</para>

      <para>By default, compilation on the Solaris OS yields a 32-bit result
      on every architecture. To obtain a 64-bit result, use the compilation
      options specified in this section for 64-bit architectures.</para>

      <para><indexterm xml:id="indexterm-125">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-126">
          <primary><command>prtconf</command> command</primary>
        </indexterm>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="prtconf-1m"> <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command with the <option> x</option> option
      to determine whether the firmware on this system is 64-bit ready.</para>

      <sect3 xml:id="gamyf">
        <title>Compiling with Sun Studio</title>

        <indexterm xml:id="indexterm-127">
          <primary>Sun Studio</primary>
        </indexterm>

        <indexterm xml:id="indexterm-128">
          <primary>commands</primary>

          <secondary><command>cc</command></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-129">
          <primary><command>cc</command> command</primary>
        </indexterm>

        <indexterm xml:id="indexterm-130">
          <primary>commands</primary>

          <secondary><command>ld</command></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-131">
          <primary><command>ld</command> command</primary>
        </indexterm>

        <itemizedlist>
          <para>Use the <option> D_KERNEL</option> option to indicate that
          this code defines a kernel module.</para>

          <listitem>
            <para>If you are compiling for a 64-bit SPARC architecture, use
            the <option> xarch=v9</option> option:</para>

            <screen>% <userinput>cc -D_KERNEL -xarch=v9 -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>

          <listitem>
            <para>If you are compiling for a 64-bit x86 architecture, use both
            the <option> xarch=amd64</option> option and the <option>
            xmodel=kernel</option> option:</para>

            <screen>% <userinput>cc -D_KERNEL -xarch=amd64 -xmodel=kernel -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>

          <listitem>
            <para>If you are compiling for a 32-bit architecture, use the
            following build commands:</para>

            <screen>% <userinput>cc -D_KERNEL -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>
        </itemizedlist>

        <para>For more information on compile and link options, see the <olink
        remap="external" targetdoc="819-2239" targetptr="as-1"> <citerefentry>
            <refentrytitle>as</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2239" targetptr="cc-1b"> <citerefentry>
            <refentrytitle>cc</refentrytitle>

            <manvolnum>1B</manvolnum>
          </citerefentry> </olink>, and <olink remap="external"
        targetdoc="819-2239" targetptr="ld-1"> <citerefentry>
            <refentrytitle>ld</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink> man pages. See also the <olink
        remap="external" targetdoc="819-3688"> <citetitle remap="book">Sun
        Studio 11: C User’s Guide</citetitle> </olink>. Click <citetitle>Sun
        Studio 11 Collection</citetitle> at the top left of this page to see
        Sun Studio books about <command>dbx</command>,
        <command>dmake</command>, Performance Analyzer, and other software
        development topics. To read technical articles about Sun Studio or to
        download Sun Studio, go to <link
        xlink:href="http://developers.sun.com/sunstudio/" xlink:type="url"
        xmlns:xlink="http://www.w3.org/1999/xlink"> </link>.</para>

        <note>
          <para>Sun Studio 9 does not support 64-bit x86 architectures. Use
          Sun Studio 10 or Sun Studio 11 to compile and debug drivers for
          64-bit x86 architectures.</para>
        </note>
      </sect3>

      <sect3 xml:id="gamzm">
        <title>Compiling with the GNU C Compiler</title>

        <indexterm xml:id="indexterm-132">
          <primary>GNU C</primary>
        </indexterm>

        <indexterm xml:id="indexterm-133">
          <primary>commands</primary>

          <secondary><command>gcc</command></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-134">
          <primary><command>gcc</command> command</primary>
        </indexterm>

        <para>To get the GNU C compiler, you must install the Solaris OS at
        the Developer level or above. Follow the instructions in <olink
        remap="external" targetdoc="819-2393" targetptr="webstart-91">Chapter
        2, <citetitle remap="chapter">Installing With the Solaris Installation
        Program (Tasks),</citetitle> in <citetitle remap="book">Solaris
        Express Installation Guide: Basic Installations</citetitle> </olink>.
        Select Custom Install, and select the Developer cluster or above. The
        GNU C compiler is installed in <filename>/usr/sfw</filename>.</para>

        <itemizedlist>
          <para>Use the <option> D_KERNEL</option> option to indicate that
          this code defines a kernel module. These examples show options that
          are required for correct functionality of the result.</para>

          <listitem>
            <para>If you are compiling for a 64-bit SPARC architecture, use
            the following build commands:</para>

            <screen>% <userinput>gcc -D_KERNEL -m64 -mcpu=v9 -mcmodel=medlow -fno-pic -mno-fpu
-ffreestanding -nodefaultlibs -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>

            <para>You might also want to use the <option>
            mtune=ultrasparc</option> option and the <option> O2</option>
            option.</para>
          </listitem>

          <listitem>
            <para>If you are compiling for a 64-bit x86 architecture, use the
            following build commands:</para>

            <screen>% <userinput>gcc -D_KERNEL -m64 -mcmodel=kernel -mno-red-zone -ffreestanding
-nodefaultlibs -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>

            <para>You might also want to use the <option>
            mtune=opteron</option> option and the <option> O2</option>
            option.</para>
          </listitem>

          <listitem>
            <para>If you are compiling for a 32-bit architecture, use the
            following build commands:</para>

            <screen>% <userinput>gcc -D_KERNEL -ffreestanding -nodefaultlibs -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>
        </itemizedlist>

        <para>For more information on these and other options, see the
        <command>gcc</command>(1) man page. See also the GCC web site at <link
        xlink:href="http://gcc.gnu.org/" xlink:type="url"
        xmlns:xlink="http://www.w3.org/1999/xlink"> </link>. More information
        about using the <command>gcc</command> compiler with the Solaris OS is
        on the OpenSolaris web site at <link
        xlink:href="http://opensolaris.org/os/community/tools/gcc/"
        xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
        </link>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="fsfqv">
      <title>Installing a Driver</title>

      <indexterm xml:id="indexterm-135">
        <primary>device drivers</primary>

        <secondary>installing</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-136">
        <primary>entry points</primary>

        <secondary><function>_info </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-137">
        <primary><function>_info </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-138">
        <primary>entry points</primary>

        <secondary><function>_init </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-139">
        <primary><function>_init </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-140">
        <primary>entry points</primary>

        <secondary><function>attach </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-141">
        <primary><function>attach </function> entry point</primary>
      </indexterm>

      <para>After you write and build your driver, you must install the driver
      binary. To install a driver, copy the driver binary and the
      configuration file to the appropriate <filename>/kernel/drv</filename>
      directory.</para>

      <para>Make sure you are user <literal>root</literal> when you install a
      driver.</para>

      <para>Copy the configuration file to the kernel driver area of the
      system.</para>

      <screen># <userinput>cp mydriver.conf /usr/kernel/drv</userinput>
</screen>

      <para>Install drivers in the <filename>/tmp</filename> directory until
      you are finished modifying and testing the <function>_info </function>,
      <function>_init </function>, and <function>attach </function> routines.
      See <olink remap="external" targetdoc="chapter-4.xml"
      targetptr="fdlbq">Device Driver Testing Tips</olink> for more
      information.</para>

      <para>Copy the driver binary to the <filename>/tmp</filename>
      directory.</para>

      <screen># <userinput>cp mydriver /tmp</userinput>
</screen>

      <itemizedlist>
        <para>Link to the driver from the kernel driver directory.</para>

        <listitem>
          <para>On a 64-bit SPARC architecture, link to the
          <filename>sparcv9</filename> directory:</para>

          <screen># <userinput>ln -s /tmp/mydriver /usr/kernel/drv/sparcv9/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 64-bit x86 architecture, link to the
          <filename>amd64</filename> directory:</para>

          <screen># <userinput>ln -s /tmp/mydriver /usr/kernel/drv/amd64/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 32-bit architecture, create the link as follows:</para>

          <screen># <userinput>ln -s /tmp/mydriver /usr/kernel/drv/mydriver</userinput>
</screen>
        </listitem>
      </itemizedlist>

      <para>When the driver is well tested, copy the driver directly to the
      appropriate kernel driver area of the system.</para>

      <itemizedlist>
        <listitem>
          <para>On a 64-bit SPARC architecture, copy the driver to the
          <filename>sparcv9</filename> directory:</para>

          <screen># <userinput>cp mydriver /usr/kernel/drv/sparcv9/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 64-bit x86 architecture, copy the driver to the
          <filename>amd64</filename> directory:</para>

          <screen># <userinput>cp mydriver /usr/kernel/drv/amd64/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 32-bit architecture, copy the driver to the kernel driver
          area of the system:</para>

          <screen># <userinput>cp mydriver /usr/kernel/drv/mydriver</userinput>
</screen>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="fsujf">
      <title>Adding, Updating, and Removing a Driver</title>

      <indexterm xml:id="indexterm-142">
        <primary>device drivers</primary>

        <secondary>adding</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-143">
        <primary>commands</primary>

        <secondary><command>add_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-144">
        <primary><command>add_drv</command> command</primary>
      </indexterm>

      <para>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="add-drv-1m"> <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to make the installed driver usable.
      Be sure you are user <literal>root</literal> when you use the
      <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command.</para>

      <screen># <userinput>add_drv mydriver</userinput>
</screen>

      <itemizedlist>
        <para>The following events take place when you add a driver:</para>

        <listitem>
          <para>The <citerefentry>
              <refentrytitle>_info</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, and <citerefentry>
              <refentrytitle>attach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> entry points are called in that order.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-145">
              <primary><literal>/devices</literal> directory</primary>
            </indexterm>The driver is added to the
          <filename>/devices</filename> directory.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-146">
              <primary>commands</primary>

              <secondary><command>modinfo</command></secondary>
            </indexterm> <indexterm xml:id="indexterm-147">
              <primary><command>modinfo</command> command</primary>
            </indexterm>The driver is the most recent module listed by <olink
          remap="external" targetdoc="819-2240" targetptr="modinfo-1m">
          <citerefentry>
              <refentrytitle>modinfo</refentrytitle>

              <manvolnum>1M</manvolnum>
            </citerefentry> </olink>.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-148">
              <primary>files</primary>

              <secondary><filename>/etc/name_to_major</filename></secondary>
            </indexterm> <indexterm xml:id="indexterm-149">
              <primary><filename>/etc/name_to_major</filename> file</primary>
            </indexterm>The driver is the most recent module listed in the
          file <filename>/etc/name_to_major</filename>.</para>
        </listitem>
      </itemizedlist>

      <para><indexterm xml:id="indexterm-150">
          <primary><literal>/etc/driver_aliases</literal> file</primary>
        </indexterm>The file <filename>/etc/driver_aliases</filename> might be
      updated. The <filename>/etc/driver_aliases</filename> file shows which
      devices are bound to which drivers. If a driver is not listed in the
      <filename>/etc/driver_aliases</filename> file, then the Solaris OS does
      not load that driver or attach to that driver. Each line of the
      <filename>/etc/driver_aliases</filename> file shows a driver name
      followed by a device name. You can search this file to determine which
      driver is managing your device.</para>

      <note>
        <para>Do not edit the <filename>/etc/driver_aliases</filename> file
        manually. Use the <citerefentry>
            <refentrytitle>add_drv</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> command to establish a device binding. Use the
        <citerefentry>
            <refentrytitle>update_drv</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> command to change a device binding.</para>
      </note>

      <para><indexterm xml:id="indexterm-151">
          <primary>PCI ID numbers</primary>
        </indexterm>The example drivers shown in this book manage pseudo
      devices. If your driver manages real hardware, then you need to use the
      <option> c</option> and <option> i</option> options on the <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command or the <option> i</option> option on the
      <citerefentry>
          <refentrytitle>update_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command. To specify a device class or device ID, you
      might find the following sites useful. This information also is useful
      to search the <filename>/etc/driver_aliases</filename> file to find out
      whether a device already is supported.</para>

      <itemizedlist>
        <listitem>
          <para>List of devices currently supported by the Solaris OS: <link
          xlink:href="http://www.sun.com/bigadmin/hcl/driverlist.html"
          xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
          </link></para>
        </listitem>

        <listitem>
          <para>Searchable PCI vendor and device lists: <link
          xlink:href="http://www.pcidatabase.com/" xlink:type="url"
          xmlns:xlink="http://www.w3.org/1999/xlink"> </link></para>
        </listitem>

        <listitem>
          <para>Repository of vendor IDs, device IDs, subsystems, and device
          classes used in PCI devices: <link
          xlink:href="http://pciids.sourceforge.net/" xlink:type="url"
          xmlns:xlink="http://www.w3.org/1999/xlink"> </link></para>
        </listitem>
      </itemizedlist>

      <para><indexterm xml:id="indexterm-152">
          <primary>device drivers</primary>

          <secondary>updating</secondary>
        </indexterm> <indexterm xml:id="indexterm-153">
          <primary>commands</primary>

          <secondary><command>update_drv</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-154">
          <primary><command>update_drv</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-155">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-156">
          <primary><command>prtconf</command> command</primary>
        </indexterm>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="update-drv-1m"> <citerefentry>
          <refentrytitle>update_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to notify the system about attribute
      changes to an installed device driver. By default, the <citerefentry>
          <refentrytitle>update_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command reloads the hardware configuration file for
      the specified driver. Use the <olink remap="external"
      targetdoc="819-2240" targetptr="prtconf-1m"> <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to review the current configuration
      information for a device and driver. For example, the <option>
      D</option> option shows which driver manages a particular device. The
      <option> P</option> option shows information about pseudo
      devices.</para>

      <para><indexterm xml:id="indexterm-157">
          <primary>device drivers</primary>

          <secondary>removing</secondary>
        </indexterm> <indexterm xml:id="indexterm-158">
          <primary>commands</primary>

          <secondary><command>rem_drv</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-159">
          <primary><command>rem_drv</command> command</primary>
        </indexterm>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="rem-drv-1m"> <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to update the system driver
      configuration files so that the driver is no longer usable. The
      <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command does not physically delete driver files. If
      possible, the <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command unloads the driver from memory.</para>
    </sect2>

    <sect2 xml:id="ganoc">
      <title>Loading and Unloading a Driver</title>

      <indexterm xml:id="indexterm-160">
        <primary>device drivers</primary>

        <secondary>loading</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-161">
        <primary>device drivers</primary>

        <secondary>unloading</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-162">
        <primary>commands</primary>

        <secondary><command>rem_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-163">
        <primary><command>rem_drv</command> command</primary>
      </indexterm>

      <para>A driver is loaded into memory when a device that the driver
      manages is accessed. A driver might be unloaded from memory when the
      driver is not being used. Normally, you do not need to load a driver
      into memory manually or unload a driver from memory manually.</para>

      <para>To manually load a loadable module into memory, use the <olink
      remap="external" targetdoc="819-2240" targetptr="modload-1m">
      <citerefentry>
          <refentrytitle>modload</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command.</para>

      <para>While you are developing your driver, you might want to manually
      unload the driver and then update the driver. To manually unload a
      loadable module from memory, use the <olink remap="external"
      targetdoc="819-2240" targetptr="modunload-1m"> <citerefentry>
          <refentrytitle>modunload</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command.</para>
    </sect2>

    <sect2 xml:id="fsujg">
      <title>Testing a Driver</title>

      <itemizedlist>
        <para><indexterm xml:id="indexterm-164">
            <primary>device drivers</primary>

            <secondary>test areas</secondary>
          </indexterm>Drivers should be thoroughly tested in the following
        areas:</para>

        <listitem>
          <para>Configuration</para>
        </listitem>

        <listitem>
          <para>Functionality</para>
        </listitem>

        <listitem>
          <para>Error handling</para>
        </listitem>

        <listitem>
          <para>Loading, unloading, and removing</para>

          <para>All drivers will need to be removed eventually. Make sure that
          your driver can be successfully removed.</para>
        </listitem>

        <listitem>
          <para>Stress, performance, and interoperability</para>
        </listitem>

        <listitem>
          <para>DDI/DKI compliance</para>
        </listitem>

        <listitem>
          <para>Installation and packaging</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <para>For detailed information on how to test your driver and how to
        avoid problems during testing, see the following references:</para>

        <listitem>
          <para><olink remap="external" targetdoc="chapter-4.xml"
          targetptr="fdlbq">Device Driver Testing Tips</olink></para>
        </listitem>

        <listitem>
          <para><olink remap="external" targetdoc="819-3196"
          targetptr="loading-17"> <citetitle remap="section">Criteria for
          Testing Drivers</citetitle> in <citetitle remap="book">Writing
          Device Drivers</citetitle> </olink></para>
        </listitem>

        <listitem>
          <para><olink remap="external" targetdoc="819-3196"
          targetptr="debug-60">Chapter 21, <citetitle
          remap="chapter">Debugging, Testing, and Tuning Device
          Drivers,</citetitle> in <citetitle remap="book">Writing Device
          Drivers</citetitle> </olink></para>
        </listitem>
      </itemizedlist>

      <para>Additional testing is specific to the type of driver.</para>
    </sect2>
  </sect1>
</chapter>