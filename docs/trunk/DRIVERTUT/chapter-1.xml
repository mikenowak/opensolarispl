<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN"
"docbook.dtd" [
<!ENTITY % xinclude SYSTEM "xinclude.mod">
%xinclude;
]>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xml:id="drivertut1">
  <title>Wprowadzenie do sterowników urządzeń</title>

  <toc>
    <para>Poniżej znajduje się przegląd jądra oraz systemu operacyjnego
    Solaris. Przedstawiono również środowisko i narzędzia służące do tworzenia
    sterowników.</para>
  </toc>

  <sect1 xml:id="fcaof">
    <title>Definicja systemu operacyjnego Solaris</title>

    <para><indexterm xml:id="indexterm-1">
        <primary>kernel</primary>
      </indexterm> <indexterm xml:id="indexterm-2">
        <primary>kernel mode</primary>
      </indexterm> <indexterm xml:id="indexterm-3">
        <primary>protected mode</primary>
      </indexterm> <indexterm xml:id="indexterm-4">
        <primary>user mode</primary>
      </indexterm> <indexterm xml:id="indexterm-5">
        <primary>restricted mode</primary>
      </indexterm>System operacyjny Solaris (Solaris OS) jest zaimplementowany
    jako plik wykonywalny uruchamiany podczas rozruchu komputera. Solaris OS
    nazywa się też <emphasis>jądrem</emphasis>. Jądro zawiera wszystkie
    funkcje i procedury wymagane do tego, aby system mógł działać. Ze względu
    na fundamentalne znaczenie jądra dla pracy komputera, pracuje ono w
    specjalnym chornionym trybie zwanym <emphasis>trybem jądra (ang. kernel
    mode)</emphasis>. Aplikacje przestrzeni użytkownika pracują w trybie
    ograniczonym (ang. restricted mode) zwanym <emphasis>trybem użytkownika
    (ang. user mode</emphasis>), który nie ma dostępu do instrukcji ani
    przestrzeni adresowej jądra. Sterowniki urządzeń pracują w trybie jądra i
    nie mają bezpośredniego dostępu do precesów trybu użytkownika.</para>
  </sect1>

  <sect1 xml:id="emjjp">
    <title>Przegląd jądra</title>

    <para>Jądro zarządza zasobami systemowymi, w tym systemami plików,
    procesami i urządzeniami fizycznymi. Jądro zapewnia aplikacjom usługi
    systemowe, takie jak zarządzanie I/O, pamięć wirtualna i planowanie. Jądro
    koordynuje współpracę wszystkich procesów użytkownika i zasobów
    systemowych. Przypisuje priorytety, obsługuje żądania dostępu do zasobów
    systemowych oraz sprzętowe przrwania i wyjątki. Planuje i przełącza wątki,
    strony pamięci i zamienia procesy.</para>

    <sect2 xml:id="emjjr">
      <title>Różnice między modułami jądra a programami przestrzeni
      użytkownika</title>

      <para>W podrozdziale przedstawiono ważne różnice między modułami jądra a
      programami przestrzeni użytkownika.</para>

      <sect3 xml:id="emqpr">
        <title>Różnice wykonywania między modułami jądra a programami
        przestrzeni użytkownika</title>

        <itemizedlist>
          <para>Poniższa charakterystyka modułów jądra podkreśla ważne różnice
          między wykonywaniem modułów jądra a programów użytkownika:</para>

          <listitem>
            <para><indexterm xml:id="indexterm-6">
                <primary>kernel</primary>

                <secondary>address space</secondary>
              </indexterm> <emphasis role="strong">Moduły jądra mają odrębną
            przestrzeń adresową.</emphasis> Moduł działa w
            <emphasis>przestrzeni jądra</emphasis>. Program działa w
            <emphasis>przestrzeni użytkownika</emphasis>. Oprogramowanie
            systemowe jest chronione przed programami użytkownika. Przestrzeń
            jądra i prrzestrzeń użytkownika mają własne, odrębne przestrzenie
            adresowe. Więcej informacji o przestrzeniach adresowych w <olink
            remap="internal" targetdoc="chapter-1.xml" targetptr="eoqob">User
            and Kernel Address Spaces on x86 and SPARC
            Machines</olink>.</para>
          </listitem>

          <listitem>
            <para><indexterm xml:id="indexterm-7">
                <primary>kernel</primary>

                <secondary>privilege</secondary>

                <seealso>kernel mode</seealso>
              </indexterm> <emphasis role="strong">Moduły jądra mają wyższy
            przywilej.</emphasis> Kod działający w przestrzeni jądra ma wyższy
            przywilej, niż kod działający w przestrzeni użytkownika.
            Sterowniki urządzeń mają możliwość większego oddziaływania na
            system, niż programy użytkowników. Kod sterowników musi być
            dokładnie przetestowany, aby uniknąć niegatywnego wpłuwy na
            system. Więcej informacji w <olink remap="external"
            targetdoc="chapter-4.xml" targetptr="fdlbq">Device Driver Testing
            Tips</olink>.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra nie są wykonywane
            sekwencyjnie.</emphasis> Program użytkownika zazwyczaj wykonywany
            jest sekwencyjnie i wykonuje jedno zadanie od początku do końca.
            Moduł jądra nie jest wykonywany sekwencyjnie. Moduł jądra
            rejestruje się w celu obsługi późniejszych żądań.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Działanie modułu jądra podlega
            przerwaniom.</emphasis> Więcej niż jeden proces może żądać
            działania od sterownika urządzenia. Obsługa przerwań może zarządać
            działania od sterownika w tym samym momencie, gdy obsługue on już
            jakieś żądanie. W środowisku równoczesnego wykonywania
            wieloprocesorowego (SMP) sterownik może być wykonywany
            równocześnie na wielu procesorach.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduł jądra musi dać się
            wywłaszczać.</emphasis> Nawet jeśli kod sterownika nie zakłada
            blokad, nie można założyć, że jest bezpieczny. Sterowniki należy
            projektować z założeniem, że mogą być wywłaszczane.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra mogą współdzielić
            dane.</emphasis> Odrębne wątki wykonywanego programu zazwyczaj nie
            daje współdzielą danych. Natomiast struktury danych i podprogramy,
            które składają się na sterownik urządzenia są współdzielone przez
            wszystkie wątki, które użytkują sterownik. Sterownik musi więc
            obsłużyć problemy ze spójnością wynikłe z wielu równoczesnych
            żądań. Struktury danych muszą być projektowane bardzo ostrożnie,
            aby utrzymać rozłączność wykonywanych równocześnie wątków. Kod
            sterownika musi obsługiwać współdzielone dane bez niszczenia lub
            psucia ich. Więcej informacji w <olink remap="external"
            targetdoc="819-3196" targetptr="mt-17026">Chapter 3, <citetitle
            remap="chapter">Multithreading,</citetitle> in <citetitle
            remap="book">Writing Device Drivers</citetitle> </olink> i <olink
            remap="external" targetdoc="816-5137"> <citetitle
            remap="book">Multithreaded Programming Guide</citetitle>
            </olink>.</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 xml:id="emqqh">
        <title>Różnice strukturalne między modułami jądra a programami
        użytkownika</title>

        <itemizedlist>
          <para>Poniższa charakterystyka modułów jądra podkreśla ważne różnice
          w strukturze modułów jądra a programów użytkownika:</para>

          <listitem>
            <para><indexterm xml:id="indexterm-8">
                <primary>device drivers</primary>

                <secondary>entry points</secondary>

                <seealso>entry points</seealso>
              </indexterm> <emphasis role="strong">Moduły jądra nie mają
            części main.</emphasis> Moduły jądra, włącznie ze sterownikami
            urządzeń, nie mają funkcji <function>main</function>. Moduł jest
            zbiorem funkcji i struktur danych. Sterownik jest modułem jądra,
            który zapewnia programowy interfejs I/O urządzenia. Funkcje
            sterownika zapewaniają <emphasis>punkty wejścia</emphasis> do
            urządzenia. Jądro używa numeru urządzenia do zlokalizowania
            funkcji <function>open</function> oraz innych funkcji właściwych
            dla sterownika urządzenia. Więcej informacji o punktach wejścia w
            <olink remap="internal" targetdoc="chapter-1.xml"
            targetptr="emjjs">Device Drivers</olink>. Więcej informacji o
            numerach urządzeń w <olink remap="internal"
            targetdoc="chapter-1.xml" targetptr="fgove">Device
            Numbers</olink>.</para>
          </listitem>

          <listitem>
            <para><indexterm xml:id="indexterm-9">
                <primary>linking</primary>
              </indexterm> <indexterm xml:id="indexterm-10">
                <primary>commands</primary>

                <secondary><command>ld</command></secondary>
              </indexterm> <indexterm xml:id="indexterm-11">
                <primary><command>ld</command> command</primary>
              </indexterm> <emphasis role="strong">Moduły jądra są
            konsolidowane (ang. linked) tylko z jądrem.</emphasis> Moduły
            jądra nie są konsolidowane z tymi samymi bibliotekami, z którymi
            konsolidowane są programy użytkownika. JEdynymi funkcjami, które
            może wywołać moduł jądra są funkcje eksportowane przez jądro.
            Jeśli sterownik odwołuje się do funkcji niezdefiniowanych w
            jądrze, skompiluje się, ale nie da się załadować. Sterowniki
            Solaris OS powinny używać interfejsów DDI/DKI (Device Driver
            Interface, Driver-Kernel Interface). Używanie tych interfejsów
            pozwala na migrację do nowej platformy lub uaktualnienie systemu
            bez rekompilowania sterownika. Więcej informacji o DDI w <olink
            remap="external" targetdoc="819-3196"
            targetptr="kernelovr-40"><citetitle remap="section">DDI/DKI
            Interfaces</citetitle> in <citetitle remap="book">Writing Device
            Drivers</citetitle> </olink>. Moduły jądra mogą zależeć od innych
            modułów. Wskazuje się to opcją <option>N</option> podczas
            edytowania konsolidacji. Więcej informacji na ten temat w
            podręczniku man <olink remap="external" targetdoc="819-2239"
            targetptr="ld-1"> <citerefentry>
                <refentrytitle>ld</refentrytitle>

                <manvolnum>1</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra używają innych plików
            nagłówkowych.</emphasis> Moduły jądra wymagają innych plików
            nagłówkowych niż programy użytkownika. Wymagane pliki nagłówkowe
            wydrukowane są na stronach man odpowiednich funkcji. Więcej
            informacji o funckjach DDI/DKI w <olink remap="external"
            targetdoc="819-2256"> <citetitle remap="book">man pages section 9:
            DDI and DKI Kernel Functions</citetitle> </olink>, o punktach
            wejścia <olink remap="external" targetdoc="819-2255"> <citetitle
            remap="book">man pages section 9: DDI and DKI Driver Entry
            Points</citetitle> </olink> i o strukturach <olink
            remap="external" targetdoc="819-2257"> <citetitle remap="book">man
            pages section 9: DDI and DKI Properties and Data
            Structures</citetitle> </olink>. Moduły jądra mogą włączać pliki
            nagłówkowe współdzielone z programami użytkownika, jeśli
            interfejscy jądra i użytkownika w tych plikach są definiowane
            conditional za pomocą makra <literal>_KERNEL</literal>.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra powinny unikać
            zmiennych globalnych.</emphasis> Unikanie zmiennych globalnych w
            modułach jądra jest jeszcze ważniejsze, niż ich unikanie w
            programach użytkownika. Jeśli to tylko możliwe symbole należy
            deklarować jako <literal>static</literal>. Jeśli użycie symboli
            globalnych jest nieuniknione, należy nadać im prefiks unikalny w
            całym jądrze. Używanie prefiksów również w prywatnej przestrzeni
            modułu jest dobrym zwyczajem.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra mogą być dostosowywane
            do sprzętu. </emphasis>Moduły jądra mogą przekazywać rejestry
            procesów konkretnym rolom. Kod jądra może być optymalizowany dla
            konkretnego procesora.</para>
          </listitem>

          <listitem>
            <para><emphasis role="strong">Moduły jądra mogą być ładowane
            dynamicznie.</emphasis> Zespół funkcji i struktur danych tworzący
            sterownik urządzdenia może być skompilowany w jeden plik obiektowy
            ładowany przez jądro. Moduł może być wtedy statycznie lub
            dynamicznie łączony z jądrem i odłączany od niego. Dzięki temu
            można dodawać do jądra nowe opcje i testować nowe wersje modułu
            bez restartu systemu.</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 xml:id="emqpt">
        <title>Data Transfer Differences Between Kernel Modules and User
        Programs</title>

        <para>Data transfer between a device and the system typically is
        slower than data transfer within the CPU. Therefore, a driver
        typically suspends execution of the calling thread until the data
        transfer is complete. While the thread that called the driver is
        suspended, the CPU is free to execute other threads. When the data
        transfer is complete, the device sends an interrupt. The driver
        handles the interrupt that the driver receives from the device. The
        driver then tells the CPU to resume execution of the calling thread.
        See <olink remap="external" targetdoc="819-3196"
        targetptr="interrupt-15678">Chapter 8, <citetitle
        remap="chapter">Interrupt Handlers,</citetitle> in <citetitle
        remap="book">Writing Device Drivers</citetitle> </olink>.</para>

        <para>Drivers must work with user process (virtual) addresses, system
        (kernel) addresses, and I/O bus addresses. Drivers sometimes copy data
        from one address space to another address space and sometimes just
        manipulate address-mapping tables. See <olink remap="external"
        targetdoc="819-3196" targetptr="hwovr-18"> <citetitle
        remap="section">Bus Architectures</citetitle> in <citetitle
        remap="book">Writing Device Drivers</citetitle> </olink>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="eoqob">
      <title>User and Kernel Address Spaces on x86 and SPARC Machines</title>

      <indexterm xml:id="indexterm-12">
        <primary>x86</primary>

        <secondary>address space</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-13">
        <primary>SPARC</primary>

        <secondary>address space</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-14">
        <primary>kernel</primary>

        <secondary>address space</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-15">
        <primary><function>ddi_copyin </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-16">
        <primary>kernel functions</primary>

        <secondary><function>ddi_copyin </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-17">
        <primary><function>ddi_copyout </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-18">
        <primary>kernel functions</primary>

        <secondary><function>ddi_copyout </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-19">
        <primary><function>devmap </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-20">
        <primary>entry points</primary>

        <secondary><function>devmap </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-21">
        <primary><function>mmap </function> system call</primary>
      </indexterm>

      <indexterm xml:id="indexterm-22">
        <primary>system calls</primary>

        <secondary><function>mmap </function></secondary>
      </indexterm>

      <para>On SPARC machines, the system panics when a kernel module attempts
      to directly access user address space. You must make sure your driver
      does not attempt to directly access user address space on a SPARC
      machine.</para>

      <para>On x86 machines, the system does not enter an error state when a
      kernel module attempts to directly access user address space. You still
      should make sure your driver does not attempt to directly access user
      address space on an x86 machine. Drivers should be written to be as
      portable as possible. Any driver that directly accesses user address
      space is a poorly written driver.</para>

      <caution>
        <para>A driver that works on an x86 machine might not work on a SPARC
        machine because the driver might access an invalid address.</para>
      </caution>

      <para>Do not access user data directly. A driver that directly accesses
      user address space is using poor programming practice. Such a driver is
      not portable and is not supportable. Use the <olink remap="external"
      targetdoc="819-2256" targetptr="ddi-copyin-9f"> <citerefentry>
          <refentrytitle>ddi_copyin</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> and <olink remap="external"
      targetdoc="819-2256" targetptr="ddi-copyout-9f"> <citerefentry>
          <refentrytitle>ddi_copyout</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> routines to transfer data to and from user
      address space. These two routines are the only supported interfaces for
      accessing user memory. <olink remap="external" targetdoc="chapter-3.xml"
      targetptr="ffdqq">Modifying Data Stored in Kernel Memory</olink> shows
      an example driver that uses <citerefentry>
          <refentrytitle>ddi_copyin</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> and <citerefentry>
          <refentrytitle>ddi_copyout</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry>.</para>

      <para>The <olink remap="external" targetdoc="819-2241"
      targetptr="mmap-2"> <citerefentry>
          <refentrytitle>mmap</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> </olink> system call maps pages of memory between a
      process's address space and a file or shared memory object. In response
      to an <citerefentry>
          <refentrytitle>mmap</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> system call, the system calls the <olink
      remap="external" targetdoc="819-2255" targetptr="devmap-9e">
      <citerefentry>
          <refentrytitle>devmap</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> </olink> entry point to map device memory into user
      space. This information is then available for direct access by user
      applications.</para>
    </sect2>

    <sect2 xml:id="emjjs">
      <title>Device Drivers</title>

      <indexterm xml:id="indexterm-23">
        <primary>device drivers</primary>
      </indexterm>

      <indexterm xml:id="indexterm-24">
        <primary>drivers</primary>

        <see>device drivers</see>
      </indexterm>

      <indexterm xml:id="indexterm-25">
        <primary>device drivers</primary>

        <secondary>entry points</secondary>

        <seealso>entry points</seealso>
      </indexterm>

      <indexterm xml:id="indexterm-26">
        <primary>device drivers</primary>

        <secondary>structures</secondary>

        <see>driver structures</see>
      </indexterm>

      <indexterm xml:id="indexterm-27">
        <primary><literal>dev_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-28">
        <primary>driver structures</primary>

        <secondary><literal>dev_ops</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-29">
        <primary><literal>cb_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-30">
        <primary>driver structures</primary>

        <secondary><literal>cb_ops</literal></secondary>
      </indexterm>

      <para>A device driver is a loadable kernel module that manages data
      transfers between a device and the OS. Loadable modules are loaded at
      boot time or by request and are unloaded by request. A device driver is
      a collection of C routines and data structures that can be accessed by
      other kernel modules. These routines must use standard interfaces called
      <emphasis>entry points</emphasis>. Through the use of entry points, the
      calling modules are shielded from the internal details of the driver.
      See <olink remap="external" targetdoc="819-3196" targetptr="eqbqy">
      <citetitle remap="section">Device Driver Entry Points</citetitle> in
      <citetitle remap="book">Writing Device Drivers</citetitle> </olink> for
      more information on entry points.</para>

      <para>A device driver declares its general entry points in its <olink
      remap="external" targetdoc="819-2257" targetptr="dev-ops-9s">
      <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> structure. A driver declares entry points for
      routines that are related to character or block data in its <olink
      remap="external" targetdoc="819-2257" targetptr="cb-ops-9s">
      <citerefentry>
          <refentrytitle>cb_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> structure. Some entry points and structures
      that are common to most drivers are shown in the following
      diagram.</para>

      <figure xml:id="feowi">
        <title>Typical Device Driver Entry Points</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/epoints.common.gif"></imagedata>
          </imageobject>

          <textobject>
            <simpara>Diagram shows entry points that are common to most
            drivers and how the entry points are used.</simpara>
          </textobject>
        </mediaobject>
      </figure>

      <para><indexterm xml:id="indexterm-31">
          <primary>device drivers</primary>

          <secondary>entry points</secondary>
        </indexterm>The Solaris OS provides many driver entry points.
      Different types of devices require different entry points in the driver.
      The following diagram shows some of the available entry points, grouped
      by driver type. No single device driver would use all the entry points
      shown in the diagram.</para>

      <figure xml:id="fevyr">
        <title>Entry Points for Different Types of Drivers</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/epoints.block.gif"></imagedata>
          </imageobject>

          <textobject>
            <simpara>Diagram shows subsets of entry points that are used by
            various types of device drivers.</simpara>
          </textobject>
        </mediaobject>
      </figure>

      <para><indexterm xml:id="indexterm-32">
          <primary>devices</primary>

          <secondary>pseudo</secondary>
        </indexterm> <indexterm xml:id="indexterm-33">
          <primary>devices</primary>

          <secondary>nexus</secondary>
        </indexterm> <indexterm xml:id="indexterm-34">
          <primary>devices</primary>

          <secondary>ramdisk</secondary>
        </indexterm>In the Solaris OS, drivers can manage physical devices,
      such as disk drives, or software (pseudo) devices, such as bus nexus
      devices or ramdisk devices. In the case of hardware devices, the device
      driver communicates with the hardware controller that manages the
      device. The device driver shields the user application layer from the
      details of a specific device so that application level or system calls
      can be generic or device independent.</para>

      <itemizedlist>
        <para><indexterm xml:id="indexterm-35">
            <primary>device drivers</primary>

            <secondary>how used</secondary>
          </indexterm>Drivers are accessed in the following situations:</para>

        <listitem>
          <para><emphasis role="strong">System initialization.</emphasis> The
          kernel calls device drivers during system initialization to
          determine which devices are available and to initialize those
          devices.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">System calls from user
          processes.</emphasis> The kernel calls a device driver to perform
          I/O operations on the device such as <citerefentry>
              <refentrytitle>open</refentrytitle>

              <manvolnum>2</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>2</manvolnum>
            </citerefentry>, and <citerefentry>
              <refentrytitle>ioctl</refentrytitle>

              <manvolnum>2</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">User-level requests.</emphasis> The
          kernel calls device drivers to service requests from commands such
          as <citerefentry>
              <refentrytitle>prtconf</refentrytitle>

              <manvolnum>1M</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Device interrupts.</emphasis> The
          kernel calls a device driver to handle interrupts generated by a
          device.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Bus reset.</emphasis> The kernel calls
          a device driver to re-initialize the driver, the device, or both
          when the bus is reset. The bus is the path from the CPU to the
          device.</para>
        </listitem>
      </itemizedlist>

      <para>The following diagram illustrates how a device driver interacts
      with the rest of the system.</para>

      <figure xml:id="feowj">
        <title>Typical Device Driver Interactions</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/driver.overview.gif"></imagedata>
          </imageobject>

          <textobject>
            <simpara>Diagram shows typical interactions between a device
            driver and other elements in the operating system.</simpara>
          </textobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2 xml:id="fgomm">
      <title>Driver Directory Organization</title>

      <indexterm xml:id="indexterm-36">
        <primary>device drivers</primary>

        <secondary>directories</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-37">
        <primary>commands</primary>

        <secondary><command>kernel</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-38">
        <primary><command>kernel</command> command</primary>
      </indexterm>

      <indexterm xml:id="indexterm-39">
        <primary>files</primary>

        <secondary><filename>system</filename></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-40">
        <primary><filename>system</filename> configuration information
        file</primary>
      </indexterm>

      <para>Device drivers and other kernel modules are organized into the
      following directories in the Solaris OS. See the <olink remap="external"
      targetdoc="819-2240" targetptr="kernel-1m"> <citerefentry>
          <refentrytitle>kernel</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> and <olink remap="external"
      targetdoc="819-2251" targetptr="system-4"> <citerefentry>
          <refentrytitle>system</refentrytitle>

          <manvolnum>4</manvolnum>
        </citerefentry> </olink> man pages for more information about kernel
      organization and how to add directories to your kernel module search
      path.</para>

      <variablelist>
        <varlistentry>
          <term><filename>/kernel</filename></term>

          <listitem>
            <para>These modules are common across most platforms. Modules that
            are required for booting or for system initialization belong in
            this directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>/platform/`uname -i`/kernel</filename></term>

          <listitem>
            <para>These modules are specific to the platform identified by the
            command <literal>uname -i</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>/platform/`uname -m`/kernel</filename></term>

          <listitem>
            <para>These modules are specific to the platform identified by the
            command <literal>uname -m</literal>. These modules are specific to
            a hardware class but more generic than modules in the
            <literal>uname -i</literal> kernel directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <indexterm xml:id="indexterm-41">
            <primary><literal>/usr/kernel</literal> directory</primary>
          </indexterm>

          <term>
            <filename>/usr/kernel</filename>
          </term>

          <listitem>
            <para>These are user modules. Modules that are not essential to
            booting belong in this directory. This tutorial instructs you to
            put all your drivers in the <filename>/usr/kernel</filename>
            directory.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><indexterm xml:id="indexterm-42">
          <primary>device drivers</primary>

          <secondary>loading</secondary>
        </indexterm> <indexterm xml:id="indexterm-43">
          <primary>commands</primary>

          <secondary><command>boot</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-44">
          <primary><command>boot</command> command</primary>
        </indexterm>One benefit of organizing drivers into different
      directories is that you can selectively load different groups of drivers
      on startup when you boot interactively at the boot prompt as shown in
      the following example. See the <olink remap="external"
      targetdoc="819-2240" targetptr="boot-1m"> <citerefentry>
          <refentrytitle>boot</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> man page for more information.</para>

      <screen>Type    b [file-name] [boot-flags] &lt;ENTER&gt;      to boot with options
or      i &lt;ENTER&gt;                               to enter boot interpreter
or      &lt;ENTER&gt;                                 to boot with defaults

                  &lt;&lt;&lt; timeout in 5 seconds &gt;&gt;&gt;

Select (b)oot or (i)nterpreter: <userinput>b -a</userinput>
bootpath: /pci@0,0/pci8086,2545@3/pci8086,
Enter default directory for modules [/platform/i86pc/kernel /kernel 
/usr/kernel]: <userinput>/platform/i86pc/kernel /kernel</userinput>
</screen>

      <para><indexterm xml:id="indexterm-45">
          <primary><literal>/usr/kernel</literal> directory</primary>
        </indexterm> <indexterm xml:id="indexterm-46">
          <primary><literal>moddir</literal> kernel variable</primary>
        </indexterm> <indexterm xml:id="indexterm-47">
          <primary>device drivers</primary>

          <secondary>directories</secondary>

          <tertiary>adding</tertiary>
        </indexterm>In this example, the <literal>/usr/kernel</literal>
      location is omitted from the list of directories to search for modules
      to load. You might want to do this if you have a driver in
      <literal>/usr/kernel</literal> that causes the kernel to panic during
      startup or on attach. Instead of omitting all
      <filename>/usr/kernel</filename> modules, a better method for testing
      drivers is to put them in their own directory. Use the
      <literal>moddir</literal> kernel variable to add this test directory to
      your kernel modules search path. The <literal>moddir</literal> kernel
      variable is described in <citerefentry>
          <refentrytitle>kernel</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> and <citerefentry>
          <refentrytitle>system</refentrytitle>

          <manvolnum>4</manvolnum>
        </citerefentry>. Another method for working with drivers that might
      have startup problems is described in <olink remap="external"
      targetdoc="chapter-4.xml" targetptr="fdlbq">Device Driver Testing
      Tips</olink>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="fgomr">
    <title>Devices as Files</title>

    <indexterm xml:id="indexterm-48">
      <primary>special files</primary>
    </indexterm>

    <indexterm xml:id="indexterm-49">
      <primary>devices</primary>

      <secondary>special files</secondary>
    </indexterm>

    <indexterm xml:id="indexterm-50">
      <primary>devices</primary>

      <secondary>block</secondary>
    </indexterm>

    <indexterm xml:id="indexterm-51">
      <primary>devices</primary>

      <secondary>character</secondary>
    </indexterm>

    <para>In UNIX, almost everything can be treated as a file. UNIX user
    applications access devices as if the devices were files. Files that
    represent devices are called <emphasis>special files</emphasis> or
    <emphasis>device nodes</emphasis>. Device special files are divided into
    two classes: <emphasis>block</emphasis> devices and
    <emphasis>character</emphasis> devices. See <olink remap="internal"
    targetdoc="chapter-1.xml" targetptr="fgoue">Character and Block
    Devices</olink> for more information.</para>

    <para><indexterm xml:id="indexterm-52">
        <primary><function>read </function> system call</primary>
      </indexterm> <indexterm xml:id="indexterm-53">
        <primary>system calls</primary>

        <secondary><function>read </function></secondary>
      </indexterm>Every I/O service request initially refers to a named file.
    Most I/O operations that read or write data perform equally well on
    ordinary or special files. For example, the same <olink remap="external"
    targetdoc="819-2241" targetptr="read-2"> <citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry> </olink> system call reads bytes from a file created
    with a text editor and reads bytes from a terminal device.</para>

    <para><indexterm xml:id="indexterm-54">
        <primary><function>ioctl </function> entry point</primary>
      </indexterm> <indexterm xml:id="indexterm-55">
        <primary>entry points</primary>

        <secondary><function>ioctl </function></secondary>
      </indexterm>Control signals also are handled as files. Use the <olink
    remap="external" targetdoc="819-2255" targetptr="ioctl-9e"> <citerefentry>
        <refentrytitle>ioctl</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry> </olink> function to manipulate control signals.</para>

    <sect2 xml:id="emjjv">
      <title>Devices Directories</title>

      <indexterm xml:id="indexterm-56">
        <primary>devices</primary>

        <secondary>directories</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-57">
        <primary><literal>/dev</literal> directory</primary>
      </indexterm>

      <indexterm xml:id="indexterm-58">
        <primary><literal>/devices</literal> directory</primary>
      </indexterm>

      <para>The Solaris OS includes both <literal>/dev</literal> and
      <literal>/devices</literal> directories for device drivers. Almost all
      the drivers in the <literal>/dev</literal> directory are links to the
      <literal>/devices</literal> directory. The <literal>/dev</literal>
      directory is UNIX standard. The <literal>/devices</literal> directory is
      specific to the Solaris OS.</para>

      <para><indexterm xml:id="indexterm-59">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-60">
          <primary><command>prtconf</command> command</primary>
        </indexterm>By convention, file names in the <literal>/dev</literal>
      directory are more readable. For example, the <literal>/dev</literal>
      directory might contain files with names such as <literal>kdb</literal>
      and <literal>mouse</literal> that are links to files such as
      <literal>/devices/pseudo/conskbd@0:kbd</literal> and
      <literal>/devices/pseudo/consms@0:mouse</literal>. The <olink
      remap="external" targetdoc="819-2240" targetptr="prtconf-1m">
      <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command shows device names that are very
      similar to the file names in the <literal>/devices</literal> directory.
      In the following example, only selected output of the command is
      shown.</para>

      <screen>% <userinput>prtconf -P</userinput>
        conskbd, instance #0
        consms, instance #0</screen>

      <para><indexterm xml:id="indexterm-61">
          <primary>commands</primary>

          <secondary><command>mknod</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-62">
          <primary><command>mknod</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-63">
          <primary><function>mknod </function> system call</primary>
        </indexterm> <indexterm xml:id="indexterm-64">
          <primary>system calls</primary>

          <secondary><function>mknod </function></secondary>
        </indexterm> <indexterm xml:id="indexterm-65">
          <primary>devices</primary>

          <secondary>numbers</secondary>
        </indexterm> <indexterm xml:id="indexterm-66">
          <primary>major number</primary>
        </indexterm> <indexterm xml:id="indexterm-67">
          <primary>minor number</primary>
        </indexterm>Entries in the <literal>/dev</literal> directory that are
      not links to the <literal>/devices</literal> directory are device nodes
      or special files created by <olink remap="external" targetdoc="819-2240"
      targetptr="mknod-1m"> <citerefentry>
          <refentrytitle>mknod</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> or <olink remap="external"
      targetdoc="819-2241" targetptr="mknod-2"> <citerefentry>
          <refentrytitle>mknod</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> </olink>. These are zero-length files that just have a
      major number and minor number attached to them. Linking to the physical
      name of the device in the <literal>/devices</literal> directory is
      preferred to using <citerefentry>
          <refentrytitle>mknod</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry>.</para>

      <para><indexterm xml:id="indexterm-68">
          <primary><literal>/devices</literal> directory</primary>
        </indexterm>Prior to the Solaris 10 OS, <literal>/devices</literal>
      was an on-disk filesystem composed of subdirectories and files.
      Beginning with the Solaris 10 OS, <literal>/devices</literal> is a
      virtual filesystem that creates these subdirectories and special files
      on demand.</para>

      <para><indexterm xml:id="indexterm-69">
          <primary><literal>devfs</literal> devices file system</primary>
        </indexterm> <indexterm xml:id="indexterm-70">
          <primary>devices</primary>

          <secondary>file system</secondary>

          <tertiary><literal>devfs</literal></tertiary>
        </indexterm>For more information about the devices file system, see
      the <olink remap="external" targetdoc="819-2254" targetptr="devfs-7fs">
      <citerefentry>
          <refentrytitle>devfs</refentrytitle>

          <manvolnum>7FS</manvolnum>
        </citerefentry> </olink> man page.</para>
    </sect2>

    <sect2 xml:id="eoqof">
      <title>Device Tree</title>

      <indexterm xml:id="indexterm-71">
        <primary>device tree</primary>
      </indexterm>

      <indexterm xml:id="indexterm-72">
        <primary>devices</primary>

        <secondary>device tree</secondary>
      </indexterm>

      <para>The device files in the <literal>/devices</literal> directory are
      also called the <emphasis>device tree</emphasis>.</para>

      <para><indexterm xml:id="indexterm-73">
          <primary>nexus device</primary>
        </indexterm> <indexterm xml:id="indexterm-74">
          <primary>devices</primary>

          <secondary>nexus</secondary>
        </indexterm>The device tree shows relationships among devices. In the
      device tree, a directory represents a <emphasis>nexus</emphasis> device.
      A nexus is a device that can be a parent of other devices. In the
      following example, <literal>pci@1f,0</literal> is a nexus device. Only
      selected output from the command is shown.</para>

      <screen># <userinput>ls -l /devices</userinput>
drwxr-xr-x   4 root     sys          512 <replaceable>date</replaceable> <replaceable>time</replaceable> pci@1f,0/
crw-------   1 root     sys      111,255 <replaceable>date</replaceable> <replaceable>time</replaceable> pci@1f,0:devctl</screen>

      <para><indexterm xml:id="indexterm-75">
          <primary><command>prtconf</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-76">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-77">
          <primary><command>prtpicl</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-78">
          <primary>commands</primary>

          <secondary><command>prtpicl</command></secondary>
        </indexterm>You can use <olink remap="external" targetdoc="819-2240"
      targetptr="prtconf-1m"> <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> or <olink remap="external"
      targetdoc="819-2240" targetptr="prtpicl-1m"> <citerefentry>
          <refentrytitle>prtpicl</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> to see a graphic representation of the device
      tree. See <olink remap="external" targetdoc="819-3196"
      targetptr="kernelovr-64300"> <citetitle remap="section">Overview of the
      Device Tree</citetitle> in <citetitle remap="book">Writing Device
      Drivers</citetitle> </olink> for more information about the device
      tree.</para>
    </sect2>

    <sect2 xml:id="fgoue">
      <title>Character and Block Devices</title>

      <indexterm xml:id="indexterm-79">
        <primary>character device</primary>
      </indexterm>

      <indexterm xml:id="indexterm-80">
        <primary>devices</primary>

        <secondary>character</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-81">
        <primary>block device</primary>
      </indexterm>

      <indexterm xml:id="indexterm-82">
        <primary>devices</primary>

        <secondary>block</secondary>
      </indexterm>

      <para>A file in the device tree that is not a directory represents
      either a <emphasis>character</emphasis> device or a
      <emphasis>block</emphasis> device.</para>

      <para><indexterm xml:id="indexterm-83">
          <primary><literal>/devices/pseudo</literal> directory</primary>
        </indexterm>A block device can contain addressable, reusable data. An
      example of a block device is a file system. Any device can be a
      character device. Most block devices also have character interfaces.
      Disks have both block and character interfaces. In your
      <filename>/devices/pseudo</filename> directory, you might find devices
      such as the following:</para>

      <programlisting>brw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,blk
crw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,raw
brw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,blk
crw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,raw
brw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,blk
crw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,raw</programlisting>

      <para><indexterm xml:id="indexterm-84">
          <primary><literal>blk</literal> device</primary>
        </indexterm> <indexterm xml:id="indexterm-85">
          <primary>devices</primary>

          <secondary><literal>blk</literal></secondary>
        </indexterm> <indexterm xml:id="indexterm-86">
          <primary><literal>raw</literal> device</primary>
        </indexterm> <indexterm xml:id="indexterm-87">
          <primary>devices</primary>

          <secondary><literal>raw</literal></secondary>
        </indexterm>Block devices have a <literal>b</literal> as the first
      character of their file mode. Character devices have a
      <literal>c</literal> as the first character of their file mode. In this
      example, the block devices have <literal>blk</literal> in their names
      and the character devices have <literal>raw</literal> in their
      names.</para>

      <para><indexterm xml:id="indexterm-88">
          <primary>metadevice</primary>
        </indexterm> <indexterm xml:id="indexterm-89">
          <primary>devices</primary>

          <secondary><literal>md</literal> metadevice</secondary>
        </indexterm>The <olink remap="external" targetdoc="819-2254"
      targetptr="md-7d"> <citerefentry>
          <refentrytitle>md</refentrytitle>

          <manvolnum>7D</manvolnum>
        </citerefentry> </olink> device is a metadevice that provides disk
      services. The block devices access the disk using the system's normal
      buffering mechanism. The character devices provide for direct
      transmission between the disk and the user's read or write
      buffer.</para>
    </sect2>

    <sect2 xml:id="fgovo">
      <title>Device Names</title>

      <indexterm xml:id="indexterm-90">
        <primary>devices</primary>

        <secondary>names</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-91">
        <primary>devices</primary>

        <secondary>directories</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-92">
        <primary><literal>/dev</literal> directory</primary>
      </indexterm>

      <indexterm xml:id="indexterm-93">
        <primary><command>devfsadmd</command> devices file system
        administration command</primary>
      </indexterm>

      <indexterm xml:id="indexterm-94">
        <primary>devices</primary>

        <secondary>file system</secondary>

        <tertiary><command>devfsadmd</command></tertiary>
      </indexterm>

      <para>This section shows a complex device name and explains the meaning
      of each part of the name in <filename>/dev</filename> and also in
      <filename>/devices</filename>. The following example is the name of a
      disk slice:</para>

      <screen>/dev/dsk/c0t0d0s7 -&gt; ../../devices/pci@1c,600000/scsi@2/sd@0,0:h</screen>

      <para>First, examine the name of the file in the
      <filename>/dev</filename> directory. These names are managed by the
      <olink remap="external" targetdoc="819-2240" targetptr="devfsadmd-1m">
      <citerefentry>
          <refentrytitle>devfsadmd</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> daemon.</para>

      <variablelist>
        <varlistentry>
          <term><literal>c0</literal></term>

          <listitem>
            <para>Controller 0</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>t0</literal></term>

          <listitem>
            <para>Target 0. On SCSI controllers, this value is the disk
            number.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>d0</literal></term>

          <listitem>
            <para>SCSI LUN. This value indicates a virtual partitioning of a
            target or single physical device.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>s7</literal></term>

          <listitem>
            <para>Slice 7 on the target 0 disk.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><indexterm xml:id="indexterm-95">
          <primary><literal>/devices</literal> directory</primary>
        </indexterm>For the same device, compare the name of the file in the
      <filename>/devices</filename> directory. These names show the physical
      structure and real device names. Note that some of the components of the
      device name in the <filename>/devices</filename> directory are
      subdirectories.</para>

      <variablelist>
        <varlistentry>
          <term><literal>pci@1c,600000</literal></term>

          <listitem>
            <para>PCI bus at address <literal>1c,600000</literal>. These
            addresses are meaningful only to the parent device.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>scsi@2</literal></term>

          <listitem>
            <para>SCSI controller at address <literal>2</literal> on the PCI
            bus at address <literal>1c,600000</literal>. This name corresponds
            to the <literal>c0</literal> in
            <filename>/dev/dsk/c0t0d0s7</filename>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sd@0,0</literal></term>

          <listitem>
            <para>SCSI disk at address <literal>0,0</literal> on the SCSI
            controller at address <literal>2</literal>. This name represents
            target 0, LUN 0 and corresponds to the <literal>t0d0</literal> in
            <filename>/dev/dsk/c0t0d0s7</filename>. The <literal>sd</literal>
            name and driver can also apply to IDE CD-ROM devices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sd@0,0:h</literal></term>

          <listitem>
            <para>Minor node <literal>h</literal> on the SCSI disk at address
            <literal>0,0</literal>. This name corresponds to the
            <literal>s7</literal> in
            <filename>/dev/dsk/c0t0d0s7</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="fgove">
      <title>Device Numbers</title>

      <indexterm xml:id="indexterm-96">
        <primary>device number</primary>
      </indexterm>

      <indexterm xml:id="indexterm-97">
        <primary>devices</primary>

        <secondary>numbers</secondary>
      </indexterm>

      <para>A <emphasis>device number</emphasis> identifies a particular
      device and minor node in the device tree. The <literal>dev_t</literal>
      parameter that is required in many DDI/DKI routines is this device
      number.</para>

      <para><indexterm xml:id="indexterm-98">
          <primary>major number</primary>
        </indexterm> <indexterm xml:id="indexterm-99">
          <primary>minor number</primary>
        </indexterm>Each device has a major number and a minor number. A
      device number is a
      <replaceable>major</replaceable>,<replaceable>minor</replaceable> pair.
      A long file listing shows the device number in the column where file
      sizes are usually listed. In the following example, the device number is
      86,255. The device major number is 86, and the device minor number is
      255.</para>

      <screen>% <userinput>ls -l /devices/pci@0,0:devctl</userinput>
crw-------   1 root     sys       86,255 <replaceable>date</replaceable> <replaceable>time</replaceable> /devices/pci@0,0:devctl</screen>

      <para>In the Solaris OS, the major number is chosen for you when you
      install the driver so that it will not conflict with any other major
      number. The kernel uses the major number to associate the I/O request
      with the correct driver code. The kernel uses this association to decide
      which driver to execute when the user reads or writes the device file.
      All devices and their major numbers are listed in the file
      <filename>/etc/name_to_major</filename>.</para>

      <screen>% <userinput>grep 86 /etc/name_to_major</userinput>
pci 86</screen>

      <para><indexterm xml:id="indexterm-100">
          <primary>instance number</primary>
        </indexterm> <indexterm xml:id="indexterm-101">
          <primary>devices</primary>

          <secondary>instances</secondary>
        </indexterm>The minor number is assigned in the driver. The minor
      number must map each driver to a specific device instance. Minor numbers
      usually refer to sub-devices. For example, a disk driver might
      communicate with a hardware controller device that has several disk
      drives attached. Minor nodes do not necessarily have a physical
      representation.</para>

      <para>The following example shows instances 0, 1, and 2 of the
      <literal>md</literal> device. The numbers 0, 1, and 2 are the minor
      numbers.</para>

      <programlisting>brw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,blk
crw-r-----   1 root     sys       85,  0 Nov  3 09:43 md@0:0,0,raw
brw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,blk
crw-r-----   1 root     sys       85,  1 Nov  3 09:43 md@0:0,1,raw
brw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,blk
crw-r-----   1 root     sys       85,  2 Nov  3 09:43 md@0:0,2,raw</programlisting>

      <para>In the name <filename>sd@0,0:h,</filename>, <literal>h</literal>
      represents a minor node. When the driver receives a request for minor
      node <literal>h</literal>, the driver actually receives a corresponding
      minor number. The driver for the <literal>sd</literal> node interprets
      that minor number to be a particular section of disk, such as slice 7
      mounted on <filename>/export</filename>.</para>

      <para><indexterm xml:id="indexterm-102">
          <primary><function>ddi_get_instance </function> kernel
          function</primary>
        </indexterm> <indexterm xml:id="indexterm-103">
          <primary>kernel functions</primary>

          <secondary><function>ddi_get_instance </function></secondary>
        </indexterm> <olink remap="external" targetdoc="chapter-2.xml"
      targetptr="eoqrt">Chapter 2, Template Driver Example</olink> shows how
      to use the <olink remap="external" targetdoc="819-2256"
      targetptr="ddi-get-instance-9f"> <citerefentry>
          <refentrytitle>ddi_get_instance</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> routine in your driver to get an instance
      number for the device you are driving.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="frymm">
    <title>Development Environment and Tools</title>

    <para>This section summarizes the driver development process and provides
    some pointers to resources. For more information on the development
    process, see <olink remap="external" targetdoc="819-3196"
    targetptr="fcaqh"> <citetitle remap="section">Driver Development
    Summary</citetitle> in <citetitle remap="book">Writing Device
    Drivers</citetitle> </olink>.</para>

    <para>Sun offers training courses in Solaris OS internals, crash dump
    analysis, writing device drivers, DTrace, Sun Studio, and other topics
    useful to Solaris developers. See <link
    xlink:href="http://www.sun.com/training/" xlink:type="url"
    xmlns:xlink="http://www.w3.org/1999/xlink"> </link> for more
    information.</para>

    <orderedlist>
      <para>The general steps in writing a device driver are as
      follows:</para>

      <listitem>
        <para>Write a <literal>.c</literal> source file using the interfaces
        and structures defined in man page sections <literal>9E</literal>,
        <literal>9F</literal>, and <literal>9S</literal>. Most of the include
        files you need are in <literal>/usr/include/sys</literal>. The
        function and structure man pages show which include files you
        need.</para>
      </listitem>

      <listitem>
        <para>Write a <literal>.conf</literal> hardware configuration file to
        define property values for your driver.</para>
      </listitem>

      <listitem>
        <para>Compile and link your driver. Always use the <option>
        D_KERNEL</option> option when you compile a driver for the Solaris OS.
        The default compile result is 32-bit. To get a 64-bit result on a
        64-bit platform, specify the appropriate 64-bit option as described in
        <olink remap="internal" targetdoc="chapter-1.xml"
        targetptr="fgouv">Building a Driver</olink>.</para>
      </listitem>

      <listitem>
        <para>Copy your driver binary file and your driver configuration file
        to the appropriate
        <filename>[<replaceable>platform</replaceable>]/kernel</filename>
        directories. See <olink remap="internal" targetdoc="chapter-1.xml"
        targetptr="fgomm">Driver Directory Organization</olink> for
        descriptions of driver directories.</para>
      </listitem>

      <listitem>
        <para>Use the <citerefentry>
            <refentrytitle>add_drv</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> command to load your driver. When your driver is
        loaded, you can see your driver in <filename>/dev</filename> and
        <filename>/devices</filename>. You can also see an entry for your
        driver in the <filename>/etc/name_to_major</filename> file.</para>
      </listitem>
    </orderedlist>

    <sect2 xml:id="fsujc">
      <title>Writing a Driver</title>

      <para>A driver consists of a C source file and a hardware configuration
      file.</para>

      <sect3 xml:id="ganag">
        <title>Writing a Driver Module</title>

        <para>The C code for a driver is a collection of data and functions
        that define a kernel module. As noted in <olink remap="internal"
        targetdoc="chapter-1.xml" targetptr="emqqh">Structural Differences
        Between Kernel Modules and User Programs</olink>, a driver has no
        <function>main </function> routine. Many of the subroutines of a
        driver are special functions called entry points. See <olink
        remap="internal" targetdoc="chapter-1.xml" targetptr="emjjs">Device
        Drivers</olink> for information about entry points.</para>

        <para>The function man pages provide both the function declaration
        that you need in your driver and the list of header files you need to
        include. Make sure you consult the correct man page. For example, the
        following command displays the <command>ioctl</command>(2) man page.
        The <command>ioctl</command>(2) system call cannot be used in a device
        driver.</para>

        <screen>% <userinput>man ioctl</userinput>
</screen>

        <para>Use one of the following commands to display the
        <command>ioctl</command>(9E) man page. The
        <command>ioctl</command>(9E) subroutine is a device driver entry
        point.</para>

        <screen>% <userinput>man ioctl.9e</userinput>
% <userinput>man -s 9e ioctl</userinput>
</screen>

        <para><indexterm xml:id="indexterm-104">
            <primary>prefixes</primary>
          </indexterm> <indexterm xml:id="indexterm-105">
            <primary>devices</primary>

            <secondary>prefixes</secondary>
          </indexterm>By convention, the names of functions and data that are
        unique to this driver begin with a common prefix. The prefix is the
        name of this driver or an abbreviation of the name of this driver. Use
        the same prefix for all names that are specific to this driver. This
        practice makes debugging much easier. Instead of seeing an error
        related to an ambiguous <function>attach </function> function, you see
        an error message about <function>mydriver_attach </function> or
        <function>newdriver_attach </function>.</para>

        <para><indexterm xml:id="indexterm-106">
            <primary>data model</primary>

            <secondary>converting</secondary>
          </indexterm> <indexterm xml:id="indexterm-107">
            <primary><function>ddi_model_convert_from </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-108">
            <primary>kernel functions</primary>

            <secondary><function>ddi_model_convert_from
            </function></secondary>
          </indexterm>A 64-bit system can run both 32-bit user programs and
        64-bit user programs. A 64-bit system runs 32-bit programs by
        converting all data needed between the two data models. A 64-bit
        kernel supports both 64-bit and 32-bit user data. Whenever a 64-bit
        driver copies data between kernel space and user space, the driver
        must use the <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-model-convert-from-9f"> <citerefentry>
            <refentrytitle>ddi_model_convert_from</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function to determine whether the data must
        be converted between 32-bit and 64-bit models. For an example, see
        <olink remap="external" targetdoc="chapter-3.xml"
        targetptr="fgham">Reporting and Setting Device Size and
        Re-initializing the Device</olink>.</para>

        <para>The Sun Studio IDE includes the following three source editors:
        GVIM, XEmacs, and the built-in Source Editor provided by NetBeans. The
        IDE provides online help for these tools. You can also run GVIM and
        XEmacs from the command line. See <command>vim</command>(1) and
        <command>xemacs</command>(1).</para>

        <itemizedlist>
          <para>For more information, see the following resources:</para>

          <listitem>
            <para>For more information about writing device drivers, see
            <olink remap="external" targetdoc="chapter-4.xml"
            targetptr="fdlbn">Device Driver Coding Tips</olink> and <olink
            remap="external" targetdoc="819-3196"> <citetitle
            remap="book">Writing Device Drivers</citetitle> </olink>.</para>
          </listitem>

          <listitem>
            <para>For simple example source files, see <olink remap="external"
            targetdoc="chapter-2.xml" targetptr="eoqrt">Chapter 2, Template
            Driver Example</olink> and <olink remap="external"
            targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
            Writing Data in Kernel Memory</olink>.</para>
          </listitem>

          <listitem>
            <para>For production driver sources, go to <link
            xlink:href="http://www.opensolaris.org/" xlink:type="url"
            xmlns:xlink="http://www.w3.org/1999/xlink"> </link> and click
            “Source Browser.”</para>
          </listitem>

          <listitem>
            <para>For more driver source and documentation, go to the driver
            development OpenSolaris community at <link
            xlink:href="http://www.opensolaris.org/os/community/device_drivers/"
            xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
            </link> and the Solaris OS driver development site on the Sun
            Developer Network (SDN) at <link
            xlink:href="http://developers.sun.com/solaris/driverdev/"
            xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
            </link>.</para>
          </listitem>

          <listitem>
            <para>For advice and examples on a wide variety of driver topics,
            see the Driver Development <link
            xlink:href="http://developers.sun.com/solaris/developer/support/driver/faqs.html"
            xlink:type="text"
            xmlns:xlink="http://www.w3.org/1999/xlink">FAQ</link> (Frequently
            Asked Questions).</para>
          </listitem>

          <listitem>
            <para>For more help, search the Driver Development Solaris forum
            at <link
            xlink:href="http://forum.sun.com/jive/forum.jspa?forumID=294"
            xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
            </link> or the Kernel forum at <link
            xlink:href="http://forum.sun.com/jive/forum.jspa?forumID=293"
            xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
            </link>. See all the Solaris forums at <link
            xlink:href="http://forum.sun.com/jive/index.jspa?tab=solaris"
            xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
            </link>.</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3 xml:id="ganar">
        <title>Writing a Configuration File</title>

        <para><indexterm xml:id="indexterm-109">
            <primary>configuration files</primary>
          </indexterm> <indexterm xml:id="indexterm-110">
            <primary>devices</primary>

            <secondary>properties</secondary>
          </indexterm> <indexterm xml:id="indexterm-111">
            <primary>devices</primary>

            <secondary>configuration files</secondary>
          </indexterm> <indexterm xml:id="indexterm-112">
            <primary><function>ddi_prop_get_int </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-113">
            <primary>kernel functions</primary>

            <secondary><function>ddi_prop_get_int </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-114">
            <primary><function>ddi_prop_lookup </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-115">
            <primary>kernel functions</primary>

            <secondary><function>ddi_prop_lookup </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-116">
            <primary><literal>driver.conf</literal> file</primary>
          </indexterm> <indexterm xml:id="indexterm-117">
            <primary>files</primary>

            <secondary><literal>driver.conf</literal></secondary>
          </indexterm>A driver that is not self-identifying must have a
        configuration file named <replaceable>node_name</replaceable>
        <literal>.conf</literal>, where <replaceable>node_name</replaceable>
        is the prefix for the device. A self-identifying driver is a driver
        that can obtain all the property information it needs from the DDI
        property interfaces such as <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-prop-get-int-9f"> <citerefentry>
            <refentrytitle>ddi_prop_get_int</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> and <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-prop-lookup-9f"> <citerefentry>
            <refentrytitle>ddi_prop_lookup</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. The minimum information that a
        configuration file must contain is the name of the device node and the
        name or type of the device's parent.</para>

        <para>For more information about device driver configuration files,
        see the <olink remap="external" targetdoc="819-2251"
        targetptr="driver.conf-4"> <citerefentry>
            <refentrytitle>driver.conf</refentrytitle>

            <manvolnum>4</manvolnum>
          </citerefentry> </olink> man page. For an example configuration
        file, see <olink remap="external" targetdoc="chapter-2.xml"
        targetptr="eoxzw">Writing the Device Configuration
        File</olink>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="fgouv">
      <title>Building a Driver</title>

      <para><indexterm xml:id="indexterm-118">
          <primary>device drivers</primary>

          <secondary>compiling</secondary>
        </indexterm> <indexterm xml:id="indexterm-119">
          <primary>compiling</primary>
        </indexterm> <indexterm xml:id="indexterm-120">
          <primary>SPARC</primary>

          <secondary>compiling</secondary>
        </indexterm> <indexterm xml:id="indexterm-121">
          <primary>x86</primary>

          <secondary>compiling</secondary>
        </indexterm> <indexterm xml:id="indexterm-122">
          <primary>device drivers</primary>

          <secondary>linking</secondary>
        </indexterm> <indexterm xml:id="indexterm-123">
          <primary>linking</primary>
        </indexterm> <indexterm xml:id="indexterm-124">
          <primary>path environment variable</primary>
        </indexterm>This section tells you how to compile and link a driver
      for different architectures.</para>

      <para>Make sure you have installed the Solaris OS at the Developer level
      or above. Follow the instructions in <olink remap="external"
      targetdoc="819-2393" targetptr="webstart-91">Chapter 2, <citetitle
      remap="chapter">Installing With the Solaris Installation Program
      (Tasks),</citetitle> in <citetitle remap="book">Solaris Express
      Installation Guide: Basic Installations</citetitle> </olink>. Select
      Custom Install, and select the Developer cluster or above.</para>

      <para>In your path environment variable, include
      <filename>/opt/SUNWspro/bin</filename> followed by
      <filename>/usr/ccs/bin</filename>.</para>

      <para>A 64-bit kernel cannot use a 32-bit driver. A 64-bit kernel can
      use only 64-bit drivers. All parts of any particular program must use
      the same data model. A device driver is not a complete program. The
      kernel is a complete program. A driver is a part of the kernel program.
      If you want your device to work with the Solaris OS in 32-bit mode and
      with the Solaris OS in 64-bit mode, then you must provide both a 32-bit
      driver and a 64-bit driver.</para>

      <para>By default, compilation on the Solaris OS yields a 32-bit result
      on every architecture. To obtain a 64-bit result, use the compilation
      options specified in this section for 64-bit architectures.</para>

      <para><indexterm xml:id="indexterm-125">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-126">
          <primary><command>prtconf</command> command</primary>
        </indexterm>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="prtconf-1m"> <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command with the <option> x</option> option
      to determine whether the firmware on this system is 64-bit ready.</para>

      <sect3 xml:id="gamyf">
        <title>Compiling with Sun Studio</title>

        <indexterm xml:id="indexterm-127">
          <primary>Sun Studio</primary>
        </indexterm>

        <indexterm xml:id="indexterm-128">
          <primary>commands</primary>

          <secondary><command>cc</command></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-129">
          <primary><command>cc</command> command</primary>
        </indexterm>

        <indexterm xml:id="indexterm-130">
          <primary>commands</primary>

          <secondary><command>ld</command></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-131">
          <primary><command>ld</command> command</primary>
        </indexterm>

        <itemizedlist>
          <para>Use the <option> D_KERNEL</option> option to indicate that
          this code defines a kernel module.</para>

          <listitem>
            <para>If you are compiling for a 64-bit SPARC architecture, use
            the <option> xarch=v9</option> option:</para>

            <screen>% <userinput>cc -D_KERNEL -xarch=v9 -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>

          <listitem>
            <para>If you are compiling for a 64-bit x86 architecture, use both
            the <option> xarch=amd64</option> option and the <option>
            xmodel=kernel</option> option:</para>

            <screen>% <userinput>cc -D_KERNEL -xarch=amd64 -xmodel=kernel -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>

          <listitem>
            <para>If you are compiling for a 32-bit architecture, use the
            following build commands:</para>

            <screen>% <userinput>cc -D_KERNEL -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>
        </itemizedlist>

        <para>For more information on compile and link options, see the <olink
        remap="external" targetdoc="819-2239" targetptr="as-1"> <citerefentry>
            <refentrytitle>as</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2239" targetptr="cc-1b"> <citerefentry>
            <refentrytitle>cc</refentrytitle>

            <manvolnum>1B</manvolnum>
          </citerefentry> </olink>, and <olink remap="external"
        targetdoc="819-2239" targetptr="ld-1"> <citerefentry>
            <refentrytitle>ld</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink> man pages. See also the <olink
        remap="external" targetdoc="819-3688"> <citetitle remap="book">Sun
        Studio 11: C User’s Guide</citetitle> </olink>. Click <citetitle>Sun
        Studio 11 Collection</citetitle> at the top left of this page to see
        Sun Studio books about <command>dbx</command>,
        <command>dmake</command>, Performance Analyzer, and other software
        development topics. To read technical articles about Sun Studio or to
        download Sun Studio, go to <link
        xlink:href="http://developers.sun.com/sunstudio/" xlink:type="url"
        xmlns:xlink="http://www.w3.org/1999/xlink"> </link>.</para>

        <note>
          <para>Sun Studio 9 does not support 64-bit x86 architectures. Use
          Sun Studio 10 or Sun Studio 11 to compile and debug drivers for
          64-bit x86 architectures.</para>
        </note>
      </sect3>

      <sect3 xml:id="gamzm">
        <title>Compiling with the GNU C Compiler</title>

        <indexterm xml:id="indexterm-132">
          <primary>GNU C</primary>
        </indexterm>

        <indexterm xml:id="indexterm-133">
          <primary>commands</primary>

          <secondary><command>gcc</command></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-134">
          <primary><command>gcc</command> command</primary>
        </indexterm>

        <para>To get the GNU C compiler, you must install the Solaris OS at
        the Developer level or above. Follow the instructions in <olink
        remap="external" targetdoc="819-2393" targetptr="webstart-91">Chapter
        2, <citetitle remap="chapter">Installing With the Solaris Installation
        Program (Tasks),</citetitle> in <citetitle remap="book">Solaris
        Express Installation Guide: Basic Installations</citetitle> </olink>.
        Select Custom Install, and select the Developer cluster or above. The
        GNU C compiler is installed in <filename>/usr/sfw</filename>.</para>

        <itemizedlist>
          <para>Use the <option> D_KERNEL</option> option to indicate that
          this code defines a kernel module. These examples show options that
          are required for correct functionality of the result.</para>

          <listitem>
            <para>If you are compiling for a 64-bit SPARC architecture, use
            the following build commands:</para>

            <screen>% <userinput>gcc -D_KERNEL -m64 -mcpu=v9 -mcmodel=medlow -fno-pic -mno-fpu
-ffreestanding -nodefaultlibs -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>

            <para>You might also want to use the <option>
            mtune=ultrasparc</option> option and the <option> O2</option>
            option.</para>
          </listitem>

          <listitem>
            <para>If you are compiling for a 64-bit x86 architecture, use the
            following build commands:</para>

            <screen>% <userinput>gcc -D_KERNEL -m64 -mcmodel=kernel -mno-red-zone -ffreestanding
-nodefaultlibs -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>

            <para>You might also want to use the <option>
            mtune=opteron</option> option and the <option> O2</option>
            option.</para>
          </listitem>

          <listitem>
            <para>If you are compiling for a 32-bit architecture, use the
            following build commands:</para>

            <screen>% <userinput>gcc -D_KERNEL -ffreestanding -nodefaultlibs -c mydriver.c</userinput>
% <userinput>/usr/ccs/bin/ld -r -o mydriver mydriver.o</userinput>
</screen>
          </listitem>
        </itemizedlist>

        <para>For more information on these and other options, see the
        <command>gcc</command>(1) man page. See also the GCC web site at <link
        xlink:href="http://gcc.gnu.org/" xlink:type="url"
        xmlns:xlink="http://www.w3.org/1999/xlink"> </link>. More information
        about using the <command>gcc</command> compiler with the Solaris OS is
        on the OpenSolaris web site at <link
        xlink:href="http://opensolaris.org/os/community/tools/gcc/"
        xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
        </link>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="fsfqv">
      <title>Installing a Driver</title>

      <indexterm xml:id="indexterm-135">
        <primary>device drivers</primary>

        <secondary>installing</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-136">
        <primary>entry points</primary>

        <secondary><function>_info </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-137">
        <primary><function>_info </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-138">
        <primary>entry points</primary>

        <secondary><function>_init </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-139">
        <primary><function>_init </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-140">
        <primary>entry points</primary>

        <secondary><function>attach </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-141">
        <primary><function>attach </function> entry point</primary>
      </indexterm>

      <para>After you write and build your driver, you must install the driver
      binary. To install a driver, copy the driver binary and the
      configuration file to the appropriate <filename>/kernel/drv</filename>
      directory.</para>

      <para>Make sure you are user <literal>root</literal> when you install a
      driver.</para>

      <para>Copy the configuration file to the kernel driver area of the
      system.</para>

      <screen># <userinput>cp mydriver.conf /usr/kernel/drv</userinput>
</screen>

      <para>Install drivers in the <filename>/tmp</filename> directory until
      you are finished modifying and testing the <function>_info </function>,
      <function>_init </function>, and <function>attach </function> routines.
      See <olink remap="external" targetdoc="chapter-4.xml"
      targetptr="fdlbq">Device Driver Testing Tips</olink> for more
      information.</para>

      <para>Copy the driver binary to the <filename>/tmp</filename>
      directory.</para>

      <screen># <userinput>cp mydriver /tmp</userinput>
</screen>

      <itemizedlist>
        <para>Link to the driver from the kernel driver directory.</para>

        <listitem>
          <para>On a 64-bit SPARC architecture, link to the
          <filename>sparcv9</filename> directory:</para>

          <screen># <userinput>ln -s /tmp/mydriver /usr/kernel/drv/sparcv9/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 64-bit x86 architecture, link to the
          <filename>amd64</filename> directory:</para>

          <screen># <userinput>ln -s /tmp/mydriver /usr/kernel/drv/amd64/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 32-bit architecture, create the link as follows:</para>

          <screen># <userinput>ln -s /tmp/mydriver /usr/kernel/drv/mydriver</userinput>
</screen>
        </listitem>
      </itemizedlist>

      <para>When the driver is well tested, copy the driver directly to the
      appropriate kernel driver area of the system.</para>

      <itemizedlist>
        <listitem>
          <para>On a 64-bit SPARC architecture, copy the driver to the
          <filename>sparcv9</filename> directory:</para>

          <screen># <userinput>cp mydriver /usr/kernel/drv/sparcv9/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 64-bit x86 architecture, copy the driver to the
          <filename>amd64</filename> directory:</para>

          <screen># <userinput>cp mydriver /usr/kernel/drv/amd64/mydriver</userinput>
</screen>
        </listitem>

        <listitem>
          <para>On a 32-bit architecture, copy the driver to the kernel driver
          area of the system:</para>

          <screen># <userinput>cp mydriver /usr/kernel/drv/mydriver</userinput>
</screen>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="fsujf">
      <title>Adding, Updating, and Removing a Driver</title>

      <indexterm xml:id="indexterm-142">
        <primary>device drivers</primary>

        <secondary>adding</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-143">
        <primary>commands</primary>

        <secondary><command>add_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-144">
        <primary><command>add_drv</command> command</primary>
      </indexterm>

      <para>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="add-drv-1m"> <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to make the installed driver usable.
      Be sure you are user <literal>root</literal> when you use the
      <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command.</para>

      <screen># <userinput>add_drv mydriver</userinput>
</screen>

      <itemizedlist>
        <para>The following events take place when you add a driver:</para>

        <listitem>
          <para>The <citerefentry>
              <refentrytitle>_info</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, and <citerefentry>
              <refentrytitle>attach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> entry points are called in that order.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-145">
              <primary><literal>/devices</literal> directory</primary>
            </indexterm>The driver is added to the
          <filename>/devices</filename> directory.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-146">
              <primary>commands</primary>

              <secondary><command>modinfo</command></secondary>
            </indexterm> <indexterm xml:id="indexterm-147">
              <primary><command>modinfo</command> command</primary>
            </indexterm>The driver is the most recent module listed by <olink
          remap="external" targetdoc="819-2240" targetptr="modinfo-1m">
          <citerefentry>
              <refentrytitle>modinfo</refentrytitle>

              <manvolnum>1M</manvolnum>
            </citerefentry> </olink>.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-148">
              <primary>files</primary>

              <secondary><filename>/etc/name_to_major</filename></secondary>
            </indexterm> <indexterm xml:id="indexterm-149">
              <primary><filename>/etc/name_to_major</filename> file</primary>
            </indexterm>The driver is the most recent module listed in the
          file <filename>/etc/name_to_major</filename>.</para>
        </listitem>
      </itemizedlist>

      <para><indexterm xml:id="indexterm-150">
          <primary><literal>/etc/driver_aliases</literal> file</primary>
        </indexterm>The file <filename>/etc/driver_aliases</filename> might be
      updated. The <filename>/etc/driver_aliases</filename> file shows which
      devices are bound to which drivers. If a driver is not listed in the
      <filename>/etc/driver_aliases</filename> file, then the Solaris OS does
      not load that driver or attach to that driver. Each line of the
      <filename>/etc/driver_aliases</filename> file shows a driver name
      followed by a device name. You can search this file to determine which
      driver is managing your device.</para>

      <note>
        <para>Do not edit the <filename>/etc/driver_aliases</filename> file
        manually. Use the <citerefentry>
            <refentrytitle>add_drv</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> command to establish a device binding. Use the
        <citerefentry>
            <refentrytitle>update_drv</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> command to change a device binding.</para>
      </note>

      <para><indexterm xml:id="indexterm-151">
          <primary>PCI ID numbers</primary>
        </indexterm>The example drivers shown in this book manage pseudo
      devices. If your driver manages real hardware, then you need to use the
      <option> c</option> and <option> i</option> options on the <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command or the <option> i</option> option on the
      <citerefentry>
          <refentrytitle>update_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command. To specify a device class or device ID, you
      might find the following sites useful. This information also is useful
      to search the <filename>/etc/driver_aliases</filename> file to find out
      whether a device already is supported.</para>

      <itemizedlist>
        <listitem>
          <para>List of devices currently supported by the Solaris OS: <link
          xlink:href="http://www.sun.com/bigadmin/hcl/driverlist.html"
          xlink:type="url" xmlns:xlink="http://www.w3.org/1999/xlink">
          </link></para>
        </listitem>

        <listitem>
          <para>Searchable PCI vendor and device lists: <link
          xlink:href="http://www.pcidatabase.com/" xlink:type="url"
          xmlns:xlink="http://www.w3.org/1999/xlink"> </link></para>
        </listitem>

        <listitem>
          <para>Repository of vendor IDs, device IDs, subsystems, and device
          classes used in PCI devices: <link
          xlink:href="http://pciids.sourceforge.net/" xlink:type="url"
          xmlns:xlink="http://www.w3.org/1999/xlink"> </link></para>
        </listitem>
      </itemizedlist>

      <para><indexterm xml:id="indexterm-152">
          <primary>device drivers</primary>

          <secondary>updating</secondary>
        </indexterm> <indexterm xml:id="indexterm-153">
          <primary>commands</primary>

          <secondary><command>update_drv</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-154">
          <primary><command>update_drv</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-155">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-156">
          <primary><command>prtconf</command> command</primary>
        </indexterm>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="update-drv-1m"> <citerefentry>
          <refentrytitle>update_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to notify the system about attribute
      changes to an installed device driver. By default, the <citerefentry>
          <refentrytitle>update_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command reloads the hardware configuration file for
      the specified driver. Use the <olink remap="external"
      targetdoc="819-2240" targetptr="prtconf-1m"> <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to review the current configuration
      information for a device and driver. For example, the <option>
      D</option> option shows which driver manages a particular device. The
      <option> P</option> option shows information about pseudo
      devices.</para>

      <para><indexterm xml:id="indexterm-157">
          <primary>device drivers</primary>

          <secondary>removing</secondary>
        </indexterm> <indexterm xml:id="indexterm-158">
          <primary>commands</primary>

          <secondary><command>rem_drv</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-159">
          <primary><command>rem_drv</command> command</primary>
        </indexterm>Use the <olink remap="external" targetdoc="819-2240"
      targetptr="rem-drv-1m"> <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to update the system driver
      configuration files so that the driver is no longer usable. The
      <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command does not physically delete driver files. If
      possible, the <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> command unloads the driver from memory.</para>
    </sect2>

    <sect2 xml:id="ganoc">
      <title>Loading and Unloading a Driver</title>

      <indexterm xml:id="indexterm-160">
        <primary>device drivers</primary>

        <secondary>loading</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-161">
        <primary>device drivers</primary>

        <secondary>unloading</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-162">
        <primary>commands</primary>

        <secondary><command>rem_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-163">
        <primary><command>rem_drv</command> command</primary>
      </indexterm>

      <para>A driver is loaded into memory when a device that the driver
      manages is accessed. A driver might be unloaded from memory when the
      driver is not being used. Normally, you do not need to load a driver
      into memory manually or unload a driver from memory manually.</para>

      <para>To manually load a loadable module into memory, use the <olink
      remap="external" targetdoc="819-2240" targetptr="modload-1m">
      <citerefentry>
          <refentrytitle>modload</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command.</para>

      <para>While you are developing your driver, you might want to manually
      unload the driver and then update the driver. To manually unload a
      loadable module from memory, use the <olink remap="external"
      targetdoc="819-2240" targetptr="modunload-1m"> <citerefentry>
          <refentrytitle>modunload</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command.</para>
    </sect2>

    <sect2 xml:id="fsujg">
      <title>Testing a Driver</title>

      <itemizedlist>
        <para><indexterm xml:id="indexterm-164">
            <primary>device drivers</primary>

            <secondary>test areas</secondary>
          </indexterm>Drivers should be thoroughly tested in the following
        areas:</para>

        <listitem>
          <para>Configuration</para>
        </listitem>

        <listitem>
          <para>Functionality</para>
        </listitem>

        <listitem>
          <para>Error handling</para>
        </listitem>

        <listitem>
          <para>Loading, unloading, and removing</para>

          <para>All drivers will need to be removed eventually. Make sure that
          your driver can be successfully removed.</para>
        </listitem>

        <listitem>
          <para>Stress, performance, and interoperability</para>
        </listitem>

        <listitem>
          <para>DDI/DKI compliance</para>
        </listitem>

        <listitem>
          <para>Installation and packaging</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <para>For detailed information on how to test your driver and how to
        avoid problems during testing, see the following references:</para>

        <listitem>
          <para><olink remap="external" targetdoc="chapter-4.xml"
          targetptr="fdlbq">Device Driver Testing Tips</olink></para>
        </listitem>

        <listitem>
          <para><olink remap="external" targetdoc="819-3196"
          targetptr="loading-17"> <citetitle remap="section">Criteria for
          Testing Drivers</citetitle> in <citetitle remap="book">Writing
          Device Drivers</citetitle> </olink></para>
        </listitem>

        <listitem>
          <para><olink remap="external" targetdoc="819-3196"
          targetptr="debug-60">Chapter 21, <citetitle
          remap="chapter">Debugging, Testing, and Tuning Device
          Drivers,</citetitle> in <citetitle remap="book">Writing Device
          Drivers</citetitle> </olink></para>
        </listitem>
      </itemizedlist>

      <para>Additional testing is specific to the type of driver.</para>
    </sect2>
  </sect1>
</chapter>