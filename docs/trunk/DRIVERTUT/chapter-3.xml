<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN"
"docbook.dtd" [
<!ENTITY % xinclude SYSTEM "xinclude.mod">
%xinclude;
]>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook" xml:id="faatl">
  <title>Reading and Writing Data in Kernel Memory</title>

  <toc>
    <para>W tym rozdziale bardzo prosty sterownik napisany wcześniej zostanie
    nieco urozmaicony. Pod koniec tego rozdziału sterownik będzie drukował
    dane odczytane z pamięci jądra. Pierwsza wersja sterownika zapisywała
    komunikaty do dziennika systemowego za każdym razem, gdy sterownik jest
    ładowany. Druga wersja sterownika drukuje dane na żądanie użytkownika. W
    trzeciej wersji użytkownik będzie mógł również zapisaywać dane do
    urządzenia.</para>
  </toc>

  <sect1 xml:id="fahrt">
    <title>Displaying Data Stored in Kernel Memory</title>

    <para>Poniższy pseudosterownik zapisuje stały łańcuch znaków do dziennika
    systemowego za każdym razem, gdy sterownik jest ładowany.</para>

    <para>Pierwsza wersja sterownika Cytat Dnia (ang. Quote Of The Day -
    <literal>qotd_1</literal>) jest nawet prostsza od sterownika
    <literal>dummy</literal> z poprzedniego rozdziału. Sterownik
    <literal>dummy</literal> zawiera wszystkie funkcje wymagane do obsługi
    sprzętu. Sterownik <literal>qotd_1</literal> zawiera tylko najbardziej
    niezbędne funkcje wymagane do udostępnienia łańcucha znakowego
    użytkownikowi. Sterownik <literal>qotd_1</literal> nie definiuje na
    przykłąd struktury <citerefentry>
        <refentrytitle>cb_ops</refentrytitle>

        <manvolnum>9S</manvolnum>
      </citerefentry>, stąd też sterownik nie definiuje funkcji <citerefentry>
        <refentrytitle>open</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry>, <citerefentry>
        <refentrytitle>close</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry>, <citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry> i <citerefentry>
        <refentrytitle>write</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry>. Również w strukturze <olink remap="external"
    targetdoc="819-2257" targetptr="dev-ops-9s"> <citerefentry>
        <refentrytitle>dev_ops</refentrytitle>

        <manvolnum>9S</manvolnum>
      </citerefentry> </olink> sterownika <literal>qotd_1</literal> nie ma
    funkcji <citerefentry>
        <refentrytitle>getinfo</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry>, <citerefentry>
        <refentrytitle>attach</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry> i <citerefentry>
        <refentrytitle>detach</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry>. Sterownik nie deklaruje funkcji, ponieważ wszystkie
    funkcje w nim definiowane zadeklarowane są w pliku nagłówkowym
    <filename>modctl.h</filename>. Wystarczy więc włączyć plik
    <filename>modctl.h</filename> do pliku
    <filename>qotd_1.c</filename>.</para>

    <para><indexterm xml:id="indexterm-335">
        <primary><function>cmn_err </function> kernel function</primary>
      </indexterm> <indexterm xml:id="indexterm-336">
        <primary>kernel functions</primary>

        <secondary><function>cmn_err </function></secondary>
      </indexterm>Sterownik <literal>qotd_1</literal> definiuje zmienną
    globalną do przetrzymywania danych tekstowych. Punkt wejścia <olink
    remap="external" targetdoc="819-2255" targetptr="u-init-9e"> <citerefentry>
        <refentrytitle>_init</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry> </olink> sterownika używa do zapisywania łańcucha w
    dzienniku systemowym funkcji <olink remap="external" targetdoc="819-2256"
    targetptr="cmn-err-9f"> <citerefentry>
        <refentrytitle>cmn_err</refentrytitle>

        <manvolnum>9F</manvolnum>
      </citerefentry> </olink>. Również sterownik <literal>dummy</literal>
    używał tej funkcji <citerefentry>
        <refentrytitle>cmn_err</refentrytitle>

        <manvolnum>9F</manvolnum>
      </citerefentry>. Sterownik <literal>qotd_1</literal> różni się do
    sterownika <literal>dummy</literal> tym, że przechowuje łańcuch znakowy w
    pamięci jądra.</para>

    <sect2 xml:id="fcajm">
      <title>Writing Quote Of The Day Version 1</title>

      <para>Poniższy kod źródłowy należy zapisać w pliku
      <filename>qotd_1.c</filename>.</para>

      <example xml:id="fcajp">
        <title>Quote Of The Day Version 1 Source File</title>

        <programlisting>#include &lt;sys/modctl.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/devops.h&gt;
#include &lt;sys/cmn_err.h&gt;
#include &lt;sys/ddi.h&gt;
#include &lt;sys/sunddi.h&gt;

#define QOTD_MAXLEN     128

static const char qotd[QOTD_MAXLEN]
        = "Be careful about reading health books. \
You may die of a misprint. - Mark Twain\n";

static struct dev_ops qotd_dev_ops = {
        DEVO_REV,               /* devo_rev */
        0,                      /* devo_refcnt */
        ddi_no_info,            /* devo_getinfo */
        nulldev,                /* devo_identify */
        nulldev,                /* devo_probe */
        nulldev,                /* devo_attach */
        nulldev,                /* devo_detach */
        nodev,                  /* devo_reset */
        (struct cb_ops *)NULL,  /* devo_cb_ops */
        (struct bus_ops *)NULL, /* devo_bus_ops */
        nulldev                 /* devo_power */
};

static struct modldrv modldrv = {
        &amp;mod_driverops,
        "Quote of the Day 1.0",
        &amp;qotd_dev_ops};

static struct modlinkage modlinkage = {
        MODREV_1,
        (void *)&amp;modldrv,
        NULL
};

int
_init(void)
{
        cmn_err(CE_CONT, "QOTD: %s\n", qotd);
        return (mod_install(&amp;modlinkage));
}

int
_info(struct modinfo *modinfop)
{
        return (mod_info(&amp;modlinkage, modinfop));
}
int
_fini(void)
{
        return (mod_remove(&amp;modlinkage));
}</programlisting>
      </example>

      <para>Poniższe dane konfiguracyjne należy umieścić w pliku
      <filename>qotd_1.conf</filename>.</para>

      <example xml:id="fcajq">
        <title>Quote Of The Day Version 1 Configuration File</title>

        <programlisting>name="qotd_1" parent="pseudo" instance=0;</programlisting>
      </example>
    </sect2>

    <sect2 xml:id="fcajo">
      <title>Building, Installing, and Using Quote Of The Day
      Version 1</title>

      <para>Aby skompilować i skonsolidować sterownik należy użyć opcji
      <option>D_KERNEL</option> wskazującej, że kod definiuje moduł jądra.
      Poniższy przykład demonstruje kompilację dla 32bitowej platformy za
      pomocą kompilatora Sun Studio C:</para>

      <screen>% <userinput>cc -D_KERNEL -c qotd_1.c</userinput>
% <userinput>ld -r -o qotd_1 qotd_1.o</userinput>
</screen>

      <para>Nazwa sterownika <literal>qotd_1</literal> musi być identyczna z
      właściwością <literal>name</literal> z pliku konfiguracyjnego.</para>

      <para>Do instalacji wymagany jest użytkownik
      <literal>root</literal>.</para>

      <para>Plik binarny sterownika należy skopiować do katalogu
      <filename>/tmp</filename>, jak w <olink remap="external"
      targetdoc="chapter-4.xml" targetptr="fdlbq">Device Driver Testing
      Tips</olink>.</para>

      <screen># <userinput>cp qotd_1 /tmp</userinput>
# <userinput>ln -s /tmp/qotd_1 /usr/kernel/drv/qotd_1</userinput>
</screen>

      <para>Plik konfiguracyjny należy skopiować do katalogu sterowników
      jądra.</para>

      <screen># <userinput>cp qotd_1.conf /usr/kernel/drv</userinput>
</screen>

      <para><indexterm xml:id="indexterm-337">
          <primary>files</primary>

          <secondary><filename>/var/adm/messages</filename></secondary>
        </indexterm> <indexterm xml:id="indexterm-338">
          <primary><filename>/var/adm/messages</filename> file</primary>
        </indexterm> <indexterm xml:id="indexterm-339">
          <primary>commands</primary>

          <secondary><command>syslogd</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-340">
          <primary><command>syslogd</command> command</primary>
        </indexterm>Sterownik <literal>qotd_1</literal> zapisuje komunikat do
      dziennika systemowego za każdym razem, gdy sterownik jest ładowany.
      Funkcja <olink remap="external" targetdoc="819-2256"
      targetptr="cmn-err-9f"> <citerefentry>
          <refentrytitle>cmn_err</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> zapisuje komunikaty o niskim priorytecie do
      <filename>/dev/log</filename>, a daemon <olink remap="external"
      targetdoc="819-2240" targetptr="syslogd-1m"> <citerefentry>
          <refentrytitle>syslogd</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> odczytuje je i zapisuje do
      <filename>/var/adm/messages</filename>.</para>

      <para>Testowanie sterownika polega na obserowaniu komunikatów
      zapisywanych w <literal>/var/adm/messages</literal>. W osobnym oknie
      należy wykonać poniższą komendę:</para>

      <screen>% <userinput>tail -f /var/adm/messages</userinput>
</screen>

      <para>Podczas dodawania sterownika należy być zalogowany jako użytkownik
      <literal>root</literal>. Sterownik dodaje się komendą <olink
      remap="external" targetdoc="819-2240" targetptr="add-drv-1m">
      <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>:</para>

      <screen># <userinput>add_drv qotd_1</userinput>
</screen>

      <para>W wiadomościach zapisywanych do
      <filename>/var/adm/messages</filename> powinny pojawić się następujące
      komunikaty:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> pseudo: [ID 129642 kern.info] pseudo-device: devinfo0
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> genunix: [ID 936769 kern.info] devinfo0 is /pseudo/devinfo@0
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> qotd: [ID 197678 kern.notice] QOTD_1: Be careful about
reading health books. You may die of a misprint. - Mark Twain</screen>

      <para>Ostatnia linijka jest jest zawartością zmiennej wydrukowanej przez
      funkcję <olink remap="external" targetdoc="819-2256"
      targetptr="cmn-err-9f"> <citerefentry>
          <refentrytitle>cmn_err</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> z punktu wejścia <olink remap="external"
      targetdoc="819-2255" targetptr="u-init-9e"> <citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> </olink>. Punkt wejścia <citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> jest wywoływany podczas ładowania sterownika.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dataondemand">
    <title>Displaying Data on Demand</title>

    <para>Przykładowy kod w tym podrozdziale tworzy pseudourządzenie
    kontrolowane przez sterownik. Sterownik przechowuje dane w urządzeniu i
    udostępnia je na żądanie odczytu urządzenia przez użytkownika.</para>

    <para>W pierwszej kolejności przedstawione będą najważniejsze różnice w
    kodzie źródłowym między pierwszą a drugą wersją sterownika Cytat Dnia.
    Później przedstawiono sposób żądania dopstępu do urządzenia, aby
    spowodować wydruk cytatu.</para>

    <sect2 xml:id="fcove">
      <title>Writing Quote Of The Day Version 2</title>

      <para>Sterownik kontrolujący pseudourządzenie jest bardziej
      skomplikowany od sterownika z poprzedniego podrozdziału. Najpwierw
      wyjaśnione zostaną niektóre ważne właściwości takiego sterownika,
      później zaś przedstawiony zostanie kompletny kod źródłowy.</para>

      <itemizedlist>
        <para>Poniższa lista przedstawia skrótowo różnice między dwiema
        wersjami sterownika Cytat Dnia:</para>

        <listitem>
          <para><indexterm xml:id="indexterm-341">
              <primary>state structures</primary>
            </indexterm>Wersja 2. sterownika definiuje strukturę stanu
          przechowującą informację o każdej instancji urządzenia.</para>
        </listitem>

        <listitem>
          <para>Wersja 2. definiuje strukturę <citerefentry>
              <refentrytitle>cb_ops</refentrytitle>

              <manvolnum>9S</manvolnum>
            </citerefentry> oraz uzupełnioną strukturę <citerefentry>
              <refentrytitle>dev_ops</refentrytitle>

              <manvolnum>9S</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Wersja 2. definiuje punkty wejścia <citerefentry>
              <refentrytitle>open</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>close</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>getinfo</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>, <citerefentry>
              <refentrytitle>attach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> i <citerefentry>
              <refentrytitle>detach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Wersja 1. używa funkcji <citerefentry>
              <refentrytitle>cmn_err</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> do zapisywania stałego łańcucha znaków w dzienniku
          systemowym w punkcie wejścia <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>. Punkt wejścia <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> wywoływany jest przy każdym ładowaniu sterownika.
          Wersja 2. używa funkcji <citerefentry>
              <refentrytitle>uiomove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> do kopiowania danych z pamięci jądra. Kopiowane
          dane są zwracane przez puinkt wejścia <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>. Punkt wejścia <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> wywoływany jest za przy każdym żądaniu odczytu z
          urządzenia.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-342">
              <primary><function>ASSERT </function> kernel function</primary>
            </indexterm> <indexterm xml:id="indexterm-343">
              <primary>kernel functions</primary>

              <secondary><function>ASSERT </function></secondary>
            </indexterm>Wersja 2. sterownika używa wyrażenia <olink
          remap="external" targetdoc="819-2256" targetptr="uc-assert-9f">
          <citerefentry>
              <refentrytitle>ASSERT</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> do testów poprawności danych.</para>
        </listitem>
      </itemizedlist>

      <para>Poniższe podrozdziały wprowadzają więcej szczegółów na temat
      dodatkowych elementów Wersji 2. sterownika Cytat Dnia.</para>

      <sect3 xml:id="fcowf">
        <title>Managing Device State</title>

        <indexterm xml:id="indexterm-344">
          <primary>state structures</primary>
        </indexterm>

        <indexterm xml:id="indexterm-345">
          <primary>soft state</primary>
        </indexterm>

        <indexterm xml:id="indexterm-346">
          <primary>devices</primary>

          <secondary>state</secondary>
        </indexterm>

        <para>Punkty wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> oraz dodatkowe sześć punktów wejścia w tym
        sterowniku zarządzają stanem miękkim (ang. soft state) urządzenia.
        (Stan miękki odnosi się najczęściej do przechowywanej w pamięci kopii
        stanu sprzętowego, na przykład rejestrów urządzenia - DW.) Większość
        sterowników urządzeń zarządza informacjami o stanie każdej instancji,
        którą kontrolują. Instancja jest zazwyczaj podległym urządzeniem. Na
        przykład sterownik dysku może komunikować się z kontrolerem
        sprzętowym, do którego podłączone jets kilka urządzeń dyskowych.
        Więcej informacji o stanach miękkich w <olink remap="external"
        targetdoc="819-3196" targetptr="fappe"> <citetitle
        remap="section">Retrieving Driver Soft State Information</citetitle>
        in <citetitle remap="book">Writing Device Drivers</citetitle>
        </olink>.</para>

        <para>Opisywany sterownik pozwala na tylko jedną instancję urządzenia.
        Numer instancji przypisywany jest w pliku konfiguracyjnym. Więcej w
        <olink remap="internal" targetdoc="chapter-3.xml"
        targetptr="fcoux">Example 3–4</olink>. Większość sterowników umożliwa
        utworzenie dowolnej liczby instancji urządzenia. System zarządza
        numerami instancji, a funkcje miękkich stanów DDI zarządzają
        instancjami.</para>

        <orderedlist>
          <para><indexterm xml:id="indexterm-347">
              <primary><function>ddi_soft_state_init </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-348">
              <primary>kernel functions</primary>

              <secondary><function>ddi_soft_state_init </function></secondary>
            </indexterm> <indexterm xml:id="indexterm-349">
              <primary><function>ddi_soft_state_zalloc </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-350">
              <primary>kernel functions</primary>

              <secondary><function>ddi_soft_state_zalloc
              </function></secondary>
            </indexterm> <indexterm xml:id="indexterm-351">
              <primary><function>ddi_get_soft_state </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-352">
              <primary>kernel functions</primary>

              <secondary><function>ddi_get_soft_state </function></secondary>
            </indexterm> <indexterm xml:id="indexterm-353">
              <primary><function>ddi_soft_state_free </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-354">
              <primary>kernel functions</primary>

              <secondary><function>ddi_soft_state_free </function></secondary>
            </indexterm> <indexterm xml:id="indexterm-355">
              <primary><function>ddi_soft_state_fini </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-356">
              <primary>kernel functions</primary>

              <secondary><function>ddi_soft_state_fini </function></secondary>
            </indexterm>Poniższy przepływ krótko przedstawia sposób
          zarządzania wskaźnikiem stanu oraz stanem instancji urządzenia przez
          funkcje stanów miękkich DDI:</para>

          <listitem>
            <para>Funkcja <olink remap="external" targetdoc="819-2256"
            targetptr="ddi-soft-state-init-9f"> <citerefentry>
                <refentrytitle>ddi_soft_state_init</refentrytitle>

                <manvolnum>9F</manvolnum>
              </citerefentry> </olink> inicjalizuje wskaźnik stanu. Wskaźnik
            stanu jest ogólnym uchwytem umożliwiającym alokację, dealokację i
            śledzenie struktury stanu dla każdej instancji urządzenia.
            Struktura stanu jest definiowana przez użytkownika i przechowuje
            dane odpowiednie dla każdej instancji urządzenia. W tym przypadku
            wskaźnik stanu i struktura stanu są deklarowane po deklaracjach
            punktów wejścia. Więcej o <literal>qotd_state_head</literal> i
            <literal>qotd_state</literal> w <olink remap="internal"
            targetdoc="chapter-3.xml" targetptr="fcova">Example
            3–3</olink>.</para>
          </listitem>

          <listitem>
            <para>Funkcja <olink remap="external" targetdoc="819-2256"
            targetptr="ddi-soft-state-zalloc-9f"> <citerefentry>
                <refentrytitle>ddi_soft_state_zalloc</refentrytitle>

                <manvolnum>9F</manvolnum>
              </citerefentry> </olink> używa wskaźnika stanu i instancji
            urządzenia do stworzenia struktury stanu dla danej
            instancji.</para>
          </listitem>

          <listitem>
            <para>Funkcja <olink remap="external" targetdoc="819-2256"
            targetptr="ddi-get-soft-state-9f"> <citerefentry>
                <refentrytitle>ddi_get_soft_state</refentrytitle>

                <manvolnum>9F</manvolnum>
              </citerefentry> </olink> używa wskaźnika stanu i instancji
            urządzenia do uzyskania infoemacji o danej instancji
            urządzenia.</para>
          </listitem>

          <listitem>
            <para>Funkcja <olink remap="external" targetdoc="819-2256"
            targetptr="ddi-soft-state-free-9f"> <citerefentry>
                <refentrytitle>ddi_soft_state_free</refentrytitle>

                <manvolnum>9F</manvolnum>
              </citerefentry> </olink> używa wskaźnika stanu i instancji
            urządzenia douwolnienia struktury stanu dla danej
            instancji.</para>
          </listitem>

          <listitem>
            <para>Funkcja <olink remap="external" targetdoc="819-2256"
            targetptr="ddi-soft-state-fini-9f"> <citerefentry>
                <refentrytitle>ddi_soft_state_fini</refentrytitle>

                <manvolnum>9F</manvolnum>
              </citerefentry> </olink> używa wskaźnika stanudo zniszczenia
            wskaźnika stanu oraz struktur stanu dla wszystkich instancji
            urządzenia.</para>
          </listitem>
        </orderedlist>

        <para>Funkcje <citerefentry>
            <refentrytitle>ddi_soft_state_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>ddi_get_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>ddi_soft_state_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> koordynują dostęp do struktur danych w sposób
        bezpieczny w środowisku wielowątkowym i dodatkowe zabezpieczenia (np.
        zamki) powinny być zbędne.</para>
      </sect3>

      <sect3 xml:id="fcoye">
        <title>Initializing and Unloading</title>

        <indexterm xml:id="indexterm-357">
          <primary><function>_init </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-358">
          <primary>entry points</primary>

          <secondary><function>_init </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-359">
          <primary><function>ddi_soft_state_init </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-360">
          <primary>kernel functions</primary>

          <secondary><function>ddi_soft_state_init </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-361">
          <primary><function>mod_install </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-362">
          <primary>kernel functions</primary>

          <secondary><function>mod_install </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-363">
          <primary><function>ddi_soft_state_fini </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-364">
          <primary>kernel functions</primary>

          <secondary><function>ddi_soft_state_fini </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-365">
          <primary><function>_fini </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-366">
          <primary>entry points</primary>

          <secondary><function>_fini </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-367">
          <primary><function>mod_remove </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-368">
          <primary>kernel functions</primary>

          <secondary><function>mod_remove </function></secondary>
        </indexterm>

        <para>Punkt wejścia <olink remap="external" targetdoc="819-2255"
        targetptr="u-init-9e"> <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> wywołuje funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-soft-state-init-9f"> <citerefentry>
            <refentrytitle>ddi_soft_state_init</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> fdo zainicjalizowania miękkiego stanu.
        Jeśli inicjalizacja stanu miękkiego nie powiedzie się, zwracany jest
        kod błędu. Jeśli się uda, punkt wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="mod-install-9f"> <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu załadowania modułu. Jeśli instalacja
        modułu się nie uda, punkt wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-soft-state-fini-9f"> <citerefentry>
            <refentrytitle>ddi_soft_state_fini</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i zwraca kod błędu nieudanej instalacji
        modułu.</para>

        <para>Kod sterownika musi zawsze na końcu wykonać pracę odwrotną od
        tej wykonywanej przy instalacji modułu. Funkcja <citerefentry>
            <refentrytitle>ddi_soft_state_fini</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> jest wywoływana przy nieudanej instalacji modułu,
        ponieważ punkt wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> stworzył już wskaźnik stanu.</para>

        <para>Punkt wejścia <olink remap="external" targetdoc="819-2255"
        targetptr="u-fini-9e"> <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> musi wykonać pracę odwrotną do tej
        wykonanej przez punkt wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Punkt wejścia <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> najpierw wywołuje funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="mod-remove-9f"> <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> aby usunąć moduł zainstalowany przez
        <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Jeśli usnięcie modułu nie uda się zwracany jest kod
        błędu. Jeśli usunięcie modułu się powiedzie, punkt wejścia
        <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-soft-state-fini-9f"> <citerefentry>
            <refentrytitle>ddi_soft_state_fini</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu zniszczenia wskaźnika stanu oraz
        struktur stanu dla wszystkich instancji urządzenia.</para>
      </sect3>

      <sect3 xml:id="fcown">
        <title>Attaching and Detaching</title>

        <indexterm xml:id="indexterm-369">
          <primary><function>attach </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-370">
          <primary>entry points</primary>

          <secondary><function>attach </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-371">
          <primary><function>ddi_get_instance </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-372">
          <primary>kernel functions</primary>

          <secondary><function>ddi_get_instance </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-373">
          <primary><function>ddi_soft_state_zalloc </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-374">
          <primary>kernel functions</primary>

          <secondary><function>ddi_soft_state_zalloc </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-375">
          <primary><function>ddi_get_soft_state </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-376">
          <primary>kernel functions</primary>

          <secondary><function>ddi_get_soft_state </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-377">
          <primary><function>ddi_create_minor_node </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-378">
          <primary>kernel functions</primary>

          <secondary><function>ddi_create_minor_node </function></secondary>
        </indexterm>

        <para>Punkt wejścia <olink remap="external" targetdoc="819-2255"
        targetptr="attach-9e"> <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> wywołuje najpierw funkcję <olink
        remap="external" targetdoc="819-2256" targetptr="ddi-get-instance-9f">
        <citerefentry>
            <refentrytitle>ddi_get_instance</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do uzyskania numeru instancji node'u
        informacyjnego urządzenia. Punkt wejścia <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> używa tego numeru do wywołania funkcji <olink
        remap="external" targetdoc="819-2256"
        targetptr="ddi-soft-state-zalloc-9f"> <citerefentry>
            <refentrytitle>ddi_soft_state_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-get-soft-state-9f"> <citerefentry>
            <refentrytitle>ddi_get_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-create-minor-node-9f">
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <para>Punkt wejścia <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje funkcję <citerefentry>
            <refentrytitle>ddi_soft_state_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>, która tworzy strukturę stanu dla instancji
        urządzenia. Jeśli stworzenie struktury stanu miękkiego się nie
        powiedzie <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zapisuje w dzienniku systemu komunikat o błędzie i
        zwraca błąd. Taka instancja nie jest podłączona. Jeśli stworzenie
        struktury stanu się powiedzie <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje <citerefentry>
            <refentrytitle>ddi_get_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>, aby uzyskać strukturę stanu dla danej instancji
        urządzenia.</para>

        <para><indexterm xml:id="indexterm-379">
            <primary><function>ddi_soft_state_free </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-380">
            <primary>kernel functions</primary>

            <secondary><function>ddi_soft_state_free </function></secondary>
          </indexterm>Jeśli nie uda się uzyskanie struktury stanu
        <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zapisuje w dzienniku systemu komunikat o błędzie,
        wywołuje funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-soft-state-free-9f"> <citerefentry>
            <refentrytitle>ddi_soft_state_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>, która niszczy strukturę stanu stworzoną
        przez <citerefentry>
            <refentrytitle>ddi_soft_state_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> i zwraca błąd. Taka instancja urządzenia nie jest
        podłączona. Jeśli uzyskanie struktury stanu uda się <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w celu stworzenia node'u urządzenia.</para>

        <para><indexterm xml:id="indexterm-381">
            <primary><function>ddi_remove_minor_node </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-382">
            <primary>kernel functions</primary>

            <secondary><function>ddi_remove_minor_node </function></secondary>
          </indexterm>Na początku pliku źródłowego sterownika zdefiniowano
        stałą nazwaną <literal>QOTD_NAME</literal> przechowującą nazwę
        urządzenia. Jest to jeden z argumentów przekazywanych do <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>. Jeśli stworzenie node'u urządzenia nie powiedzie
        się <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zapisuje komunikat o błędzie do dziennika systemu,
        wywołuje <citerefentry>
            <refentrytitle>ddi_soft_state_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w celu zniszczenia struktury stanu stworzonej przez
        <citerefentry>
            <refentrytitle>ddi_soft_state_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>, wywołuje <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-remove-minor-node-9f">
        <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i zwraca bład. Taka instancja urządzenia
        nie jest podłączona.</para>

        <para><indexterm xml:id="indexterm-383">
            <primary><function>ddi_report_dev </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-384">
            <primary>kernel functions</primary>

            <secondary><function>ddi_report_dev </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-385">
            <primary><command>dmesg</command> command</primary>
          </indexterm> <indexterm xml:id="indexterm-386">
            <primary>commands</primary>

            <secondary><command>dmesg</command></secondary>
          </indexterm>Jeśli powiedzie się stworzenie node'u urządzeni,
        instancja jest podłączana. Punkt wejścia <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> przydziela elementowi instance ze struktury stanu
        dla tej instancji numer instancji uzyskany z funkcji <citerefentry>
            <refentrytitle>ddi_get_instance</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>. Następnie <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> przydziela elementowi <literal>dev_info</literal>
        struktury stanu wskaźnik przekazany w wywołaniu <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Funkcja <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-report-dev-9f"> <citerefentry>
            <refentrytitle>ddi_report_dev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> zapisuje komunikat w dzienniku systemu
        podczas dodawania urządzenia oraz podczas startu systemu. Komunikat
        ogląsza dostępność urządzenia jak w przykładzie poniżej:</para>

        <screen>% <userinput>dmesg</userinput>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> pseudo: [ID 129642 kern.info] pseudo-device: qotd_20
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> genunix: [ID 936769 kern.info] qotd_20 is /pseudo/qotd_2@0</screen>

        <para><indexterm xml:id="indexterm-387">
            <primary><function>detach </function> entry point</primary>
          </indexterm> <indexterm xml:id="indexterm-388">
            <primary>entry points</primary>

            <secondary><function>detach </function></secondary>
          </indexterm>Punkt wejścia <olink remap="external"
        targetdoc="819-2255" targetptr="detach-9e"> <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> najpierw wywołuje funkcję <citerefentry>
            <refentrytitle>ddi_get_instance</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> aby uzyskać numer instancji node'u informacyjnego
        urządzenia. Punkt wejścia <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> używa tego numeru do wywołania funkcji <citerefentry>
            <refentrytitle>ddi_soft_state_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> niszczącej strukturę stanu stworzoną przez
        <citerefentry>
            <refentrytitle>ddi_soft_state_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w punkcie wejścia <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Punkt wejścia <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje następnie funkcję <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w celu usunięcia urządzenia stworzonego przez
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w punkcie wejścia <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>
      </sect3>

      <sect3 xml:id="fcows">
        <title>Opening the Device, Closing the Device, and Getting Module
        Information</title>

        <indexterm xml:id="indexterm-389">
          <primary><function>open </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-390">
          <primary>entry points</primary>

          <secondary><function>open </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-391">
          <primary><function>close </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-392">
          <primary>entry points</primary>

          <secondary><function>close </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-393">
          <primary><function>getminor </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-394">
          <primary>kernel functions</primary>

          <secondary><function>getminor </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-395">
          <primary><function>ddi_get_soft_state </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-396">
          <primary>kernel functions</primary>

          <secondary><function>ddi_get_soft_state </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-397">
          <primary><function>getinfo </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-398">
          <primary>entry points</primary>

          <secondary><function>getinfo </function></secondary>
        </indexterm>

        <para>Punkty wejścia <olink remap="external" targetdoc="819-2255"
        targetptr="open-9e"> <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="close-9e"> <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> są w tym przykładzie identyczne. W obydwóch
        przypadkach punkt wejścia wywołuje najpierw funkcję <olink
        remap="external" targetdoc="819-2256" targetptr="getminor-9f">
        <citerefentry>
            <refentrytitle>getminor</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu uzyskania młodszego numeru
        urządzenia. Później oba punkty wejścia używają tego numeru instancji
        do wywołania funkcji <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-get-soft-state-9f"> <citerefentry>
            <refentrytitle>ddi_get_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu uzyskania struktury stanu dla danej
        instancji. Jeśli nie uda się uzyskać żadnej struktury stanu, zwracany
        jest kod błędu; w przeciwnym razie oba punkty wejścia sprawdzają typ
        urządzenia. Jeśli urządzenie nie jest znakowe, zwracany jest kod błędu
        <literal>EINVAL</literal> (nieprawidłowe).</para>

        <para>Jeśli użytkownik zażąda informacji o urządzeniu dla danej
        instancji punkt wejścia <olink remap="external" targetdoc="819-2255"
        targetptr="getinfo-9e"> <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca informację o urządzeniu ze struktury
        stanu. Jeśli użytkownik zażąda numeru instancji punkt wejścia
        <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołuje funkcję <citerefentry>
            <refentrytitle>getminor</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w celu zwrócenia młodszego numeru.</para>
      </sect3>

      <sect3 xml:id="fcowr">
        <title>Reading the Data</title>

        <indexterm xml:id="indexterm-399">
          <primary><function>read </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-400">
          <primary>entry points</primary>

          <secondary><function>read </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-401">
          <primary><function>getminor </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-402">
          <primary>kernel functions</primary>

          <secondary><function>getminor </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-403">
          <primary><function>ddi_get_soft_state </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-404">
          <primary>kernel functions</primary>

          <secondary><function>ddi_get_soft_state </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-405">
          <primary><function>uiomove </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-406">
          <primary>kernel functions</primary>

          <secondary><function>uiomove </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-407">
          <primary><literal>uio</literal> kernel structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-408">
          <primary>kernel structures</primary>

          <secondary><literal>uio</literal></secondary>
        </indexterm>

        <para>Punkt wejścia <olink remap="external" targetdoc="819-2255"
        targetptr="read-9e"> <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> najpierw wywołuje funkcję <olink
        remap="external" targetdoc="819-2256" targetptr="getminor-9f">
        <citerefentry>
            <refentrytitle>getminor</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu uzyskania młodszego numeru
        urządzenia. Punkt wejścia <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> używa tego numeru do wywołania funkcji <olink
        remap="external" targetdoc="819-2256"
        targetptr="ddi-get-soft-state-9f"> <citerefentry>
            <refentrytitle>ddi_get_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do uzyskania struktury stanu dla danej
        instancji. Jeśli nie uda się uzyskać żadnej struktury <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zwraca kod błędu, w przeciwnym przypadku wywołuje
        funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="uiomove-9f"> <citerefentry>
            <refentrytitle>uiomove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu przekopiowania cytatu ze sterownika
        do struktury żądania I/O <olink remap="external" targetdoc="819-2257"
        targetptr="uio-9s"> <citerefentry>
            <refentrytitle>uio</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink>.</para>
      </sect3>

      <sect3 xml:id="fgowt">
        <title>Checking Data Validity</title>

        <indexterm xml:id="indexterm-409">
          <primary><function>ASSERT </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-410">
          <primary>kernel functions</primary>

          <secondary><function>ASSERT </function></secondary>
        </indexterm>

        <para>Wersja 2. sterownika używa wyrażeń <olink remap="external"
        targetdoc="819-2256" targetptr="uc-assert-9f"> <citerefentry>
            <refentrytitle>ASSERT</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do sprawdzenia poprawności danych. Jeśli
        wartość sprawdzanego wyrażenia jest prawdziwa <citerefentry>
            <refentrytitle>ASSERT</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> nie podejmuje żadnych działań. Jeśli jednak
        wyrażenie okaże się fałszywe <citerefentry>
            <refentrytitle>ASSERT</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zapisze na konsoli komunikat o błędzie i spowoduje
        panikę systemu.</para>

        <para>Użycia wyrażenia <citerefentry>
            <refentrytitle>ASSERT</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> wymaga włączenia pliku nagłówkowego
        <filename>sys/debug.h</filename> i zdefiniowania symbolu preprocesora
        <literal>DEBUG</literal>. Jeśli symbol <literal>DEBUG</literal> nie
        będzie zdefiniowany, wyrażenia <citerefentry>
            <refentrytitle>ASSERT</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> nie podejmują żadnych akcji. Włączenie i wyłączenie
        <citerefentry>
            <refentrytitle>ASSERT</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> wymaga rekompilacji.</para>
      </sect3>

      <sect3 xml:id="fcowy">
        <title>Quote Of The Day Version 2 Source</title>

        <para>Poniższy kod źródłowy należy zapisać w pliku
        <filename>qotd_2.c</filename>.</para>

        <example xml:id="fcova">
          <title>Quote Of The Day Version 2 Source File</title>

          <programlisting>#include &lt;sys/types.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/open.h&gt;
#include &lt;sys/cred.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/modctl.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/devops.h&gt;
#include &lt;sys/debug.h&gt;
#include &lt;sys/cmn_err.h&gt;
#include &lt;sys/ddi.h&gt;
#include &lt;sys/sunddi.h&gt;

#define QOTD_NAME       "qotd"
#define QOTD_MAXLEN     128

static const char qotd[QOTD_MAXLEN]
        = "You can't have everything. \
Where would you put it? - Steven Wright\n";

static void *qotd_state_head;

struct qotd_state {
        int             instance;
        dev_info_t      *devi;
};

static int qotd_getinfo(dev_info_t *, ddi_info_cmd_t, void *, void **);
static int qotd_attach(dev_info_t *, ddi_attach_cmd_t);
static int qotd_detach(dev_info_t *, ddi_detach_cmd_t);
static int qotd_open(dev_t *, int, int, cred_t *);
static int qotd_close(dev_t, int, int, cred_t *);
static int qotd_read(dev_t, struct uio *, cred_t *);

static struct cb_ops qotd_cb_ops = {
        qotd_open,              /* cb_open */
        qotd_close,             /* cb_close */
        nodev,                  /* cb_strategy */
        nodev,                  /* cb_print */
        nodev,                  /* cb_dump */
        qotd_read,              /* cb_read */
        nodev,                  /* cb_write */
        nodev,                  /* cb_ioctl */
        nodev,                  /* cb_devmap */
        nodev,                  /* cb_mmap */
        nodev,                  /* cb_segmap */
        nochpoll,               /* cb_chpoll */
        ddi_prop_op,            /* cb_prop_op */
        (struct streamtab *)NULL,       /* cb_str */
        D_MP | D_64BIT,         /* cb_flag */
        CB_REV,                 /* cb_rev */
        nodev,                  /* cb_aread */
        nodev                   /* cb_awrite */
};

static struct dev_ops qotd_dev_ops = {
        DEVO_REV,               /* devo_rev */
        0,                      /* devo_refcnt */
        qotd_getinfo,           /* devo_getinfo */
        nulldev,                /* devo_identify */
        nulldev,                /* devo_probe */
        qotd_attach,            /* devo_attach */
        qotd_detach,            /* devo_detach */
        nodev,                  /* devo_reset */
        &amp;qotd_cb_ops,           /* devo_cb_ops */
        (struct bus_ops *)NULL, /* devo_bus_ops */
        nulldev                 /* devo_power */
};

static struct modldrv modldrv = {
        &amp;mod_driverops,
        "Quote of the Day 2.0",
        &amp;qotd_dev_ops};

static struct modlinkage modlinkage = {
        MODREV_1,
        (void *)&amp;modldrv,
        NULL
};

int
_init(void)
{
        int retval;

        if ((retval = ddi_soft_state_init(&amp;qotd_state_head,
            sizeof (struct qotd_state), 1)) != 0)
                return retval;
        if ((retval = mod_install(&amp;modlinkage)) != 0) {
                ddi_soft_state_fini(&amp;qotd_state_head);
                return (retval);
        }

        return (retval);
}

int
_info(struct modinfo *modinfop)
{
        return (mod_info(&amp;modlinkage, modinfop));
}

int
_fini(void)
{
        int retval;

        if ((retval = mod_remove(&amp;modlinkage)) != 0)
                return (retval);
        ddi_soft_state_fini(&amp;qotd_state_head);

        return (retval);
}

/*ARGSUSED*/
static int
qotd_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, void **resultp)
{
        struct qotd_state *qsp;
        int retval = DDI_FAILURE;

        ASSERT(resultp != NULL);

        switch (cmd) {
        case DDI_INFO_DEVT2DEVINFO:
                if ((qsp = ddi_get_soft_state(qotd_state_head,
                    getminor((dev_t)arg))) != NULL) {
                        *resultp = qsp-&gt;devi;
                        retval = DDI_SUCCESS;
                } else
                        *resultp = NULL;
                break;
        case DDI_INFO_DEVT2INSTANCE:
                *resultp = (void *)getminor((dev_t)arg);
                retval = DDI_SUCCESS;
                break;
        }

        return (retval);
}

static int
qotd_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
        int instance = ddi_get_instance(dip);
        struct qotd_state *qsp;

        switch (cmd) {
        case DDI_ATTACH:
                if (ddi_soft_state_zalloc(qotd_state_head, instance)
                    != DDI_SUCCESS) {
                        cmn_err(CE_WARN, "Unable to allocate state for %d",
                            instance);
                        return (DDI_FAILURE);
                }
                if ((qsp = ddi_get_soft_state(qotd_state_head, instance))
                    == NULL) {
                        cmn_err(CE_WARN, "Unable to obtain state for %d",
                            instance);
                        ddi_soft_state_free(qotd_state_head, instance);
                        return (DDI_FAILURE);
                }
                if (ddi_create_minor_node(dip, QOTD_NAME, S_IFCHR, instance,
                    DDI_PSEUDO, 0) != DDI_SUCCESS) {
                        cmn_err(CE_WARN, "Cannot create minor node for %d",
                            instance);
                        ddi_soft_state_free(qotd_state_head, instance);
                        ddi_remove_minor_node(dip, NULL);
                        return (DDI_FAILURE);
                }
                qsp-&gt;instance = instance;
                qsp-&gt;devi = dip;

                ddi_report_dev(dip);
                return (DDI_SUCCESS);
        case DDI_RESUME:
                return (DDI_SUCCESS);
        default:
                return (DDI_FAILURE);
        }
}

static int
qotd_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
        int instance = ddi_get_instance(dip);

        switch (cmd) {
        case DDI_DETACH:
                ddi_soft_state_free(qotd_state_head, instance);
                ddi_remove_minor_node(dip, NULL);
                return (DDI_SUCCESS);
        case DDI_SUSPEND:
                return (DDI_SUCCESS);
        default:
                return (DDI_FAILURE);
        }
}

/*ARGSUSED*/
static int
qotd_open(dev_t *devp, int flag, int otyp, cred_t *credp)
{
        int instance = getminor(*devp);
        struct qotd_state *qsp;

        if ((qsp = ddi_get_soft_state(qotd_state_head, instance)) == NULL)
                return (ENXIO);

        ASSERT(qsp-&gt;instance == instance);

        if (otyp != OTYP_CHR)
                return (EINVAL);

        return (0);
}

/*ARGSUSED*/
static int
qotd_close(dev_t dev, int flag, int otyp, cred_t *credp)
{
        struct qotd_state *qsp;
        int instance = getminor(dev);

        if ((qsp = ddi_get_soft_state(qotd_state_head, instance)) == NULL)
                return (ENXIO);

        ASSERT(qsp-&gt;instance == instance);

        if (otyp != OTYP_CHR)
                return (EINVAL);

        return (0);
}

/*ARGSUSED*/
static int
qotd_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
        struct qotd_state *qsp;
        int instance = getminor(dev);

        if ((qsp = ddi_get_soft_state(qotd_state_head, instance)) == NULL)
                return (ENXIO);

        ASSERT(qsp-&gt;instance == instance);

        return (uiomove((void *)qotd, min(uiop-&gt;uio_resid, strlen(qotd)),
            UIO_READ, uiop));
}</programlisting>
        </example>

        <para>Poniższe dane konfiguracyjne należy umieścić w pliku
        <filename>qotd_2.conf</filename>.</para>

        <example xml:id="fcoux">
          <title>Quote Of The Day Version 2 Configuration File</title>

          <programlisting>name="qotd_2" parent="pseudo" instance=0;</programlisting>
        </example>
      </sect3>
    </sect2>

    <sect2 xml:id="fcovc">
      <title>Building, Installing, and Using Quote Of The Day
      Version 2</title>

      <indexterm xml:id="indexterm-411">
        <primary><function>ASSERT </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-412">
        <primary>kernel functions</primary>

        <secondary><function>ASSERT </function></secondary>
      </indexterm>

      <para>Wersja 2. sterownika używa wyrażeń <olink remap="external"
      targetdoc="819-2256" targetptr="uc-assert-9f"> <citerefentry>
          <refentrytitle>ASSERT</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> do sprawdzania poprawności danych. Użycie
      <citerefentry>
          <refentrytitle>ASSERT</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> wymaga włączenia pliku nagłówkowego
      <filename>sys/debug.h</filename> i zdefiniowania symbolu preprocesora
      <literal>DEBUG</literal>.</para>

      <para>Kompilacja i konsolidacja ze zdefiniowanym symbolem
      <literal>DEBUG</literal> wymaganym do włączenia wyrażeń <olink
      remap="external" targetdoc="819-2256" targetptr="uc-assert-9f">
      <citerefentry>
          <refentrytitle>ASSERT</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink> została przedstawiona poniżej:</para>

      <screen>% <userinput>cc -D_KERNEL -DDEBUG -c qotd_2.c</userinput>
% <userinput>ld -r -o qotd_2 qotd_2.o</userinput>
</screen>

      <para>Poniższy przykład pokazuje kompilację i konsolidację dla 32bitowej
      architektury bez włączania wyrażeń <citerefentry>
          <refentrytitle>ASSERT</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry>:</para>

      <screen>% <userinput>cc -D_KERNEL -c qotd_2.c</userinput>
% <userinput>ld -r -o qotd_2 qotd_2.o</userinput>
</screen>

      <para>Do instalacji sterownika wymagany jest użytkownik
      <literal>root</literal>.</para>

      <para>Plik binarny sterownika należy skopiować do katalogu
      <filename>/tmp</filename> jak w <olink remap="external"
      targetdoc="chapter-2.xml" targetptr="eoxzr">Building and Installing the
      Template Driver</olink>.</para>

      <screen># <userinput>cp qotd_2 /tmp</userinput>
# <userinput>ln -s /tmp/qotd_2 /usr/kernel/drv/qotd_2</userinput>
</screen>

      <para>Plik konfiguracyjny należy skopiować do katalogu sterowników
      jądra.</para>

      <screen># <userinput>cp qotd_2.conf /usr/kernel/drv</userinput>
</screen>

      <para>W osobnym oknie należy wykonać poniższą komendę:</para>

      <screen>% <userinput>tail -f /var/adm/messages</userinput>
</screen>

      <para>Do załadowania sterownika wymagany jest użytkownik
      <literal>root</literal>. Do załadowania sterownika służy komenda <olink
      remap="external" targetdoc="819-2240" targetptr="add-drv-1m">
      <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>:</para>

      <screen># <userinput>add_drv qotd_2</userinput>
</screen>

      <para>W oknie, w którym śledzone są komunikaty w pliku
      <literal>/var/adm/messages</literal> powinny pojawić się poniższe
      wpisy:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> pseudo: [ID 129642 kern.info] pseudo-device: devinfo0
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> genunix: [ID 936769 kern.info] devinfo0 is /pseudo/devinfo@0
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> pseudo: [ID 129642 kern.info] pseudo-device: qotd_20
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> genunix: [ID 936769 kern.info] qotd_20 is /pseudo/qotd_2@0</screen>

      <para>Obecna wersja sterownika nie drukuje cytatu po załadowaniu.
      Sterownik <literal>qotd_1</literal> zapisywał wiadomość do dziennika
      systemowego w punkcie wejścia<citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>. Sterownik <literal>qotd_2</literal> przechowuje dane
      i udostępnia je w punkcie wejścia <citerefentry>
          <refentrytitle>read</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>.</para>

      <para><indexterm xml:id="indexterm-413">
          <primary>commands</primary>

          <secondary><command>modinfo</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-414">
          <primary><command>modinfo</command> command</primary>
        </indexterm> <indexterm xml:id="indexterm-415">
          <primary>files</primary>

          <secondary><filename>/etc/name_to_major</filename></secondary>
        </indexterm> <indexterm xml:id="indexterm-416">
          <primary><filename>/etc/name_to_major</filename> file</primary>
        </indexterm>Informacje o tej wersji sterownika Cytat Dnia można
      uzyskać komendą <olink remap="external" targetdoc="819-2240"
      targetptr="modinfo-1m"> <citerefentry>
          <refentrytitle>modinfo</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>. Nazwa modułu to wartość drugiego elementu
      struktury <literal>modldrv</literal>. Wartość <literal>96</literal> to
      starszy numer modułu.</para>

      <screen>% <userinput>modinfo | grep qotd</userinput>
182 ed115948    754  96   1  qotd_2 (Quote of the Day 2.0)
% <userinput>grep qotd /etc/name_to_major</userinput>
qotd_1 94
qotd_2 96</screen>

      <para><indexterm xml:id="indexterm-417">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-418">
          <primary><command>prtconf</command> command</primary>
        </indexterm>Sterownik jest też najnowszą pozycją w wydruku komendy
      <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> w sekcji z pseudourządzeniami:</para>

      <screen>% <userinput>prtconf -P | grep qotd</userinput>
        qotd_1, instance #0 (driver not attached)
        qotd_2, instance #0</screen>

      <para><indexterm xml:id="indexterm-419">
          <primary><literal>/devices/pseudo</literal> directory</primary>
        </indexterm>Podczas próby otwarcia urządzenia komenda wykorzystywana
      do uzyskania dostępu do urządzenia uzyskuje dane z node'u urządzenia,
      później komenda ta drukuje informacje w taki sam sposób jak drukowałaby
      wszystkie inne informacje. Nazwę pliku specjalnego urządzenia można
      uzyskać zaglądając do katalogu <filename>/devices</filename>:</para>

      <screen>% <userinput>ls -l /devices/pseudo/qotd*</userinput>
crw-------   1 root   sys   96, 0 <replaceable>date</replaceable> <replaceable>time</replaceable> /devices/pseudo/qotd_2@0:qotd</screen>

      <para><indexterm xml:id="indexterm-420">
          <primary>devices</primary>

          <secondary>reading</secondary>
        </indexterm> <indexterm xml:id="indexterm-421">
          <primary>commands</primary>

          <secondary><command>more</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-422">
          <primary><command>more</command> command</primary>
        </indexterm>Wydruk pokazuje, że urządzenie
      <literal>qotd_2@0:qotd</literal> jest urządzeniem znakowym, pokazuje
      także, że tylko użytkownik <literal>root</literal> może pisać i czytać z
      urządzenia. Podczas testu urządzenia należy korzystać z użytkownika
      <literal>root</literal>. Do testowania odczytu z urządzenia
      <literal>qotd_2</literal> można użyć komendy <olink remap="external"
      targetdoc="819-2239" targetptr="more-1"> <citerefentry>
          <refentrytitle>more</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> </olink>:</para>

      <screen># <userinput>more /devices/pseudo/qotd_2@0:qotd</userinput>
You can't have everything. Where would you put it? - Steven Wright
You can't have everything. Where would you put it? - Steven Wright</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="ffdqq">
    <title>Modifying Data Stored in Kernel Memory</title>

    <indexterm xml:id="indexterm-423">
      <primary>devices</primary>

      <secondary>writing</secondary>
    </indexterm>

    <para><indexterm xml:id="indexterm-424">
        <primary>devices</primary>

        <secondary>ramdisk</secondary>
      </indexterm>W trzeciej wersji sterownika Cytat Dnia użytkownik będzie
    mógł zapisać dane do pamięci jądra. Pseudourządzenie stworzone przez ten
    sterownik jest urządzenie pseudodyskowym lub ramdyskiem. Ramdysk symuluje
    urządzenie dyskowe alokując pamięć w przestrzeni jądra i używając jej do
    przechowywania danych. Więcej informacji w <olink remap="external"
    targetdoc="819-2254" targetptr="ramdisk-7d"> <citerefentry>
        <refentrytitle>ramdisk</refentrytitle>

        <manvolnum>7D</manvolnum>
      </citerefentry> </olink>.</para>

    <para>Tak jak w wersji 2. sterownik przechowuje dane i udostępnia je za
    pomocą punktu wejścia <citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>9E</manvolnum>
      </citerefentry>. Wersja 3. nadpisuje dane zaczynając od pierwszego znaku
    w momencie, gdy użytkownik zaczyna zapisywać do urządzenia.</para>

    <para>Najpierw przedstawione zostaną ważne różnice w kodzie między obecną
    i poprzednią wersją sterownika Cytat Dnia. Później zaprezentowany zostanie
    sposób modyfikacji i drukowania cytatu.</para>

    <para>Oprócz zmian w sterowniku, w wersji trzeciej wprowadzony zostaje
    plik nagłówkowy oraz program pomocniczy. Plik nagłówkowy jest omawiany w
    następnym podrozdziale. Program pomocniczy omawiany jtes w <olink
    remap="internal" targetdoc="chapter-3.xml" targetptr="ffzsc">Using Quote
    Of The Day Version 3</olink>.</para>

    <sect2 xml:id="ffdqv">
      <title>Writing Quote Of The Day Version 3</title>

      <para>Trzecia wersja sterownika Cytat Dnia jest bardziej skomplikowana,
      ponieważ umożliwia użytkownikowi zmianę tekstu zapisanego w
      urządzeniu.</para>

      <para>Najperw omówione zostaną niektóre ważne elementy nowej wersji
      sterownika, później zaś zaprezentowany zostanie kompletny kod źródłowy,
      włącznie z plikiem nagłówkowym i plikiem konfiguracyjnym.</para>

      <itemizedlist>
        <para>Poniższej podsumowano nowe elementy trzeciej wersji sterownika
        Cytat Dnia:</para>

        <listitem>
          <para>Wersja 3. alokuje i uwalnia pamięć w przestrzeni jądra.</para>
        </listitem>

        <listitem>
          <para>Wersja 3. używa zmiennych warunkowych i muteksów do
          zarządzania synchronizacją wątków.</para>
        </listitem>

        <listitem>
          <para>Wersja 3. kopiuje dane z przestrzeni użytkownika do
          przestrzeni jądra umożliwiając mianę cytatu.</para>
        </listitem>

        <listitem>
          <para>Wersja 3. dodaje dwa nowe punkty wejścia: <olink
          remap="external" targetdoc="819-2255" targetptr="write-9e">
          <citerefentry>
              <refentrytitle>write</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> and <olink remap="external"
          targetdoc="819-2255" targetptr="ioctl-9e"> <citerefentry>
              <refentrytitle>ioctl</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink>.</para>
        </listitem>

        <listitem>
          <para>Wersja 3. dodaje trzecią nową funkcję. Funkcja
          <function>qotd_rw</function> wywoływana jest przez punkty wejścia
          <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> i <citerefentry>
              <refentrytitle>write</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-425">
              <primary><function>uiomove </function> kernel function</primary>
            </indexterm> <indexterm xml:id="indexterm-426">
              <primary>kernel functions</primary>

              <secondary><function>uiomove </function></secondary>
            </indexterm> <indexterm xml:id="indexterm-427">
              <primary><function>ddi_copyin </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-428">
              <primary>kernel functions</primary>

              <secondary><function>ddi_copyin </function></secondary>
            </indexterm> <indexterm xml:id="indexterm-429">
              <primary><function>ddi_copyout </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-430">
              <primary>kernel functions</primary>

              <secondary><function>ddi_copyout </function></secondary>
            </indexterm>Podobnie do wersji 2. wersja 3. używa używa funkcji
          <citerefentry>
              <refentrytitle>uiomove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> do udostępniania cytatu użytkownikowi. Wersja 3.
          używa funkcji <olink remap="external" targetdoc="819-2256"
          targetptr="ddi-copyin-9f"> <citerefentry>
              <refentrytitle>ddi_copyin</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> do kopiowania nowego cytatu i nowego
          rozmiaru urządzenia z przestrzeni użytkownika do przestrzeni jądra.
          Wersja 3. używa funkcji <olink remap="external" targetdoc="819-2256"
          targetptr="ddi-copyout-9f"> <citerefentry>
              <refentrytitle>ddi_copyout</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> do informowania użytkownika o aktualnej
          wielkości urządzenia.</para>
        </listitem>

        <listitem>
          <para><indexterm xml:id="indexterm-431">
              <primary>data model</primary>

              <secondary>converting</secondary>
            </indexterm> <indexterm xml:id="indexterm-432">
              <primary><function>ddi_model_convert_from </function> kernel
              function</primary>
            </indexterm> <indexterm xml:id="indexterm-433">
              <primary>kernel functions</primary>

              <secondary><function>ddi_model_convert_from
              </function></secondary>
            </indexterm>Sterownik kopiuje dane między przestrzenią jądra i
          przestrzenią użytkownika, dlatego wersja 3. używa funkcji <olink
          remap="external" targetdoc="819-2256"
          targetptr="ddi-model-convert-from-9f"> <citerefentry>
              <refentrytitle>ddi_model_convert_from</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> do sprawdzenia, czy trzeba dokonać
          konwersji danych między modelami 32bitowym i 64bitowym. Jądro
          obsługuje dane użytkownika w obydwóch modelach.</para>
        </listitem>

        <listitem>
          <para>Wersja 3. definiuje następną zmienną informującą sterownik,
          czy urządzenie jest zajęte. Inna nowa zmienna informuje sterownik,
          czy cytat został zmieniony. Dodatkowo wersja 3. definiuje cztery
          nowe zmienne pomagające cofnąć wykonane operacje.</para>
        </listitem>

        <listitem>
          <para>Wersja 3. zawiera osobne narzędzie do testowania kontroli I/O
          urządzenia.</para>
        </listitem>
      </itemizedlist>

      <para>Poniżej podano więcej szczegółowych informacji o zmianach i nowych
      elementach wertsji 3. Cytatu Dnia. Struktury <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>modlinkage</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> są takie same jak w wersji 2. W strukturze
      <citerefentry>
          <refentrytitle>modldrv</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> zmienił się tylko numer wersji sterownika. W stosunku
      do wersji 2. nie zmieniły się też funkcje <citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>_info</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>_fini</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>getinfo</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>close</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>.</para>

      <sect3 xml:id="fggxn">
        <title>Attaching, Allocating Memory, and Initializing a Mutex and a
        Condition Variable</title>

        <indexterm xml:id="indexterm-434">
          <primary><function>ddi_create_minor_node </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-435">
          <primary>kernel functions</primary>

          <secondary><function>ddi_create_minor_node </function></secondary>
        </indexterm>

        <para>Punkt wejścia <function>qotd_attach</function> najpierw alokuje
        i uzyskuje miękki stan urządzenia. Kod jest taki sam jak w wersji 2.
        Jeśli wywołanie <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-create-minor-node-9f"> <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> powiedzie się, funkcja
        <function>qotd_attach</function> ustawia flagię
        <literal>QOTD_DIDMINOR</literal> w nowego elementu struktury stanu
        <literal>qotd_state</literal> - <literal>flags</literal>
        member.</para>

        <para>Wersja 3. sterownika definiuje nowe cztery stałe służące do
        śledzenia czterech różnych zdarzeń. Funkcja może za pomocą tych flag
        ustalić, czy powinna uwolnić, zamknąć czy usunąć zasoby. Wszystkie
        cztery flagi ustawiane są w punkcie wejścia <function>qotd_attach
        </function>i dla każdego warunku podejmowane są odpowiednie
        działania.</para>

        <para>W punkcie wejścia <function>qotd_detach</function> działania
        sterownika są odwoływane w kolejności odwrotnej do ich występowania w
        punkcie wejścia <function>qotd_attach</function>. Funkcja
        <function>qotd_attach</function> tworzy młodszy węzeł, alokuje pamięć
        dla cytatu inicjalizuje mutex i inicjalizuje zmienną warunkową.
        Funkcja <function>qotd_detach</function> niszczy zmienną warunkową,
        niszczy mutex, uwalnia pamięć i usuwa młodszy węzeł.</para>

        <para>Po utworzeniu młodszego węzła funkcja
        <function>qotd_attach</function> alokuje pamięć na cytat. Więcej
        informacji o alokowaniu pamięci w <olink remap="internal"
        targetdoc="chapter-3.xml" targetptr="ffdqy">Allocating and Freeing
        Kernel Memory</olink>. Jeśli pamięć jest zaalokowana, funkcja
        <function>qotd_attach</function> ustawia flagę
        <literal>QOTD_DIDALLOC</literal> w elemencie <literal>flags</literal>
        struktury stanu.</para>

        <para><indexterm xml:id="indexterm-436">
            <primary><function>mutex_init </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-437">
            <primary>kernel functions</primary>

            <secondary><function>mutex_init </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-438">
            <primary><function>cv_init </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-439">
            <primary>kernel functions</primary>

            <secondary><function>cv_init </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-440">
            <primary><function>strlcpy </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-441">
            <primary>kernel functions</primary>

            <secondary><function>strlcpy </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-442">
            <primary><function>strncpy </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-443">
            <primary>kernel functions</primary>

            <secondary><function>strncpy </function></secondary>
          </indexterm>Później funkcja <function>qotd_attach</function>
        wywołuje funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="mutex-init-9f"> <citerefentry>
            <refentrytitle>mutex_init</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu inicjalizacji muteksu. Jeśli
        operacja się powiedzie, funkcja <function>qotd_attach</function>
        ustawia flagę <literal>QOTD_DIDMUTEX</literal>. Następnie funkcja
        <function>qotd_attach</function> wywołuje funkcję <olink
        remap="external" targetdoc="819-2256" targetptr="cv-init-9f">
        <citerefentry>
            <refentrytitle>cv_init</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu inicjalizacji zmiennej warunkowej.
        Jeśli ta operacja powiedzie się, funkcja
        <function>qotd_attach</function> ustawia flagę
        <literal>QOTD_DIDCV</literal>.</para>

        <para>Następnie funkcja <function>qotd_attach</function> wywołuje
        funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="strlcpy-9f"> <citerefentry>
            <refentrytitle>strlcpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu skopiowania pierwszego łańcucha z
        cytatem do nowego elementu cytatu struktury stanu urządzenia. Należy
        zauważyć, że użyto funkcji <citerefentry>
            <refentrytitle>strlcpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zamiast <olink remap="external" targetdoc="819-2256"
        targetptr="strncpy-9f"> <citerefentry>
            <refentrytitle>strncpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Funkcja <citerefentry>
            <refentrytitle>strncpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> może prowadzić do marnotrawstwa, ponieważ zawsze
        kopiuje <replaceable>n</replaceable> znaków, nawet jeśli cel jest
        mniejszy niż <replaceable>n</replaceable> znaków. Można podstawić
        funkcję <citerefentry>
            <refentrytitle>strncpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zamiast <citerefentry>
            <refentrytitle>strlcpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> i sprawdzić różnicę w zachowaniu sterownika.</para>

        <para>Na końcu wstępny cytat kopiowany jest do nowego elementu
        struktury stanu. Reszta funkcji <function>qotd_attach</function> jest
        taka sama jak w wersji 2.</para>
      </sect3>

      <sect3 xml:id="fgvsj">
        <title>Checking for Changes, Cleaning Up, and Detaching</title>

        <para>Niemal cała funkcja <function>qotd_detach</function> napisana
        jest od nowa. Najpierw sprawdza stan miękki, ponieważ musi sprawdzić
        element <literal>flags</literal> struktury stanu.</para>

        <para>Pierwsza flaga sprawdzana przez <function>qotd_detach</function>
        to <literal>QOTD_CHANGED</literal>. Flaga
        <literal>QOTD_CHANGED</literal> wskazuje, czy urządzenie jest w stanie
        początkowym i ustawiana jest przez funkcję
        <function>qotd_rw</function> oraz punkt wejścia
        <function>qotd_ioctl</function>. Flaga <literal>QOTD_CHANGED</literal>
        jest ustawiana, gdy użytkowik wykona na urządzeniu dowolną operację
        inną niż sprawdzenie stanu. Jeśli flaga
        <literal>QOTD_CHANGED</literal> została ustawiona, zmianie uległa
        wielkość lub zawartość buforu. Więcej informacji o fladze
        <literal>QOTD_CHANGED</literal> w <olink remap="internal"
        targetdoc="chapter-3.xml" targetptr="ffdra">Writing New Data</olink>.
        Odłączenie nie powiedzie się przy ustawionej fladze
        <literal>QOTD_CHANGED</literal>, ponieważ urządzenie może zawierać
        ważne dla użytkownika dane i dlatego urządzenie nie powinno być
        odłączane. Jeśli flaga <literal>QOTD_CHANGED</literal> jest ustawiona,
        funkcja <function>qotd_detach</function> zwraca błąd "urządzenie jest
        zajęte (ang. device is busy)".</para>

        <para>Po zmianie cytatu urządzenie może być odłączone tylko po
        wykonaniu komendy <command>qotdctl</command> z opcją<option>
        r</option>. Opcja<option> r</option> ponownie inicjalizuje cytat i
        wskazuje, że użytkonik nie jest już zainteresowany zawartością
        urządzenia. Więcej o komendzie <command>qotdctl</command> w <olink
        remap="internal" targetdoc="chapter-3.xml"
        targetptr="fgvsf">Exercising the Driver's I/O Controls</olink>.</para>

        <para><indexterm xml:id="indexterm-444">
            <primary><function>mutex_destroy </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-445">
            <primary>kernel functions</primary>

            <secondary><function>mutex_destroy </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-446">
            <primary><function>cv_destroy </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-447">
            <primary>kernel functions</primary>

            <secondary><function>cv_destroy </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-448">
            <primary><function>ddi_umem_free </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-449">
            <primary>kernel functions</primary>

            <secondary><function>ddi_umem_free </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-450">
            <primary><function>ddi_remove_minor_node </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-451">
            <primary>kernel functions</primary>

            <secondary><function>ddi_remove_minor_node </function></secondary>
          </indexterm>Funkcja <function>qotd_detach</function> sprawdza cztery
        flagi ustawiane w funkcji <function>qotd_attach</function>. Jeśłi
        ustawiona jest flaga <literal>QOTD_DIDCV</literal>, funkcja
        <function>qotd_detach</function> wywołuje <olink remap="external"
        targetdoc="819-2256" targetptr="cv-destroy-9f"> <citerefentry>
            <refentrytitle>cv_destroy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Jeśli ustawiona jest flaga
        <literal>QOTD_DIDMUTEX</literal>, funkcja
        <function>qotd_detach</function> wywołuje <olink remap="external"
        targetdoc="819-2256" targetptr="mutex-destroy-9f"> <citerefentry>
            <refentrytitle>mutex_destroy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Jeśli ustawiona jest flaga
        <literal>QOTD_DIDALLOC</literal>, funkcja
        <function>qotd_detach</function> wywołuje <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-umem-free-9f"> <citerefentry>
            <refentrytitle>ddi_umem_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Na końcu, jeśli ustawiona jest flaga
        <literal>QOTD_DIDMINOR</literal>, funkcja
        <function>qotd_detach</function> wywołuje <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-remove-minor-node-9f">
        <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>
      </sect3>

      <sect3 xml:id="ffdqy">
        <title>Allocating and Freeing Kernel Memory</title>

        <indexterm xml:id="indexterm-452">
          <primary><function>ddi_umem_alloc </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-453">
          <primary>kernel functions</primary>

          <secondary><function>ddi_umem_alloc </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-454">
          <primary><function>ddi_umem_free </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-455">
          <primary>kernel functions</primary>

          <secondary><function>ddi_umem_free </function></secondary>
        </indexterm>

        <para>Jeden z nowych elementów struktury stanu obsługuje zajmowanie i
        uwalnianie pamięci. Element <literal>qotd_cookie</literal> otrzymuje
        wartość z funkcji <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-umem-alloc-9f"> <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Wartość ta jest później używana do
        uwolnienia pamięci przez funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-umem-free-9f"> <citerefentry>
            <refentrytitle>ddi_umem_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <itemizedlist>
          <para>Wersja 3. sterownika Cytat Dnia alokuje pamięć jądra w trzech
          miejscach:</para>

          <listitem>
            <para>Po utworzneiu młodszego węzła</para>
          </listitem>

          <listitem>
            <para>W przypadku <literal>QOTDIOCSSZ</literal> w punkcie wejścia
            <function>qotd_ioctl</function></para>
          </listitem>

          <listitem>
            <para>W przypadku <literal>QOTDIOCDISCARD</literal> w punkcie
            wejścia <function>qotd_ioctl</function></para>
          </listitem>
        </itemizedlist>

        <para>Funkcja <function>qotd_attach</function> alokuje pamięć po
        utworzeniu młodszego węzła. alokacja pmięci jest konieczna, aby
        użytkownik mógł zmienić cytat. Funkcja <function>qotd_attach
        </function>wywołuje <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> z flagą <literal>DDI_UMEM_NOSLEEP, przez co funkcja
        </literal><citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> natychmiast wróci. Jeśli żądana ilość pamięci jest
        niedostępna, funkcja <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwraca natyhcmiast <literal>NULL</literal> i nie
        czeka na zwolnienie niezbędnej ilości pamięci. Jeśli nie uda się
        zalokować pamięci, funkcja <function>qotd_attach</function> wywołuje
        funkcję <function>qotd_detach</function> i zwraca błąd. Jeśli uda się
        zalokować pamięć, funkcja <function>qotd_attach</function> ustawia
        flagę <literal>QOTD_DIDALLOC</literal>, dzięki czemu później pamięć ta
        zostanie uwolniona przez funkcję
        <function>qotd_detach</function>.</para>

        <para>Drugie miejsce alokacji pamięci przez sterownik znajduje się w
        przypadku <literal>QOTDIOCSSZ</literal> punktu wejścia
        <function>qotd_ioctl</function>. Przypadek
        <literal>QOTDIOCSSZ</literal> ustawia nową wielkość urządzenia. Nowa
        wielkość jest ustawiana gdy użytkownik uruchomi komendę
        <command>qotdctl</command> z opcją <option>s</option>. Więcej o
        komendzie <command>qotdctl</command> w <olink remap="internal"
        targetdoc="chapter-3.xml" targetptr="fgvsf">Exercising the Driver's
        I/O Controls</olink>. Tym razem funkcja <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-umem-alloc-9f"> <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wywoływana jest z flagą
        <literal>DDI_UMEM_SLEEP</literal>, przez co <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> będzie czekać na zwolnienie wymaganej ilości
        pamięci. Powrót funkcji <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> oznacza zaalokowanie wymaganej ilości
        pamięci.</para>

        <para><indexterm xml:id="indexterm-456">
            <primary><function>kmem_alloc </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-457">
            <primary>kernel functions</primary>

            <secondary><function>kmem_alloc </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-458">
            <primary><function>kmem_zalloc </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-459">
            <primary>kernel functions</primary>

            <secondary><function>kmem_zalloc </function></secondary>
          </indexterm>Flagi <literal>DDI_UMEM_SLEEP</literal> nie można użyć w
        każdej sytuacji. W sekcjach <literal>CONTEXT</literal> stron man
        <citerefentry>
            <refentrytitle>i_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>, <olink remap="external" targetdoc="819-2256"
        targetptr="kmem-alloc-9f"> <citerefentry>
            <refentrytitle>kmem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2256" targetptr="kmem-zalloc-9f"> <citerefentry>
            <refentrytitle>kmem_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> podane są szczegółowe informacje. Należy
        także zwrócić uwagę na różnice w zachowaniu między tymi funkcjami.
        Funkcja <citerefentry>
            <refentrytitle>kmem_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> jest najwydajniejsza przy alokacji małych ilości
        pamięci. Przy większych alokacjach lepsza i szybsza jest funkcja
        <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>. Funkcja <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> używana jest w sterowniku <literal>qotd_3</literal>
        ponieważ alokuje od razu całe strony pamięci. Funkcja <citerefentry>
            <refentrytitle>kmem_zalloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> może oszczędzić pamięć, ponieważ alokuje mniejsze
        obszary. Sterownik <literal>qotd_3</literal> przedstawia zachowanie
        urządzenia pracującego jako dysk w pamięci (ang. ramdisk). W przypadku
        produkcyjnego ramdysku należy używać <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do alokowania pamięci w stronach.</para>

        <para>Po skopiowaniu aktualnego cytatu do nowej przestrzeni funkcja
        <function>qotd_ioctl</function> wywołuje <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-umem-free-9f"> <citerefentry>
            <refentrytitle>ddi_umem_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w celu uwolnienia wcześniej zaalokowanej
        pamięci.</para>

        <para>Trzecie miescje, w którym alokowana jest pamięć to przypadek
        <literal>QOTDIOCDISCARD</literal> w punkcie wejścia
        <function>qotd_ioctl</function>. Przypadek
        <literal>QOTDIOCDISCARD</literal> wywoływany jest z komendy
        <command>qotdctl</command>. Komenda <command>qotdctl</command> z
        opcją<option> r</option> resetuje cytat. Jeśli ilość zaalokowanych
        bajtów różna jest od początkowej ilości zaalokowanych bajtów,
        alokowany jest nowy obszar pamięci w celu zresetowania cytatu.
        Ponownie użyta jest flaga <literal>DDI_UMEM_SLEEP</literal> aby
        zapewnić, że po powrocie funkcji <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-umem-alloc-9f"> <citerefentry>
            <refentrytitle>ddi_umem_alloc</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> zaalokowana jest żądana ilość pamięci.
        Funkcja <function>qotd_ioctl </function> wywołuje wtedy funkcję <olink
        remap="external" targetdoc="819-2256" targetptr="ddi-umem-free-9f">
        <citerefentry>
            <refentrytitle>ddi_umem_free</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do uwolnienia wcześniej zaalokowanej
        pamięci.</para>
      </sect3>

      <sect3 xml:id="ffzre">
        <title>Managing Thread Synchronization</title>

        <indexterm xml:id="indexterm-460">
          <primary>thread synchronization</primary>
        </indexterm>

        <indexterm xml:id="indexterm-461">
          <primary>device drivers</primary>

          <secondary>thread synchronization</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-462">
          <primary>mutexes</primary>
        </indexterm>

        <indexterm xml:id="indexterm-463">
          <primary>device drivers</primary>

          <secondary>mutexes</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-464">
          <primary>condition variables</primary>
        </indexterm>

        <indexterm xml:id="indexterm-465">
          <primary>device drivers</primary>

          <secondary>condition variables</secondary>
        </indexterm>

        <para>Wersja 3. sterownika Cytat Dnia korzysta ze zmiennych
        warunkowych oraz wzajemnie wykluczające się zamki (ang. mutual
        exclusion locks = mutex) do synchronizacji wątków. Więcej informacji o
        muteksach, zmiennych warunkowych i synchronizacji wątków w <olink
        remap="external" targetdoc="816-5137"> <citetitle
        remap="book">Multithreaded Programming Guide</citetitle>
        </olink>.</para>

        <para>W sterowniku mutex i zmienna warunkowa inicjalizowane są w
        punkcie wejścia <function>qotd_attach</function> i niszczone w punkcie
        wejścia <function>qotd_detach</function>. Test zmiennej warunkowej
        wykonywany jest w funkcji <function>qotd_rw</function> i w punkcie
        wejścia <function>qotd_ioctl</function>.</para>

        <para><indexterm xml:id="indexterm-466">
            <primary><literal>QOTD_BUSY</literal> condition</primary>
          </indexterm>Zmienna warunkowa powoduje czekanie w warunku
        <literal>QOTD_BUSY</literal>. Warunek ten jest konieczny, ponieważ
        sterownik musi wykonać operacje zależne od wyłącznego dostępu do
        wewnętrznych struktur bez utrzymywania zamka. Dostęp do buforu lub
        jego metadanych wymaga wzajemnego wykluczenia, ale sterownik nie może
        blokować, jeśli operacja może przejść w stan uśpienia. Dlatego zamiast
        zakładać blokadę, sterownik czeka w warunku
        <literal>QOTD_BUSY</literal>.</para>

        <para>Sterownik zakłada mutex podczas sprawdzania zmiennej warunkowej
        i dostępu do buforu. Mutex chroni bufor. Gdyby nie użyto wzajemnie
        wyłączającej blokady na buforze jeden z proces użytkownika mógłby
        zmienić rozmiar buforuy w tym samym momencie, gdy drugi proces
        próbowałby go odczytać. Wynikiem niechronionoego dostępu do buforu
        mogłoby być uszkodzenie danych lub panika jądra.</para>

        <para><indexterm xml:id="indexterm-467">
            <primary><function>uiomove </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-468">
            <primary>kernel functions</primary>

            <secondary><function>uiomove </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-469">
            <primary><function>ddi_copyin </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-470">
            <primary>kernel functions</primary>

            <secondary><function>ddi_copyin </function></secondary>
          </indexterm>Zmienna warunkowa używana jest w połączeniu z funkcjami,
        które mogą przechodzić w stan uśpienia. Takie funkcje to <olink
        remap="external" targetdoc="819-2256" targetptr="ddi-copyin-9f">
        <citerefentry>
            <refentrytitle>ddi_copyin</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-copyout-9f"> <citerefentry>
            <refentrytitle>ddi_copyout</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2256" targetptr="uiomove-9f"> <citerefentry>
            <refentrytitle>uiomove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Funkcja alokująca pamięć może przchodzić w
        stan uśpienia, jeśli użyto flagi <literal>SLEEP</literal>. Podczas
        uśpienia funkcjom nie wolno utrzymywać muteksu, może to bowiem
        doprowadzić do zakleszczenia. Jeśli funkcja może przechodzić w stan
        uśpienia, należy ustawić flagę <literal>QOTD_BUSY</literal> i zająć
        zmienną warunkową, co spowoduje zdjęcie muteksu. Wyścigu unika się
        przez zezwolenie na ustawienie i zdjęcie flagi
        <literal>QOTD_BUSY</literal> tylko wtedy, gdy utrzymuje się mutex.
        Więcej informacji o zakleszczeniach w <olink remap="external"
        targetdoc="816-5137" targetptr="sync-110"> <citetitle
        remap="section">Using Mutual Exclusion Locks</citetitle> in <citetitle
        remap="book">Multithreaded Programming Guide</citetitle> </olink> i
        <olink remap="external" targetdoc="816-5137" targetptr="guide-35930">
        <citetitle remap="section">Avoiding Deadlock</citetitle> in <citetitle
        remap="book">Multithreaded Programming Guide</citetitle>
        </olink>.</para>

        <sect4 xml:id="fgpaf">
          <title>Locking Rules for Quote Of The Day Version 3</title>

          <orderedlist>
            <para><indexterm xml:id="indexterm-471">
                <primary>devices</primary>

                <secondary>exclusive access</secondary>
              </indexterm> <indexterm xml:id="indexterm-472">
                <primary><literal>QOTD_BUSY</literal> condition</primary>
              </indexterm>Reguły blokowania dla sterownika
            <literal>qotd_3</literal>:</para>

            <listitem>
              <para>Do wykonania poniższych operacji wymagany jest wyłączny
              dostęp. Wyłączny dostęp uzyskuje się przez założeneue muteksu
              albo ustawianie flagi <literal>QOTD_BUSY</literal>. Kiedy
              ustawiona jest flaga <literal>QOTD_BUSY</literal> wątki muszą
              czekać.</para>

              <itemizedlist>
                <listitem>
                  <para>Sprawdzenie zawartości buforu.</para>
                </listitem>

                <listitem>
                  <para>Zmiana zawartości buforu.</para>
                </listitem>

                <listitem>
                  <para>Zmiana wielkości buforu.</para>
                </listitem>

                <listitem>
                  <para>Zmiana wartośći zmiennych wskazujących adres
                  buforu.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <orderedlist>
                <para>Jeśli działanie nie wymaga uśpienia, można wykonać
                następujące kroki:</para>

                <listitem>
                  <para>Założenie muteksu.</para>
                </listitem>

                <listitem>
                  <para>Oczekiwanie na zdjęcie flagi
                  <literal>QOTD_BUSY</literal>. Jeśli wątek ustawiający
                  <literal>QOTD_BUSY</literal> zdejmuje flagę
                  <literal>QOTD_BUSY</literal>, wątek ten powinien wysłać
                  sygnał do pozostałych wątków czekających na zdjęcie flagi i
                  zdjąć mutex.</para>
                </listitem>

                <listitem>
                  <para>Wykonanie działania. Ustawienie flagi
                  <literal>QOTD_BUSY</literal> nie jest konieczne przed
                  wykonaniem działania.</para>
                </listitem>

                <listitem>
                  <para>Zdjęcie muteksu.</para>
                </listitem>
              </orderedlist>

              <para>Poniższy przykładowy kod ilustruje tę regułę:</para>

              <programlisting>mutex_enter(&amp;qsp-&gt;lock);
while (qsp-&gt;flags &amp; QOTD_BUSY) {
        if (cv_wait_sig(&amp;qsp-&gt;cv, &amp;qsp-&gt;lock) == 0) {
                mutex_exit(&amp;qsp-&gt;lock);
                ddi_umem_free(new_cookie);
                return (EINTR);
        }
}
memcpy(new_qotd, qsp-&gt;qotd, min(qsp-&gt;qotd_len, new_len));
ddi_umem_free(qsp-&gt;qotd_cookie);
qsp-&gt;qotd = new_qotd;
qsp-&gt;qotd_cookie = new_cookie;
qsp-&gt;qotd_len = new_len;
qsp-&gt;flags |= QOTD_CHANGED;
mutex_exit(&amp;qsp-&gt;lock);</programlisting>
            </listitem>

            <listitem>
              <orderedlist>
                <para>Jeśli operacja musi spać, należy wykonać następujące
                kroki:</para>

                <listitem>
                  <para>Założenie muteksu.</para>
                </listitem>

                <listitem>
                  <para>Ustawienie <literal>QOTD_BUSY</literal>.</para>
                </listitem>

                <listitem>
                  <para>Zdjęcie muteksu.</para>
                </listitem>

                <listitem>
                  <para>Wykonanie działania.</para>
                </listitem>

                <listitem>
                  <para>Ponowne założenie muteksu.</para>
                </listitem>

                <listitem>
                  <para>Wysłanie sygnału do wątków czekających na
                  wyczyszczenie zmiennej warunkowej.</para>
                </listitem>

                <listitem>
                  <para>Zdjęcie muteksu.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </orderedlist>

          <para>Reguły te są dość proste i zapewniają spójny dostęp do buforu
          i jego metadanych. Prawdziwe sterowniki mają prawdopodobnie bardziej
          skomplikowane wymagania odnośnie blokowania. Na przykład sterowniki
          używające ring buffers lub zarządzają wieloma zestawami rejestrów
          albo wieloma urządzeniami mają bardziej skomplikowane reguły
          blokowania.</para>
        </sect4>

        <sect4 xml:id="fgvsa">
          <title>Lock and Condition Variable Members of the State
          Structure</title>

          <indexterm xml:id="indexterm-473">
            <primary><function>mutex </function> kernel function</primary>
          </indexterm>

          <indexterm xml:id="indexterm-474">
            <primary>kernel functions</primary>

            <secondary><function>mutex </function></secondary>
          </indexterm>

          <indexterm xml:id="indexterm-475">
            <primary><function>cv_wait_sig </function> kernel
            function</primary>
          </indexterm>

          <indexterm xml:id="indexterm-476">
            <primary>kernel functions</primary>

            <secondary><function>cv_wait_sig </function></secondary>
          </indexterm>

          <indexterm xml:id="indexterm-477">
            <primary><function>condvar </function> kernel functions</primary>
          </indexterm>

          <indexterm xml:id="indexterm-478">
            <primary>kernel functions</primary>

            <secondary><function>condvar </function></secondary>
          </indexterm>

          <itemizedlist>
            <para>Struktura stanu wersji 3. sterownika Cytat Dania ma dwa nowe
            elementy wspomagające synchronizację wątków:</para>

            <listitem>
              <para>Element <literal>lock</literal> używany jest do zakładania
              i zdejmowania miteksów dla aktualnej instancji sterownika.
              Element <literal>lock</literal> jest argumentem dla każdego
              wywołania funkcji <olink remap="external" targetdoc="819-2256"
              targetptr="mutex-9f"> <citerefentry>
                  <refentrytitle>mutex</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> </olink>. <literal>lock</literal> jest także
              używany jako argument wywołania funkcji <olink remap="external"
              targetdoc="819-2256" targetptr="cv-wait-sig-9f"> <citerefentry>
                  <refentrytitle>cv_wait_sig</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> </olink>. W wywołaniu funkcji <citerefentry>
                  <refentrytitle>cv_wait_sig</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> wartość <literal>lock</literal> gwarantuje, że
              warunek nie zmieni się przed powrotem z funkcji <citerefentry>
                  <refentrytitle>cv_wait_sig</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry>.</para>
            </listitem>

            <listitem>
              <para>Element <literal>cv</literal> jest zmienną warunkową i
              jest argumentem każdego wywołania funkcji <olink
              remap="external" targetdoc="819-2256" targetptr="condvar-9f">
              <citerefentry>
                  <refentrytitle>condvar</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> </olink> (<literal>cv_</literal>).</para>
            </listitem>
          </itemizedlist>
        </sect4>

        <sect4 xml:id="fgvsd">
          <title>Creating and Destroying Locks and Condition Variables</title>

          <para>Wersja 3. sterownika Cytat Dnia definiuje dwie stałe
          zapewniające zniszczenie muteksu i zmiennej warunkowej, kiedy
          sterownik przestanie ich używać. Sterownik używa tych stałych do
          ustawiania i zdejmowania nowego elementu struktury stanu:
          <literal>flags</literal>.</para>

          <itemizedlist>
            <listitem>
              <para><indexterm xml:id="indexterm-479">
                  <primary><function>mutex_init </function> kernel
                  function</primary>
                </indexterm> <indexterm xml:id="indexterm-480">
                  <primary>kernel functions</primary>

                  <secondary><function>mutex_init </function></secondary>
                </indexterm> <indexterm xml:id="indexterm-481">
                  <primary><function>mutex_destroy </function> kernel
                  function</primary>
                </indexterm> <indexterm xml:id="indexterm-482">
                  <primary>kernel functions</primary>

                  <secondary><function>mutex_destroy </function></secondary>
                </indexterm> <indexterm xml:id="indexterm-483">
                  <primary><function>cv_init </function> kernel
                  function</primary>
                </indexterm> <indexterm xml:id="indexterm-484">
                  <primary>kernel functions</primary>

                  <secondary><function>cv_init </function></secondary>
                </indexterm> <indexterm xml:id="indexterm-485">
                  <primary><function>cv_destroy </function> kernel
                  function</primary>
                </indexterm> <indexterm xml:id="indexterm-486">
                  <primary>kernel functions</primary>

                  <secondary><function>cv_destroy </function></secondary>
                </indexterm>Flaga <literal>QOTD_DIDMUTEX</literal> ustawiana
              jest w punkcie wejśćia <function>qotd_attach</function>
              natychmiast po udanym wywołaniu <olink remap="external"
              targetdoc="819-2256" targetptr="mutex-init-9f"> <citerefentry>
                  <refentrytitle>mutex_init</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> </olink>. Jeśli flaga
              <literal>QOTD_DIDMUTEX</literal> będzie ustawiona w punkcie
              wejścia <function>qotd_detach</function>, wtedy punkt wejścia
              <function>qotd_detach</function> wywołuje funkcję <olink
              remap="external" targetdoc="819-2256"
              targetptr="mutex-destroy-9f"> <citerefentry>
                  <refentrytitle>mutex_destroy</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> </olink>.</para>
            </listitem>

            <listitem>
              <para>Flaga <literal>QOTD_DIDCV</literal> ustawiana jest w
              punkcie wejścia <function>qotd_attach </function>natyc hmiast po
              udanym wywołaniu <olink remap="external" targetdoc="819-2256"
              targetptr="cv-init-9f"> <citerefentry>
                  <refentrytitle>cv_init</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> </olink>. Jeśli flaga
              <literal>QOTD_DIDCV</literal> jest ustawiona w punkcie wejścia
              <function>qotd_detach</function>, punkt wejścia
              <function>qotd_detach</function> wywołuje funkcję <olink
              remap="external" targetdoc="819-2256" targetptr="cv-destroy-9f">
              <citerefentry>
                  <refentrytitle>cv_destroy</refentrytitle>

                  <manvolnum>9F</manvolnum>
                </citerefentry> </olink>.</para>
            </listitem>
          </itemizedlist>
        </sect4>

        <sect4 xml:id="fgvsc">
          <title>Waiting on Signals</title>

          <indexterm xml:id="indexterm-487">
            <primary><function>cv_wait_sig </function> kernel
            function</primary>
          </indexterm>

          <indexterm xml:id="indexterm-488">
            <primary>kernel functions</primary>

            <secondary><function>cv_wait_sig </function></secondary>
          </indexterm>

          <indexterm xml:id="indexterm-489">
            <primary><function>signal </function> function</primary>
          </indexterm>

          <indexterm xml:id="indexterm-490">
            <primary>functions</primary>

            <secondary><function>signal </function></secondary>
          </indexterm>

          <indexterm xml:id="indexterm-491">
            <primary><function>cv_signal </function> kernel function</primary>
          </indexterm>

          <indexterm xml:id="indexterm-492">
            <primary>kernel functions</primary>

            <secondary><function>cv_signal </function></secondary>
          </indexterm>

          <indexterm xml:id="indexterm-493">
            <primary><function>cv_broadcast </function> kernel
            function</primary>
          </indexterm>

          <indexterm xml:id="indexterm-494">
            <primary>kernel functions</primary>

            <secondary><function>cv_broadcast </function></secondary>
          </indexterm>

          <indexterm xml:id="indexterm-495">
            <primary><function>cv_wait </function> kernel function</primary>
          </indexterm>

          <indexterm xml:id="indexterm-496">
            <primary>kernel functions</primary>

            <secondary><function>cv_wait </function></secondary>
          </indexterm>

          <para>Wywołania <olink remap="external" targetdoc="819-2256"
          targetptr="cv-wait-sig-9f"><citerefentry>
              <refentrytitle>cv_wait_sig</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry></olink> w funkcjach <function>qotd_rw</function> i
          <function>qotd_ioctl</function> oczekują na sygnał dla zmiennej
          warunkowej, że można kontynuować, albo na odebranie <olink
          remap="external" targetdoc="819-2243" targetptr="signal-3c">
          <citerefentry>
              <refentrytitle>signal</refentrytitle>

              <manvolnum>3C</manvolnum>
            </citerefentry> </olink>. Jedna z funkcji <olink remap="external"
          targetdoc="819-2256" targetptr="cv-signal-9f"> <citerefentry>
              <refentrytitle>cv_signal</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> i <olink remap="external"
          targetdoc="819-2256" targetptr="cv-broadcast-9f"> <citerefentry>
              <refentrytitle>cv_broadcast</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> wysyła sygnał do zmiennej warunkowej o
          możliwości kontynuowania.</para>

          <para>Wątek może oczekiwać na zmienną warunkową dopóki zmienna nie
          otrzyma sygnału, bądź do procesu wysłany zostanie <olink
          remap="external" targetdoc="819-2243" targetptr="signal-3c">
          <citerefentry>
              <refentrytitle>signal</refentrytitle>

              <manvolnum>3C</manvolnum>
            </citerefentry> </olink>. Funkcja <olink remap="external"
          targetdoc="819-2256" targetptr="cv-wait-9f"> <citerefentry>
              <refentrytitle>cv_wait</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> oczekuje na sygnał dla zmiennej
          warunkowej, ale sama ignoruje sygnały <citerefentry>
              <refentrytitle>signal</refentrytitle>

              <manvolnum>3C</manvolnum>
            </citerefentry>. Opisywany sterownik korzysta z funkcji <olink
          remap="external" targetdoc="819-2256" targetptr="cv-wait-sig-9f">
          <citerefentry>
              <refentrytitle>cv_wait_sig</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> zamiast <citerefentry>
              <refentrytitle>cv_wait</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>, ponieważ musi zareagować na sygnał otrzymany
          przez proces wykonujący operację. Jeśli proces otrzyma <citerefentry>
              <refentrytitle>signal</refentrytitle>

              <manvolnum>3C</manvolnum>
            </citerefentry>, musi zwrócić błąd przerwania i nie kończy
          operacji. Zazwyczaj preferowana jest funkcja <citerefentry>
              <refentrytitle>cv_wait_sig</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> zamiast <citerefentry>
              <refentrytitle>cv_wait</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>, ponieważ jej implementacja pozwala na
          precyzyjnieszą reakcję programu. Funkcja <citerefentry>
              <refentrytitle>signal</refentrytitle>

              <manvolnum>3C</manvolnum>
            </citerefentry> wywołuje efekt podobny do do momentu wykonania, w
          którym proces znajdował się w momencie uzyskania <citerefentry>
              <refentrytitle>signal</refentrytitle>

              <manvolnum>3C</manvolnum>
            </citerefentry>.</para>

          <para>W niektórych przypadkach użycie funkcji <citerefentry>
              <refentrytitle>cv_wait_sig</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> jest niemożliwe, ponieważ sterownik nie powinien
          akceptować przerwań od <citerefentry>
              <refentrytitle>signal</refentrytitle>

              <manvolnum>3C</manvolnum>
            </citerefentry>. Nie można na przykład użyć funkcji <citerefentry>
              <refentrytitle>cv_wait_sig</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> podczas transferu DMA, który sam spowoduje później
          przerwanie. W tym przypadku, jeśli wywołanie <citerefentry>
              <refentrytitle>cv_wait_sig</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> zostanie przerwane, dane z zakończonego transferu
          DMA nie mają się gdzie podziać i sterownik spanikuje.</para>
        </sect4>
      </sect3>

      <sect3 xml:id="ffdra">
        <title>Writing New Data</title>

        <indexterm xml:id="indexterm-497">
          <primary>devices</primary>

          <secondary>writing</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-498">
          <primary><literal>cb_ops</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-499">
          <primary>driver structures</primary>

          <secondary><literal>cb_ops</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-500">
          <primary>entry points</primary>

          <secondary><function>write </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-501">
          <primary><function>write </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-502">
          <primary>entry points</primary>

          <secondary><function>ioctl </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-503">
          <primary><function>ioctl </function> entry point</primary>
        </indexterm>

        <para>Struktura <olink remap="external" targetdoc="819-2257"
        targetptr="cb-ops-9s"> <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> w wersji 3. sterownika Cytat Dnia deklaruje
        dwa nowe punkty wejścia obsługujące zmianę cytatu. Są to: <olink
        remap="external" targetdoc="819-2255" targetptr="write-9e">
        <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="ioctl-9e"> <citerefentry>
            <refentrytitle>ioctl</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>. Funkcja <function>qotd_rw </function> to
        trzecia nowa funkcja w wersji 3. sterownika. Funkcja
        <function>qotd_rw</function> wywoływana jest przez punkty wejścia
        <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> oraz <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Struktura stanu zawiera w tej wersji dwa nowe elementy używane
        do modyfikowania cytatu. Zmienna łańcuchowa <literal>qotd</literal>
        przechowuje treść aktualnej instancji urządzenia. Element
        <literal>qotd_len</literal> przechowuje długość aktualnego cytatu
        liczoną w bajtach.</para>

        <para>Version 3 of the driver also defines two new constants that
        support modifying the quotation. In place of
        <literal>QOTD_MAXLEN</literal>, Version 3 of the driver defines
        <literal>QOTD_MAX_LEN</literal>. <literal>QOTD_MAX_LEN</literal> is
        used in the <function>qotd_ioctl </function> entry point to test
        whether the user has entered a string that is too long. Version 3 of
        the driver also defines <literal>QOTD_CHANGED</literal>. The
        <literal>QOTD_CHANGED</literal> flag is set in the <function>qotd_rw
        </function> routine and in the <function>qotd_ioctl </function> entry
        point when a new quotation is copied from the user.</para>

        <para>When the <literal>qotd_3</literal> device is opened for writing,
        the kernel calls the <function>qotd_write </function> entry point. The
        <function>qotd_write </function> entry point then calls the
        <function>qotd_rw </function> routine and passes a
        <literal>UIO_WRITE</literal> flag. The new <function>qotd_read
        </function> entry point is exactly the same as the
        <function>qotd_write </function> entry point, except that the
        <function>qotd_read </function> entry point passes a
        <literal>UIO_READ</literal> flag. The <function>qotd_rw </function>
        routine supports both reading and writing the device and thereby
        eliminates much duplicate code.</para>

        <para><indexterm xml:id="indexterm-504">
            <primary><literal>uio</literal> kernel structure</primary>
          </indexterm> <indexterm xml:id="indexterm-505">
            <primary>kernel structures</primary>

            <secondary><literal>uio</literal></secondary>
          </indexterm>The <function>qotd_rw </function> routine first gets the
        device soft state. Then the <function>qotd_rw </function> routine
        checks the length of the I/O request in the <olink remap="external"
        targetdoc="819-2257" targetptr="uio-9s"> <citerefentry>
            <refentrytitle>uio</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> I/O request structure. If this length is
        zero, the <function>qotd_rw </function> routine returns zero. If this
        length is not zero, the <function>qotd_rw </function> routine enters a
        mutex.</para>

        <para><indexterm xml:id="indexterm-506">
            <primary><function>signal </function> function</primary>
          </indexterm> <indexterm xml:id="indexterm-507">
            <primary>functions</primary>

            <secondary><function>signal </function></secondary>
          </indexterm>While the device is busy, the <function>qotd_rw
        </function> routine checks whether the condition variable has been
        signaled or a <olink remap="external" targetdoc="819-2243"
        targetptr="signal-3c"> <citerefentry>
            <refentrytitle>signal</refentrytitle>

            <manvolnum>3C</manvolnum>
          </citerefentry> </olink> is pending. If either of these conditions
        is true, the <function>qotd_rw </function> routine exits the mutex and
        returns an error.</para>

        <para>When the device is not busy, the <function>qotd_rw </function>
        routine checks whether the data offset in the <olink remap="external"
        targetdoc="819-2257" targetptr="uio-9s"> <citerefentry>
            <refentrytitle>uio</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> I/O request structure is valid. If the
        offset is not valid, the <function>qotd_rw </function> routine exits
        the mutex and returns an error. If the offset is valid, the local
        length variable is set to the difference between the offset in the I/O
        request structure and the length in the device state structure. If
        this difference is zero, the <function>qotd_rw </function> routine
        exits the mutex and returns. If the device was opened for writing, the
        <function>qotd_rw </function> routine returns a space error.
        Otherwise, the <function>qotd_rw </function> routine returns
        zero.</para>

        <para><indexterm xml:id="indexterm-508">
            <primary><function>uiomove </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-509">
            <primary>kernel functions</primary>

            <secondary><function>uiomove </function></secondary>
          </indexterm>The <function>qotd_rw </function> routine then sets the
        <literal>QOTD_BUSY</literal> flag in the <literal>flags</literal>
        member of the device state structure and exits the mutex. The
        <function>qotd_rw </function> routine then calls the <olink
        remap="external" targetdoc="819-2256" targetptr="uiomove-9f">
        <citerefentry>
            <refentrytitle>uiomove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function to copy the quotation. If the
        <literal>rw</literal> argument is <literal>UIO_READ</literal>, then
        the quotation is transferred from the state structure to the I/O
        request structure. If the <literal>rw</literal> argument is
        <literal>UIO_WRITE</literal>, then the quotation is transferred from
        the I/O request structure to the state structure.</para>

        <para><indexterm xml:id="indexterm-510">
            <primary><function>cv_broadcast </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-511">
            <primary>kernel functions</primary>

            <secondary><function>cv_broadcast </function></secondary>
          </indexterm>The <function>qotd_rw </function> routine then enters a
        mutex again. If the device was opened for writing, the
        <function>qotd_rw </function> routine sets the
        <literal>QOTD_CHANGED</literal> flag. The <function>qotd_rw
        </function> routine then sets the device to not busy, calls <olink
        remap="external" targetdoc="819-2256" targetptr="cv-broadcast-9f">
        <citerefentry>
            <refentrytitle>cv_broadcast</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> to unblock any threads that were blocked on
        this condition variable, and exits the mutex.</para>

        <para>Finally, the <function>qotd_rw </function> routine returns the
        quotation. The quotation is written to the device node.</para>
      </sect3>

      <sect3 xml:id="fgham">
        <title>Reporting and Setting Device Size and Re-initializing the
        Device</title>

        <indexterm xml:id="indexterm-512">
          <primary>I/O controls</primary>
        </indexterm>

        <indexterm xml:id="indexterm-513">
          <primary>device drivers</primary>

          <secondary>I/O controls</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-514">
          <primary>entry points</primary>

          <secondary><function>ioctl </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-515">
          <primary><function>ioctl </function> entry point</primary>
        </indexterm>

        <para>The behavior of the <olink remap="external" targetdoc="819-2255"
        targetptr="ioctl-9e"> <citerefentry>
            <refentrytitle>ioctl</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> entry point depends on the command value
        passed in to the entry point. These constants are defined in the new
        <filename>qotd.h</filename> header file. The <function>qotd_ioctl
        </function> routine reports the size of the space allocated for the
        quotation, sets a new amount of space to allocate for the quotation,
        or resets the quotation back to its initial value.</para>

        <para>If the request is to report the size of the space allocated for
        the quotation, then the <function>qotd_ioctl </function> routine first
        sets a local size variable to the value of the quotation length in the
        state structure. If the device was not opened for reading, the
        <function>qotd_ioctl </function> routine returns an error.</para>

        <para><indexterm xml:id="indexterm-516">
            <primary><function>ddi_model_convert_from </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-517">
            <primary>kernel functions</primary>

            <secondary><function>ddi_model_convert_from
            </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-518">
            <primary><function>ddi_copyout </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-519">
            <primary>kernel functions</primary>

            <secondary><function>ddi_copyout </function></secondary>
          </indexterm>Because the <function>qotd_ioctl </function> routine
        transfers data between kernel space and user space, the
        <function>qotd_ioctl </function> routine must check whether both
        spaces are using the same data model. If the return value of the
        <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-model-convert-from-9f"> <citerefentry>
            <refentrytitle>ddi_model_convert_from</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function is
        <literal>DDI_MODEL_ILP32</literal>, then the driver must convert to
        32-bit data before calling <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-copyout-9f"> <citerefentry>
            <refentrytitle>ddi_copyout</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> to transfer the current size of the
        quotation space. If the return value of the <citerefentry>
            <refentrytitle>ddi_model_convert_from</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function is <literal>DDI_MODEL_NONE</literal>, then
        no data type conversion is necessary.</para>

        <para>If the request is to set a new size for the space allocated for
        the quotation, then the <function>qotd_ioctl </function> routine first
        sets local variables for the new size, the new quotation, and a new
        memory allocation cookie. If the device was not opened for writing,
        the <function>qotd_ioctl </function> routine returns an error.</para>

        <para><indexterm xml:id="indexterm-520">
            <primary><function>ddi_copyin </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-521">
            <primary>kernel functions</primary>

            <secondary><function>ddi_copyin </function></secondary>
          </indexterm>The <function>qotd_ioctl </function> routine then checks
        again for data model mismatch. If the return value of the <olink
        remap="external" targetdoc="819-2256"
        targetptr="ddi-model-convert-from-9f"> <citerefentry>
            <refentrytitle>ddi_model_convert_from</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function is
        <literal>DDI_MODEL_ILP32</literal>, then the driver declares a 32-bit
        size variable to receive the new size from <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-copyin-9f"> <citerefentry>
            <refentrytitle>ddi_copyin</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. When the new size is received, the size is
        converted to the data type of the kernel space.</para>

        <para>If the new size is zero or is greater than
        <literal>QOTD_MAX_LEN</literal>, the <function>qotd_ioctl </function>
        routine returns an error. If the new size is valid, then the
        <function>qotd_ioctl </function> routine allocates new memory for the
        quotation and enters a mutex.</para>

        <para><indexterm xml:id="indexterm-522">
            <primary><function>signal </function> function</primary>
          </indexterm> <indexterm xml:id="indexterm-523">
            <primary>functions</primary>

            <secondary><function>signal </function></secondary>
          </indexterm>While the device is busy, the <function>qotd_ioctl
        </function> routine checks whether the condition variable has been
        signaled or a <olink remap="external" targetdoc="819-2243"
        targetptr="signal-3c"> <citerefentry>
            <refentrytitle>signal</refentrytitle>

            <manvolnum>3C</manvolnum>
          </citerefentry> </olink> is pending. If either of these conditions
        is true, the <function>qotd_ioctl </function> routine exits the mutex,
        frees the new memory it allocated, and returns an error.</para>

        <para><indexterm xml:id="indexterm-524">
            <primary><function>memcpy </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-525">
            <primary>kernel functions</primary>

            <secondary><function>memcpy </function></secondary>
          </indexterm>When the device is not busy, the <function>qotd_ioctl
        </function> routine uses <olink remap="external" targetdoc="819-2256"
        targetptr="memcpy-9f"> <citerefentry>
            <refentrytitle>memcpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> to copy the quotation from the driver's
        state structure to the new space. The <function>qotd_ioctl </function>
        routine then frees the memory currently pointed to by the state
        structure, and updates the state structure members to the new values.
        The <function>qotd_ioctl </function> routine then sets the
        <literal>QOTD_CHANGED</literal> flag, exits the mutex, and
        returns.</para>

        <para>If the request is to discard the current quotation and reset to
        the initial quotation, then the <function>qotd_ioctl </function>
        routine first sets local variables for the new quotation and a new
        memory allocation cookie. If the device was not opened for writing,
        the <function>qotd_ioctl </function> routine returns an error. If the
        space allocated for the current quotation is different from the space
        allocated for the initial quotation, then the <function>qotd_ioctl
        </function> routine allocates new memory that is the size of the
        initial space and enters a mutex.</para>

        <para>While the device is busy, the <function>qotd_ioctl </function>
        routine checks whether the condition variable has been signaled or a
        <olink remap="external" targetdoc="819-2243" targetptr="signal-3c">
        <citerefentry>
            <refentrytitle>signal</refentrytitle>

            <manvolnum>3C</manvolnum>
          </citerefentry> </olink> is pending. If either of these conditions
        is true, the <function>qotd_ioctl </function> routine exits the mutex,
        frees the new memory it allocated, and returns an error.</para>

        <para><indexterm xml:id="indexterm-526">
            <primary><function>bzero </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-527">
            <primary>kernel functions</primary>

            <secondary><function>bzero </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-528">
            <primary><function>strlcpy </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-529">
            <primary>kernel functions</primary>

            <secondary><function>strlcpy </function></secondary>
          </indexterm>When the device is not busy, the <function>qotd_ioctl
        </function> routine frees the memory currently pointed to by the state
        structure, updates the memory state structure members to the new
        values, and resets the length to its initial value. If the size of the
        current quotation space was the same as the initial size and no new
        memory was allocated, then <function>qotd_ioctl </function> calls
        <olink remap="external" targetdoc="819-2256" targetptr="bzero-9f">
        <citerefentry>
            <refentrytitle>bzero</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> to clear the current quotation. The
        <function>qotd_ioctl </function> routine then calls the <olink
        remap="external" targetdoc="819-2256" targetptr="strlcpy-9f">
        <citerefentry>
            <refentrytitle>strlcpy</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function to copy the initial quotation
        string to the quotation member of the state structure. The
        <function>qotd_ioctl </function> routine then unsets the
        <literal>QOTD_CHANGED</literal> flag, exits the mutex, and
        returns.</para>

        <para>Once the <literal>QOTD_CHANGED</literal> flag has been set, the
        only way to unset it is to run the <command>qotdctl</command> command
        with the <option> r</option> option. See <olink remap="internal"
        targetdoc="chapter-3.xml" targetptr="fgvsf">Exercising the Driver's
        I/O Controls</olink> for more information about the
        <command>qotdctl</command> command.</para>
      </sect3>

      <sect3 xml:id="ffdqw">
        <title>Quote Of The Day Version 3 Source</title>

        <para>Enter the source code shown in the following example into a text
        file named <filename>qotd_3.c</filename>.</para>

        <example xml:id="ffdqz">
          <title>Quote Of The Day Version 3 Source File</title>

          <programlisting>#include &lt;sys/types.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/errno.h&gt;
#include &lt;sys/open.h&gt;
#include &lt;sys/cred.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ksynch.h&gt;
#include &lt;sys/modctl.h&gt;
#include &lt;sys/conf.h&gt;
#include &lt;sys/devops.h&gt;
#include &lt;sys/debug.h&gt;
#include &lt;sys/cmn_err.h&gt;
#include &lt;sys/ddi.h&gt;
#include &lt;sys/sunddi.h&gt;

#include "qotd.h"

#define QOTD_NAME       "qotd_3"

static const char init_qotd[]
        = "On the whole, I'd rather be in Philadelphia. - W. C. Fields\n";
static const size_t init_qotd_len = 128;

#define QOTD_MAX_LEN    65536           /* Maximum quote in bytes */
#define QOTD_CHANGED    0x1             /* User has made modifications */
#define QOTD_DIDMINOR   0x2             /* Created minors */
#define QOTD_DIDALLOC   0x4             /* Allocated storage space */
#define QOTD_DIDMUTEX   0x8             /* Created mutex */
#define QOTD_DIDCV      0x10            /* Created cv */
#define QOTD_BUSY       0x20            /* Device is busy */

static void *qotd_state_head;

struct qotd_state {
        int             instance;
        dev_info_t      *devi;
        kmutex_t        lock;
        kcondvar_t      cv;
        char            *qotd;
        size_t          qotd_len;
        ddi_umem_cookie_t qotd_cookie;
        int             flags;
};

static int qotd_getinfo(dev_info_t *, ddi_info_cmd_t, void *, void **);
static int qotd_attach(dev_info_t *, ddi_attach_cmd_t);
static int qotd_detach(dev_info_t *, ddi_detach_cmd_t);
static int qotd_open(dev_t *, int, int, cred_t *);
static int qotd_close(dev_t, int, int, cred_t *);
static int qotd_read(dev_t, struct uio *, cred_t *);
static int qotd_write(dev_t, struct uio *, cred_t *);
static int qotd_rw(dev_t, struct uio *, enum uio_rw);
static int qotd_ioctl(dev_t, int, intptr_t, int, cred_t *, int *);

static struct cb_ops qotd_cb_ops = {
        qotd_open,              /* cb_open */
        qotd_close,             /* cb_close */
        nodev,                  /* cb_strategy */
        nodev,                  /* cb_print */
        nodev,                  /* cb_dump */
        qotd_read,              /* cb_read */
        qotd_write,             /* cb_write */
        qotd_ioctl,             /* cb_ioctl */
        nodev,                  /* cb_devmap */
        nodev,                  /* cb_mmap */
        nodev,                  /* cb_segmap */
        nochpoll,               /* cb_chpoll */
        ddi_prop_op,            /* cb_prop_op */
        (struct streamtab *)NULL,       /* cb_str */
        D_MP | D_64BIT,         /* cb_flag */
        CB_REV,                 /* cb_rev */
        nodev,                  /* cb_aread */
        nodev                   /* cb_awrite */
};

static struct dev_ops qotd_dev_ops = {
        DEVO_REV,               /* devo_rev */
        0,                      /* devo_refcnt */
        qotd_getinfo,           /* devo_getinfo */
        nulldev,                /* devo_identify */
        nulldev,                /* devo_probe */
        qotd_attach,            /* devo_attach */
        qotd_detach,            /* devo_detach */
        nodev,                  /* devo_reset */
        &amp;qotd_cb_ops,           /* devo_cb_ops */
        (struct bus_ops *)NULL, /* devo_bus_ops */
        nulldev                 /* devo_power */
};

static struct modldrv modldrv = {
        &amp;mod_driverops,
        "Quote of the day 3.0",
        &amp;qotd_dev_ops};

static struct modlinkage modlinkage = {
        MODREV_1,
        (void *)&amp;modldrv,
        NULL
};

int
_init(void)
{
        int retval;

        if ((retval = ddi_soft_state_init(&amp;qotd_state_head,
            sizeof (struct qotd_state), 1)) != 0)
                return retval;
        if ((retval = mod_install(&amp;modlinkage)) != 0) {
                ddi_soft_state_fini(&amp;qotd_state_head);
                return (retval);
        }

        return (retval);
}

int
_info(struct modinfo *modinfop)
{
        return (mod_info(&amp;modlinkage, modinfop));
}

int
_fini(void)
{
        int retval;

        if ((retval = mod_remove(&amp;modlinkage)) != 0)
                return (retval);
        ddi_soft_state_fini(&amp;qotd_state_head);

        return (retval);
}

/*ARGSUSED*/
static int
qotd_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, void **resultp)
{
        struct qotd_state *qsp;
        int retval = DDI_FAILURE;

        ASSERT(resultp != NULL);

        switch (cmd) {
        case DDI_INFO_DEVT2DEVINFO:
                if ((qsp = ddi_get_soft_state(qotd_state_head,
                    getminor((dev_t)arg))) != NULL) {
                        *resultp = qsp-&gt;devi;
                        retval = DDI_SUCCESS;
                } else
                        *resultp = NULL;
                break;
        case DDI_INFO_DEVT2INSTANCE:
                *resultp = (void *)getminor((dev_t)arg);
                retval = DDI_SUCCESS;
                break;
        }

        return (retval);
}

static int
qotd_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
        int instance = ddi_get_instance(dip);
        struct qotd_state *qsp;

        switch (cmd) {
        case DDI_ATTACH:
                if (ddi_soft_state_zalloc(qotd_state_head, instance)
                    != DDI_SUCCESS) {
                        cmn_err(CE_WARN, "Unable to allocate state for %d",
                            instance);
                        return (DDI_FAILURE);
                }
                if ((qsp = ddi_get_soft_state(qotd_state_head, instance))
                    == NULL) {
                        cmn_err(CE_WARN, "Unable to obtain state for %d",
                            instance);
                        ddi_soft_state_free(qotd_state_head, instance);
                        return (DDI_FAILURE);
                }
                if (ddi_create_minor_node(dip, QOTD_NAME, S_IFCHR, instance,
                    DDI_PSEUDO, 0) != DDI_SUCCESS) {
                        cmn_err(CE_WARN, "Unable to create minor node for %d",
                            instance);
                        (void)qotd_detach(dip, DDI_DETACH);
                        return (DDI_FAILURE);
                }
                qsp-&gt;flags |= QOTD_DIDMINOR;
                qsp-&gt;qotd = ddi_umem_alloc(init_qotd_len, DDI_UMEM_NOSLEEP,
                    &amp;qsp-&gt;qotd_cookie);
                if (qsp-&gt;qotd == NULL) {
                        cmn_err(CE_WARN, "Unable to allocate storage for %d",
                            instance);
                        (void)qotd_detach(dip, DDI_DETACH);
                        return (DDI_FAILURE);
                }
                qsp-&gt;flags |= QOTD_DIDALLOC;
                mutex_init(&amp;qsp-&gt;lock, NULL, MUTEX_DRIVER, NULL);
                qsp-&gt;flags |= QOTD_DIDMUTEX;
                cv_init(&amp;qsp-&gt;cv, NULL, CV_DRIVER, NULL);
                qsp-&gt;flags |= QOTD_DIDCV;

                (void)strlcpy(qsp-&gt;qotd, init_qotd, init_qotd_len);
                qsp-&gt;qotd_len = init_qotd_len;
                qsp-&gt;instance = instance;
                qsp-&gt;devi = dip;

                ddi_report_dev(dip);
                return (DDI_SUCCESS);
        case DDI_RESUME:
                return (DDI_SUCCESS);
        default:
                return (DDI_FAILURE);
        }
}


static int
qotd_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
        int instance = ddi_get_instance(dip);
        struct qotd_state *qsp;

        switch (cmd) {
        case DDI_DETACH:
                qsp = ddi_get_soft_state(qotd_state_head, instance);
                if (qsp != NULL) {
                        ASSERT(!(qsp-&gt;flags &amp; QOTD_BUSY));
                        if (qsp-&gt;flags &amp; QOTD_CHANGED)
                                return (EBUSY);
                        if (qsp-&gt;flags &amp; QOTD_DIDCV)
                                cv_destroy(&amp;qsp-&gt;cv);
                        if (qsp-&gt;flags &amp; QOTD_DIDMUTEX)
                                mutex_destroy(&amp;qsp-&gt;lock);
                        if (qsp-&gt;flags &amp; QOTD_DIDALLOC) {
                                ASSERT(qsp-&gt;qotd != NULL);
                                ddi_umem_free(qsp-&gt;qotd_cookie);
                        }
                        if (qsp-&gt;flags &amp; QOTD_DIDMINOR)
                                ddi_remove_minor_node(dip, NULL);
                }
                ddi_soft_state_free(qotd_state_head, instance);
                return (DDI_SUCCESS);
        case DDI_SUSPEND:
                return (DDI_SUCCESS);
        default:
                return (DDI_FAILURE);
        }
}

/*ARGSUSED*/
static int
qotd_open(dev_t *devp, int flag, int otyp, cred_t *credp)
{
        int instance = getminor(*devp);
        struct qotd_state *qsp;

        if ((qsp = ddi_get_soft_state(qotd_state_head, instance)) == NULL)
                return (ENXIO);

        ASSERT(qsp-&gt;instance == instance);

        if (otyp != OTYP_CHR)
                return (EINVAL);

        return (0);
}

/*ARGSUSED*/
static int
qotd_close(dev_t dev, int flag, int otyp, cred_t *credp)
{
        struct qotd_state *qsp;
        int instance = getminor(dev);

        if ((qsp = ddi_get_soft_state(qotd_state_head, instance)) == NULL)
                return (ENXIO);

        ASSERT(qsp-&gt;instance == instance);

        if (otyp != OTYP_CHR)
                return (EINVAL);

        return (0);
}

/*ARGSUSED*/
static int
qotd_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
        return qotd_rw(dev, uiop, UIO_READ);
}

/*ARGSUSED*/
static int
qotd_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
        return qotd_rw(dev, uiop, UIO_WRITE);
}

static int
qotd_rw(dev_t dev, struct uio *uiop, enum uio_rw rw)
{
        struct qotd_state *qsp;
        int instance = getminor(dev);
        size_t len = uiop-&gt;uio_resid;
        int retval;

        if ((qsp = ddi_get_soft_state(qotd_state_head, instance)) == NULL)
                return (ENXIO);

        ASSERT(qsp-&gt;instance == instance);

        if (len == 0)
                return (0);

        mutex_enter(&amp;qsp-&gt;lock);

        while (qsp-&gt;flags &amp; QOTD_BUSY) {
                if (cv_wait_sig(&amp;qsp-&gt;cv, &amp;qsp-&gt;lock) == 0) {
                        mutex_exit(&amp;qsp-&gt;lock);
                        return (EINTR);
                }
        }

        if (uiop-&gt;uio_offset &lt; 0 || uiop-&gt;uio_offset &gt; qsp-&gt;qotd_len) {
                mutex_exit(&amp;qsp-&gt;lock);
                return (EINVAL);
        }

        if (len &gt; qsp-&gt;qotd_len - uiop-&gt;uio_offset)
                len = qsp-&gt;qotd_len - uiop-&gt;uio_offset;

        if (len == 0) {
                mutex_exit(&amp;qsp-&gt;lock);
                return (rw == UIO_WRITE ? ENOSPC : 0);
        }

        qsp-&gt;flags |= QOTD_BUSY;
        mutex_exit(&amp;qsp-&gt;lock);

        retval = uiomove((void *)(qsp-&gt;qotd + uiop-&gt;uio_offset), len, rw, uiop);

        mutex_enter(&amp;qsp-&gt;lock);
        if (rw == UIO_WRITE)
                qsp-&gt;flags |= QOTD_CHANGED;
        qsp-&gt;flags &amp;= ~QOTD_BUSY;
        cv_broadcast(&amp;qsp-&gt;cv);
        mutex_exit(&amp;qsp-&gt;lock);

        return (retval);
}

/*ARGSUSED*/
static int
qotd_ioctl(dev_t dev, int cmd, intptr_t arg, int mode, cred_t *credp,
    int *rvalp)
{
        struct qotd_state *qsp;
        int instance = getminor(dev);

        if ((qsp = ddi_get_soft_state(qotd_state_head, instance)) == NULL)
                return (ENXIO);

        ASSERT(qsp-&gt;instance == instance);

        switch (cmd) {
        case QOTDIOCGSZ: {
                /* We are not guaranteed that ddi_copyout(9F) will read
                 * automatically anything larger than a byte.  Therefore we
                 * must duplicate the size before copying it out to the user.
                 */
                size_t sz = qsp-&gt;qotd_len;

                if (!(mode &amp; FREAD))
                        return (EACCES);

#ifdef _MULTI_DATAMODEL
                switch (ddi_model_convert_from(mode &amp; FMODELS)) {
                case DDI_MODEL_ILP32: {
                        size32_t sz32 = (size32_t)sz;
                        if (ddi_copyout(&amp;sz32, (void *)arg, sizeof (size32_t),
                            mode) != 0)
                                return (EFAULT);
                        return (0);
                }
                case DDI_MODEL_NONE:
                        if (ddi_copyout(&amp;sz, (void *)arg, sizeof (size_t),
                            mode) != 0)
                                return (EFAULT);
                        return (0);
                default:
                        cmn_err(CE_WARN, "Invalid data model %d in ioctl\n",
                            ddi_model_convert_from(mode &amp; FMODELS));
                        return (ENOTSUP);
                }
#else /* ! _MULTI_DATAMODEL */
                if (ddi_copyout(&amp;sz, (void *)arg, sizeof (size_t), mode) != 0)
                        return (EFAULT);
                return (0);
#endif /* _MULTI_DATAMODEL */
        }
        case QOTDIOCSSZ: {
                size_t new_len;
                char *new_qotd;
                ddi_umem_cookie_t new_cookie;
                uint_t model;

                if (!(mode &amp; FWRITE))
                        return (EACCES);

#ifdef _MULTI_DATAMODEL
                model = ddi_model_convert_from(mode &amp; FMODELS);

                switch (model) {
                case DDI_MODEL_ILP32: {
                        size32_t sz32;
                        if (ddi_copyin((void *)arg, &amp;sz32, sizeof (size32_t),
                            mode) != 0)
                                return (EFAULT);
                        new_len = (size_t)sz32;
                        break;
                }
                case DDI_MODEL_NONE:
                        if (ddi_copyin((void *)arg, &amp;new_len, sizeof (size_t),
                            mode) != 0)
                                return (EFAULT);
                        break;
                default:
                        cmn_err(CE_WARN, "Invalid data model %d in ioctl\n",
                            model);
                        return (ENOTSUP);
                }
#else /* ! _MULTI_DATAMODEL */
                if (ddi_copyin((void *)arg, &amp;new_len, sizeof (size_t),
                    mode) != 0)
                        return (EFAULT);
#endif /* _MULTI_DATAMODEL */

                if (new_len == 0 || new_len &gt; QOTD_MAX_LEN)
                        return (EINVAL);

                new_qotd = ddi_umem_alloc(new_len, DDI_UMEM_SLEEP, &amp;new_cookie);

                mutex_enter(&amp;qsp-&gt;lock);
                while (qsp-&gt;flags &amp; QOTD_BUSY) {
                        if (cv_wait_sig(&amp;qsp-&gt;cv, &amp;qsp-&gt;lock) == 0) {
                                mutex_exit(&amp;qsp-&gt;lock);
                                ddi_umem_free(new_cookie);
                                return (EINTR);
                        }
                }
                memcpy(new_qotd, qsp-&gt;qotd, min(qsp-&gt;qotd_len, new_len));
                ddi_umem_free(qsp-&gt;qotd_cookie);
                qsp-&gt;qotd = new_qotd;
                qsp-&gt;qotd_cookie = new_cookie;
                qsp-&gt;qotd_len = new_len;
                qsp-&gt;flags |= QOTD_CHANGED;
                mutex_exit(&amp;qsp-&gt;lock);

                return (0);
        }
        case QOTDIOCDISCARD: {
                char *new_qotd = NULL;
                ddi_umem_cookie_t new_cookie;

                if (!(mode &amp; FWRITE))
                        return (EACCES);

                if (qsp-&gt;qotd_len != init_qotd_len) {
                        new_qotd = ddi_umem_alloc(init_qotd_len,
                            DDI_UMEM_SLEEP, &amp;new_cookie);
                }

                mutex_enter(&amp;qsp-&gt;lock);
                while (qsp-&gt;flags &amp; QOTD_BUSY) {
                        if (cv_wait_sig(&amp;qsp-&gt;cv, &amp;qsp-&gt;lock) == 0) {
                                mutex_exit(&amp;qsp-&gt;lock);
                                if (new_qotd != NULL)
                                        ddi_umem_free(new_cookie);
                                return (EINTR);
                        }
                }
                if (new_qotd != NULL) {
                        ddi_umem_free(qsp-&gt;qotd_cookie);
                        qsp-&gt;qotd = new_qotd;
                        qsp-&gt;qotd_cookie = new_cookie;
                        qsp-&gt;qotd_len = init_qotd_len;
                } else {
                        bzero(qsp-&gt;qotd, qsp-&gt;qotd_len);
                }
                (void)strlcpy(qsp-&gt;qotd, init_qotd, init_qotd_len);
                qsp-&gt;flags &amp;= ~QOTD_CHANGED;
                mutex_exit(&amp;qsp-&gt;lock);

                return (0);
        }
        default:
                return (ENOTTY);
        }
}</programlisting>
        </example>

        <para>Enter the definitions shown in the following example into a text
        file named <filename>qotd.h</filename>.</para>

        <example xml:id="ffzrj">
          <title>Quote Of The Day Version 3 Header File</title>

          <programlisting>#ifndef _SYS_QOTD_H
#define _SYS_QOTD_H

#define QOTDIOC         ('q' &lt;&lt; 24 | 't' &lt;&lt; 16 | 'd' &lt;&lt; 8)

#define QOTDIOCGSZ      (QOTDIOC | 1)   /* Get quote buffer size */
#define QOTDIOCSSZ      (QOTDIOC | 2)   /* Set new quote buffer size */
#define QOTDIOCDISCARD  (QOTDIOC | 3)   /* Discard quotes and reset */

#endif /* _SYS_QOTD_H */</programlisting>
        </example>

        <para>Enter the configuration information shown in the following
        example into a text file named
        <filename>qotd_3.conf</filename>.</para>

        <example xml:id="ffdqx">
          <title>Quote Of The Day Version 3 Configuration File</title>

          <programlisting>name="qotd_3" parent="pseudo" instance=0;</programlisting>
        </example>
      </sect3>
    </sect2>

    <sect2 xml:id="ffdrd">
      <title>Building and Installing Quote Of The Day Version 3</title>

      <para>Compile and link the driver. The following example shows compiling
      and linking for a 32-bit architecture:</para>

      <screen>% <userinput>cc -D_KERNEL -c qotd_3.c</userinput>
% <userinput>ld -r -o qotd_3 qotd_3.o</userinput>
</screen>

      <para>Make sure you are user <literal>root</literal> when you install
      the driver.</para>

      <para>Copy the driver binary to the <filename>/tmp</filename> directory
      as discussed in <olink remap="external" targetdoc="chapter-2.xml"
      targetptr="eoxzr">Building and Installing the Template
      Driver</olink>.</para>

      <screen># <userinput>cp qotd_3 /tmp</userinput>
# <userinput>ln -s /tmp/qotd_3 /usr/kernel/drv/qotd_3</userinput>
</screen>

      <para>Copy the configuration file to the kernel driver area of the
      system.</para>

      <screen># <userinput>cp qotd_3.conf /usr/kernel/drv</userinput>
</screen>

      <para>In a separate window, enter the following command:</para>

      <screen>% <userinput>tail -f /var/adm/messages</userinput>
</screen>

      <para>Make sure you are user <literal>root</literal> when you load the
      driver. Use the <olink remap="external" targetdoc="819-2240"
      targetptr="add-drv-1m"> <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to load the driver:</para>

      <screen># <userinput>add_drv qotd_3</userinput>
</screen>

      <para>You should see the following messages in the window where you are
      viewing <filename>/var/adm/messages</filename>:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> pseudo: [ID 129642 kern.info] pseudo-device: qotd_30
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> genunix: [ID 936769 kern.info] qotd_30 is /pseudo/qotd_3@0</screen>
    </sect2>

    <sect2 xml:id="ffzsc">
      <title>Using Quote Of The Day Version 3</title>

      <para>This section describes how to read and write the
      <literal>qotd_3</literal> device and how to test the driver's I/O
      controls. The I/O controls include retrieving the size of the storage
      buffer, setting a new size for the storage buffer, and reinitializing
      the storage buffer size and contents.</para>

      <sect3 xml:id="fgvse">
        <title>Reading the Device</title>

        <indexterm xml:id="indexterm-530">
          <primary>devices</primary>

          <secondary>reading</secondary>
        </indexterm>

        <para>When you access this <literal>qotd_3</literal> device for
        reading, the command you use to access the device retrieves the data
        from the device node. The command then displays the data in the same
        way that the command displays any other input. To get the name of the
        device special file, look in the <filename>/devices</filename>
        directory:</para>

        <screen>% <userinput>ls -l /devices/pseudo/qotd*</userinput>
crw-------   1 root   sys   122,  0 <replaceable>date</replaceable> <replaceable>time</replaceable> /devices/pseudo/qotd_3@0:qotd_3</screen>

        <para>To read the <literal>qotd_3</literal> device, you can use the
        <olink remap="external" targetdoc="819-2239" targetptr="cat-1">
        <citerefentry>
            <refentrytitle>cat</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink> command:</para>

        <screen># <userinput>cat /devices/pseudo/qotd_3@0:qotd_3</userinput>
On the whole, I'd rather be in Philadelphia. - W. C. Fields</screen>
      </sect3>

      <sect3 xml:id="fgvsh">
        <title>Writing the Device</title>

        <indexterm xml:id="indexterm-531">
          <primary>devices</primary>

          <secondary>writing</secondary>
        </indexterm>

        <para>To write to the <literal>qotd_3</literal> device, you can
        redirect command-line input:</para>

        <screen># <userinput>echo "A life is not important except in the impact it has on others. 
- Jackie Robinson" &gt;&gt; /devices/pseudo/qotd_3@0:qotd_3</userinput>
# <userinput>cat /devices/pseudo/qotd_3@0:qotd_3</userinput>
A life is not important except in the impact it has on others. - Jackie
Robinson</screen>
      </sect3>

      <sect3 xml:id="fgvsf">
        <title>Exercising the Driver's I/O Controls</title>

        <indexterm xml:id="indexterm-532">
          <primary>device drivers</primary>

          <secondary>I/O controls</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-533">
          <primary>I/O controls</primary>
        </indexterm>

        <indexterm xml:id="indexterm-534">
          <primary>entry points</primary>

          <secondary><function>ioctl </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-535">
          <primary><function>ioctl </function> entry point</primary>
        </indexterm>

        <para>In addition to changes in the driver, Quote Of The Day Version 3
        introduces a new utility program. The <command>qotdctl</command>
        command enables you to test the driver's I/O controls.</para>

        <para>The source for this command is shown in <olink remap="internal"
        targetdoc="chapter-3.xml" targetptr="ffzrf">Example 3–8</olink>.
        Compile the <literal>qotdctl</literal> utility as follows:</para>

        <screen>% <userinput>cc -o qotdctl qotdctl.c</userinput>
</screen>

        <para>The <command>qotdctl</command> command has the following
        options:</para>

        <variablelist>
          <varlistentry>
            <term><option> g</option></term>

            <listitem>
              <para>Get the size that is currently allocated. Call the <olink
              remap="external" targetdoc="819-2255" targetptr="ioctl-9e">
              <citerefentry>
                  <refentrytitle>ioctl</refentrytitle>

                  <manvolnum>9E</manvolnum>
                </citerefentry> </olink> entry point of the driver with the
              <literal>QOTDIOCGSZ</literal> request. The
              <literal>QOTDIOCGSZ</literal> request reports the current size
              of the space allocated for the quotation.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><option> s</option> <replaceable>size</replaceable></term>

            <listitem>
              <para>Set the new size to be allocated. Call the <olink
              remap="external" targetdoc="819-2255" targetptr="ioctl-9e">
              <citerefentry>
                  <refentrytitle>ioctl</refentrytitle>

                  <manvolnum>9E</manvolnum>
                </citerefentry> </olink> entry point of the driver with the
              <literal>QOTDIOCSSZ</literal> request. The
              <literal>QOTDIOCSSZ</literal> request sets a new size for the
              quotation space.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><option> r</option></term>

            <listitem>
              <para>Discard the contents and reset the device. Call the <olink
              remap="external" targetdoc="819-2255" targetptr="ioctl-9e">
              <citerefentry>
                  <refentrytitle>ioctl</refentrytitle>

                  <manvolnum>9E</manvolnum>
                </citerefentry> </olink> entry point of the driver with the
              <literal>QOTDIOCDISCARD</literal> request.</para>

              <para>Invoking <command>qotdctl</command> with the <option>
              r</option> option is the only way to unset the
              <literal>QOTD_CHANGED</literal> flag in the device. The device
              cannot be detached while the <literal>QOTD_CHANGED</literal>
              flag is set. This protects the contents of the ramdisk device
              from being unintentionally or automatically removed. For
              example, a device might be automatically removed by the
              automatic device unconfiguration thread.</para>

              <para>When you are no longer interested in the contents of the
              device, run the <command>qotdctl</command> command with the
              <option> r</option> option. Then you can remove the
              device.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><option> h</option></term>

            <listitem>
              <para>Display help text.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><option> V</option></term>

            <listitem>
              <para>Display the version number of the
              <command>qotdctl</command> command.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><option> d</option> <replaceable>device</replaceable></term>

            <listitem>
              <para>Specify the device node to use. The default value is
              <filename>/dev/qotd0</filename>.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Use the <command>qotdctl</command> command to test the driver's
        I/O controls:</para>

        <screen># <userinput>./qotdctl -V</userinput>
qotdctl 1.0
# <userinput>./qotdctl -h</userinput>
Usage: ./qotdctl [-d device] {-g | -h | -r | -s size | -V}
# <userinput>./qotdctl -g</userinput>
open: No such file or directory</screen>

        <para>By default, the <command>qotdctl</command> command accesses the
        <filename>/dev/qotd0</filename> device. The <literal>qotd_3</literal>
        device in this example is
        <filename>/devices/pseudo/qotd_3@0:qotd_3</filename>. Either define a
        link from <filename>/dev/qotd0</filename> to
        <filename>/devices/pseudo/qotd_3@0:qotd_3</filename> or use the
        <option> d</option> option to specify the correct device:</para>

        <screen># <userinput>./qotdctl -d /devices/pseudo/qotd_3@0:qotd_3 -g</userinput>
128
# <userinput>./qotdctl -d /devices/pseudo/qotd_3@0:qotd_3 -s 512</userinput>
# <userinput>./qotdctl -d /devices/pseudo/qotd_3@0:qotd_3 -g</userinput>
512
# <userinput>./qotdctl -d /devices/pseudo/qotd_3@0:qotd_3 -r</userinput>
# <userinput>cat /devices/pseudo/qotd_3@0:qotd_3</userinput>
On the whole, I'd rather be in Philadelphia. - W. C. Fields</screen>

        <para>If you try to remove the device now, you will receive an error
        message:</para>

        <screen># <userinput>rem_drv qotd_3</userinput>
Device busy
Cannot unload module: qotd_3
Will be unloaded upon reboot.</screen>

        <para>The device is still marked busy because you have not told the
        driver that you are no longer interested in this device. Run the
        <command>qotdctl</command> command with the <option> r</option> option
        to unset the <literal>QOTD_CHANGED</literal> flag in the driver and
        mark the device not busy:</para>

        <screen># <userinput>./qotdctl -r</userinput>
</screen>

        <para>Enter the source code shown in the following example into a text
        file named <filename>qotdctl.c</filename>.</para>

        <example xml:id="ffzrf">
          <title>Quote Of The Day I/O Control Command Source File</title>

          <programlisting>#include &lt;sys/ioctl.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;

#include "qotd.h"

static const char *DEFAULT_DEVICE = "/dev/qotd0";
static const char *VERSION = "1.0";

static void show_usage(const char *);
static void get_size(const char *);
static void set_size(const char *, size_t);
static void reset_dev(const char *);

int
main(int argc, char *argv[])
{
        int op = -1;
        int opt;
        int invalid_usage = 0;
        size_t sz_arg;
        const char *device = DEFAULT_DEVICE;

        while ((opt = getopt(argc, argv,
            "d:(device)g(get-size)h(help)r(reset)s:(set-size)V(version)"))
            != -1) {
                switch (opt) {
                case 'd':
                        device = optarg;
                        break;
                case 'g':
                        if (op &gt;= 0)
                                invalid_usage++;
                        op = QOTDIOCGSZ;
                        break;
                case 'h':
                        show_usage(argv[0]);
                        exit(0);
                        /*NOTREACHED*/
                case 'r':
                        if (op &gt;= 0)
                                invalid_usage++;
                        op = QOTDIOCDISCARD;
                        break;
                case 's':
                        if (op &gt;= 0)
                                invalid_usage++;
                        op = QOTDIOCSSZ;
                        sz_arg = (size_t)atol(optarg);
                        break;
                case 'V':
                        (void) printf("qotdctl %s\n", VERSION);
                        exit(0);
                        /*NOTREACHED*/
                default:
                        invalid_usage++;
                        break;
                }
        }

        if (invalid_usage &gt; 0 || op &lt; 0) {
                show_usage(argv[0]);
                exit(1);
        }

        switch (op) {
        case QOTDIOCGSZ:
                get_size(device);
                break;
        case QOTDIOCSSZ:
                set_size(device, sz_arg);
                break;
        case QOTDIOCDISCARD:
                reset_dev(device);
                break;
        default:
                (void) fprintf(stderr,
                    "internal error - invalid operation %d\n", op);
                exit(2);
        }

        return (0);
}

static void
show_usage(const char *execname)
{
        (void) fprintf(stderr,
         "Usage: %s [-d device] {-g | -h | -r | -s size | -V}\n", execname);
}

static void
get_size(const char *dev)
{
        size_t sz;
        int fd;

        if ((fd = open(dev, O_RDONLY)) &lt; 0) {
                perror("open");
                exit(3);
        }

        if (ioctl(fd, QOTDIOCGSZ, &amp;sz) &lt; 0) {
                perror("QOTDIOCGSZ");
                exit(4);
        }

        (void) close(fd);

        (void) printf("%zu\n", sz);
}

static void
set_size(const char *dev, size_t sz)
{
        int fd;

        if ((fd = open(dev, O_RDWR)) &lt; 0) {
                perror("open");
                exit(3);
        }

        if (ioctl(fd, QOTDIOCSSZ, &amp;sz) &lt; 0) {
                perror("QOTDIOCSSZ");
                exit(4);
        }

        (void) close(fd);
}

static void
reset_dev(const char *dev)
{
        int fd;

        if ((fd = open(dev, O_RDWR)) &lt; 0) {
                perror("open");
                exit(3);
        }

        if (ioctl(fd, QOTDIOCDISCARD) &lt; 0) {
                perror("QOTDIOCDISCARD");
                exit(4);
        }

        (void) close(fd);
}</programlisting>
        </example>
      </sect3>
    </sect2>
  </sect1>
</chapter>