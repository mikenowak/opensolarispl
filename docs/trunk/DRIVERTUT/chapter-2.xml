<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN"
"docbook.dtd" [
<!ENTITY % xinclude SYSTEM "xinclude.mod">
%xinclude;
]>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook" xml:id="eoqrt">
  <title>Przykładowy sterownik urządzenia</title>

  <toc>
    <para>W tym rozdziale przedstawiono przykładowy proces tworzenia prostego,
    działającego sterownika. Wyjaśniono jak pisać sterownik, plik
    konfiguracyjny, skompilować sterownik, załadować go i przetestować.</para>

    <para><indexterm xml:id="indexterm-165">
        <primary>devices</primary>

        <secondary>pseudo</secondary>
      </indexterm>Sterownik przedstawiony w tym rozdizale to sterownik
    pseudourządzenia, wypisujący zaledwie wiadomość do logów systemowych za
    każdym razem, gdy następuje wejście przez punkt wejścia. Zawiera minimalną
    strukturę wymaganą od sterownika urządzenia znakowego. Można użyć go jako
    punkt wyjścia do napisania skomplikowanego sterownika.</para>

    <itemizedlist>
      <para>W rozdziale omawiane są następujące kroki tworzenia
      sterownika:</para>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="ffzpv">Overview of the Template Driver
        Example</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="writedriver">Writing the Template Driver</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eoxzw">Writing the Device Configuration File</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eoxzr">Building and Installing the Template
        Driver</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eoxzu">Testing the Template Driver</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eqbof">Complete Template Driver Source</olink></para>
      </listitem>
    </itemizedlist>
  </toc>

  <sect1 xml:id="ffzpv">
    <title>Overview of the Template Driver Example</title>

    <orderedlist>
      <para>Przykład przedstawia następujące kroki:</para>

      <listitem>
        <para>Stworzenie katalogu służącego do pisania sterownika i stworzenie
        pustego pliku <filename>dummy.c</filename>.</para>
      </listitem>

      <listitem>
        <para>Napisanie punktów wejścia dla konfiguracji ładowanego modułu:
        <olink remap="external" targetdoc="819-2255" targetptr="u-init-9e">
        <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="u-info-9e"> <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="u-fini-9e"> <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Napisanie puntków wejścia dla autokonfiguracji: <olink
        remap="external" targetdoc="819-2255" targetptr="attach-9e">
        <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="detach-9e"> <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="getinfo-9e"> <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="prop-op-9e"> <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Napisanie punktów wejścia dla kontekstu użytkownika: <olink
        remap="external" targetdoc="819-2255" targetptr="open-9e">
        <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="close-9e"> <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="read-9e"> <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="write-9e"> <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Zdefiniowanie struktur danych: struktury operacji znakowych i
        blokowych <olink remap="external" targetdoc="819-2257"
        targetptr="cb-ops-9s"> <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink>, struktury operacji urządzenia <olink
        remap="external" targetdoc="819-2257" targetptr="dev-ops-9s">
        <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> i struktur konsolidacji modułu <olink
        remap="external" targetdoc="819-2257" targetptr="modldrv-9s">
        <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2257" targetptr="modlinkage-9s"> <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Stworzenie pliku konfiguracyjnego
        <filename>dummy.conf</filename>.</para>
      </listitem>

      <listitem>
        <para>Zbudowanie i zainstalowanie sterownika.</para>
      </listitem>

      <listitem>
        <para>Testowanie sterownika przez załadowanie go, odczytanie i zapis
        do node'u urządzenia oraz wyładowanie sterownika.</para>
      </listitem>
    </orderedlist>

    <para><indexterm xml:id="indexterm-166">
        <primary>device drivers</primary>

        <secondary>entry points</secondary>
      </indexterm>Punkty wejścia do napisania dla sterownika pokazane są na
    diagramie poniżej.</para>

    <figure xml:id="fgotp">
      <title>Entry Points for the <literal>dummy</literal> Example</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figures/epoints.dummy.gif"></imagedata>
        </imageobject>

        <textobject>
          <simpara>Diagram pokazuje punkty wejścia do stworzenia w
          przykładowym sterowniku.</simpara>
        </textobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1 xml:id="writedriver">
    <title>Writing the Template Driver</title>

    <indexterm xml:id="indexterm-167">
      <primary>devices</primary>

      <secondary>character</secondary>
    </indexterm>

    <para>Podrozdział ten opisuje punkty wejścia i struktury danych włączone
    do sterownika oraz opisuje jak je zdefiniować. Wszystkie te struktury
    danych i niemal wszystkie te punkty wejścia są wymagane dla każdego
    sterownika urządzenia znakowego.</para>

    <itemizedlist>
      <para>Podrozdział ten opisuje następujące punkty wejścia i struktury
      danych:</para>

      <listitem>
        <para>Punkty wejścia konfiguracji ładowalnych modułów</para>
      </listitem>

      <listitem>
        <para>Punkty wejścia autokonfiguracji</para>
      </listitem>

      <listitem>
        <para>Punkty wejścia kontekstu użytkownika</para>
      </listitem>

      <listitem>
        <para>Struktury operacji znakowych i blokowych</para>
      </listitem>

      <listitem>
        <para>Struktura operacji urządzenia</para>
      </listitem>

      <listitem>
        <para>Struktura konsolidacji modułu</para>
      </listitem>
    </itemizedlist>

    <para>Najpierw należy stworzyć katalog, w którym tworzony będzie
    sterownik. Sterownik nazywa się <literal>dummy</literal>, poniewż nie
    wykonuje żadnej prawdziwej pracy. W katalogu należy otworzyć do edycji
    nowy, pusty plik <filename>dummy.c</filename>.</para>

    <sect2 xml:id="eoxzy">
      <title>Writing the Loadable Module Configuration Entry Points</title>

      <indexterm xml:id="indexterm-168">
        <primary>entry points</primary>

        <secondary>loadable module configuration</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-169">
        <primary>entry points</primary>

        <secondary><function>_init </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-170">
        <primary><function>_init </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-171">
        <primary>entry points</primary>

        <secondary><function>_info </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-172">
        <primary><function>_info </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-173">
        <primary>entry points</primary>

        <secondary><function>_fini </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-174">
        <primary><function>_fini </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-175">
        <primary><function>mod_install </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-176">
        <primary>kernel functions</primary>

        <secondary><function>mod_install </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-177">
        <primary><function>mod_info </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-178">
        <primary>kernel functions</primary>

        <secondary><function>mod_info </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-179">
        <primary><function>mod_remove </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-180">
        <primary>kernel functions</primary>

        <secondary><function>mod_remove </function></secondary>
      </indexterm>

      <itemizedlist>
        <para>Każdy moduł jądra dowolnego typu musi zawierać przynajmniej trzy
        punkty wejścia konfiguracji ładowalnego modułu:</para>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="u-init-9e"> <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> inicjalizuje moduł ładowalny. Funkcja
          <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wywołać przynajmniej funkcję <olink
          remap="external" targetdoc="819-2256" targetptr="mod-install-9f">
          <citerefentry>
              <refentrytitle>mod_install</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> i zwrócić wartość sukcesu albo błędu
          zwracaną przez <citerefentry>
              <refentrytitle>mod_install</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="u-info-9e"> <citerefentry>
              <refentrytitle>_info</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zwraca informację o ładowalnym module.
          Funkcja <citerefentry>
              <refentrytitle>_info</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wywołać przynajmniej funkcję <olink
          remap="external" targetdoc="819-2256" targetptr="mod-info-9f">
          <citerefentry>
              <refentrytitle>mod_info</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> i zwrócić wartość zwracaną przez
          <citerefentry>
              <refentrytitle>mod_info</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="u-fini-9e"> <citerefentry>
              <refentrytitle>_fini</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> przygotowuje ładowalny moduł do
          wyładowania. Funkcja <citerefentry>
              <refentrytitle>_fini</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wywołać przynajmniej funkcję <olink
          remap="external" targetdoc="819-2256" targetptr="mod-remove-9f">
          <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> i zwrócić wartość sukcesu albo błędu
          zwróconą przez <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>. Jeśli <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> zwróci informację o powodzeniu, funkcja
          <citerefentry>
              <refentrytitle>_fini</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wykonać pracę odwrotną wykonała funkcja
          <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>.</para>
        </listitem>
      </itemizedlist>

      <para>Funkcje <citerefentry>
          <refentrytitle>mod_install</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>mod_info</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>mod_remove</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> używane są dokładnie tak samo we wszystkich
      sterownikach, niezależnie od możliwości sterownika. Nie ma potrzeby
      dowiadywać się jakie powinny być wartości pzrekazywane tym funkcjom.
      Wywołania tych funkcji można skopiować z poniższego przykładu i
      bezpiecznie wkleić do dowolnego sterownika.</para>

      <para>Do pliku żródłowego the <filename>dummy.c</filename> dodano
      poniższy kod:</para>

      <programlisting>/* Punkty wejścia konfiguracji ładowalnego modułu */
int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}

int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}

int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}</programlisting>

      <sect3 xml:id="epmnj">
        <title>Declaring the Loadable Module Configuration Entry
        Points</title>

        <para>Nazwy funkcji <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> nie są unikalne dla żadnego modułu jądra. Ich
        działanie podlega modyfikacji podczas definiowania w module, ale ich
        nazwy nie są unikalne. Zadeklarowane są w pliku nagłówkowym
        <filename>modctl.h</filename> i trzeba go włączyć do pliku
        <filename>dummy.c</filename>. Funkcji tych nie należy samodzielnie
        deklarować w pliku <filename>dummy.c</filename>.</para>
      </sect3>

      <sect3 xml:id="epmnk">
        <title>Defining the Module Initialization Entry Point</title>

        <indexterm xml:id="indexterm-181">
          <primary>entry points</primary>

          <secondary><function>_init </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-182">
          <primary><function>_init </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-183">
          <primary><function>mod_install </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-184">
          <primary>kernel functions</primary>

          <secondary><function>mod_install </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-185">
          <primary><literal>modlinkage</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-186">
          <primary>driver structures</primary>

          <secondary><literal>modlinkage</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-187">
          <primary><function>cmn_err </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-188">
          <primary>kernel functions</primary>

          <secondary><function>cmn_err </function></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="u-init-9e"> <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> i nie
        pobiera argumentów. Funkcja <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wywołać funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="mod-install-9f"> <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i zwrócić wartość wskazującą powodzenie lub
        błąd zwracaną przez <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera argument będący strukturą <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry>. Więcej informacji w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epffy">Defining the Module
        Linkage Structures</olink>.</para>

        <para>Sterownik ma za zadanie wypisywać wiadomość za każdym razem, gdy
        następuje wejście przez punkt wejścia. Wiadomości w logu systemoweym
        zapisuje się funkcją <olink remap="external" targetdoc="819-2256"
        targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Funkcji <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> używa się zazwyczaj do zapisania informacji o
        błędzie, ale bywa też przydatna przy szukaniu błędów w sposób podobny
        do wyrażeń print w programie użytkownika.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> wymaga włączenia plików nagłówkowych
        <filename>cmn_err.h</filename>, <filename>ddi.h</filename> i the
        <filename>sunddi.h</filename>. Funkcja <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera dwa arumenty. Pierwszy argument to stała
        wskazująca powagę błędu. Wiadomości pisane przez ten sterownik nie są
        informacjami o błędzie, ale zwykłymi informacjami testowymi, więc
        wartość tej stałej będzie wynosić <literal>CE_NOTE</literal>. Drugi
        argument funkcji <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> to łańcuch znakowy z wiadomością do
        zapisania.</para>

        <para>Poniżej zamieszczono kod z definicją funkcji <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> do włączenia do pliku <filename>dummy.c</filename>.
        Struktura <literal>ml</literal> to struktura <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> opisana w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epffy">Defining the Module
        Linkage Structures</olink>.</para>

        <programlisting>int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}</programlisting>
      </sect3>

      <sect3 xml:id="epmnm">
        <title>Defining the Module Information Entry Point</title>

        <indexterm xml:id="indexterm-189">
          <primary>entry points</primary>

          <secondary><function>_info </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-190">
          <primary><function>_info </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-191">
          <primary><function>mod_info </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-192">
          <primary>kernel functions</primary>

          <secondary><function>mod_info </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-193">
          <primary><literal>modinfo</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-194">
          <primary>driver structures</primary>

          <secondary><literal>modinfo</literal></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="u-info-9e"> <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> i pobiera
        argument będący wskaźnikiem do struktury <literal>modinfo</literal>.
        Funkcja <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi zwrócić wartość zwracaną przez funkcję <olink
        remap="external" targetdoc="819-2256" targetptr="mod-info-9f">
        <citerefentry>
            <refentrytitle>mod_info</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>mod_info</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera dwa argumenty. Pierwszy argument to
        struktura <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry>. Więcej informacji w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epffy">Defining the Module
        Linkage Structures</olink>. Drugi argument to ten sam wskażnik do
        struktury <literal>modinfo</literal>, który został przekazany funkcji
        <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Funkcja <citerefentry>
            <refentrytitle>mod_info</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwraca informację o module lub zwraca zero, jeśli
        wystąpił błąd.</para>

        <para>Do zapisania infgormacji w logach systemowych użyta zostanie
        funkcja <olink remap="external" targetdoc="819-2256"
        targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w taki sam sposób jak w funkcji
        <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod funkcji <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> powinien zostać włączony do pliku<filename>
        dummy.c</filename>. Struktura <literal>ml</literal> opisana jest w
        <olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="epffy">Defining the Module Linkage Structures</olink>.
        Argument <literal>modinfop</literal> jest wskaźniekiem do struktury
        używanej przez system do przekazywania informacji o modułach.</para>

        <programlisting>int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}</programlisting>
      </sect3>

      <sect3 xml:id="epmnn">
        <title>Defining the Module Unload Entry Point</title>

        <indexterm xml:id="indexterm-195">
          <primary>entry points</primary>

          <secondary><function>_fini </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-196">
          <primary><function>_fini </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-197">
          <primary><function>mod_remove </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-198">
          <primary>kernel functions</primary>

          <secondary><function>mod_remove </function></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="u-fini-9e"> <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> i nie
        pobiera argumentów. Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wywołać funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="mod-remove-9f"> <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i zwrócić wartość powodzenia lub błędu
        zwracaną przez <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>.</para>

        <para>Jeśli <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> się uda funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wykonać pracę odwrotną do tej wykonanej przez
        funkcję <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wywołać <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>, ponieważ <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołała <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>. Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi uwolnić wszystko, co zostało zalokowane,
        zamknąć wszystko, co zostało otwarte i zniszczyć wszystko, co zostało
        stworzone przez funkcję <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> może być wywołana w dowolnym momencie, gdy moduł
        jest załadowany. W normalnym działaniu funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> często zwraca błąd. To jest normalne, ponieważ jądro
        pozwala modułowi na ustalenie, czy moduł może być wyładowany, czy
        też nie. Jeśli wywołanie <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwróciło powodzenie, moduł uznaje, że urządzenie
        zostało odłączone i moduł można wyładować. Jeśli <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> nie powiedzie się, moduł uznaje, że urządzenie nie
        zostało odłączone i modułu nie można wyładować.</para>

        <itemizedlist>
          <para>Po wywołaniu <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> wykonywane są następujące akcje:</para>

          <listitem>
            <itemizedlist>
              <para>Jądro sprawdza, czy sterownik jest zajęty. Sterownik jest
              zajęty, jeśli spełniony jest jeden z poniższych warunków:</para>

              <listitem>
                <para>Node zarządzany przez sterownik jest otwarty.</para>
              </listitem>

              <listitem>
                <para><indexterm xml:id="indexterm-199">
                    <primary>linking</primary>
                  </indexterm> <indexterm xml:id="indexterm-200">
                    <primary>commands</primary>

                    <secondary><command>ld</command></secondary>
                  </indexterm> <indexterm xml:id="indexterm-201">
                    <primary><command>ld</command> command</primary>
                  </indexterm>Inny moduł, który zależy od sterownika jet
                otwarty. Moduł zależy od sterownika jeśli był konsolidowany z
                opcją <option>N</option> ze sterownikiem jako argumentem dla
                opcji <option>N</option>. Więcej informacji w <olink
                remap="external" targetdoc="819-2239" targetptr="ld-1">
                <citerefentry>
                    <refentrytitle>ld</refentrytitle>

                    <manvolnum>1</manvolnum>
                  </citerefentry> </olink>.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Jeśli sterownik jest zajęty, <citerefentry>
                <refentrytitle>mod_remove</refentrytitle>

                <manvolnum>9F</manvolnum>
              </citerefentry> zwraca błąd i <citerefentry>
                <refentrytitle>_fini</refentrytitle>

                <manvolnum>9E</manvolnum>
              </citerefentry> zwraca błąd.</para>
          </listitem>

          <listitem>
            <para><indexterm xml:id="indexterm-202">
                <primary>entry points</primary>

                <secondary><function>detach </function></secondary>
              </indexterm> <indexterm xml:id="indexterm-203">
                <primary><function>detach </function> entry point</primary>
              </indexterm>Jeśli sterownik nie jest zajęty, jądro wywołuje
            punkt wejścia <olink remap="external" targetdoc="819-2255"
            targetptr="detach-9e"> <citerefentry>
                <refentrytitle>detach</refentrytitle>

                <manvolnum>9E</manvolnum>
              </citerefentry> </olink>.</para>

            <itemizedlist>
              <listitem>
                <para>Jeśli <citerefentry>
                    <refentrytitle>detach</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> się nie powiedzie, to <citerefentry>
                    <refentrytitle>mod_remove</refentrytitle>

                    <manvolnum>9F</manvolnum>
                  </citerefentry> zwraca błąd i <citerefentry>
                    <refentrytitle>_fini</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> zwraca błąd.</para>
              </listitem>

              <listitem>
                <para><citerefentry>
                    <refentrytitle>Jeśli detach</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> się powiedzie, to <citerefentry>
                    <refentrytitle>mod_remove</refentrytitle>

                    <manvolnum>9F</manvolnum>
                  </citerefentry> się powiedzie i <citerefentry>
                    <refentrytitle>_fini</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> kontynuuje sprzątanie.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>Funkcja <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera strukturę <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> jako argument. Więcej informacji w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="epffy">Defining
        the Module Linkage Structures</olink>.</para>

        <para>Podobnie jak w punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, do zapisania informacji posłuży funkcja <olink
        remap="external" targetdoc="819-2256" targetptr="cmn-err-9f">
        <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <para>Poniższy kod funkcji <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> należy włączyć do pliku
        <filename>dummy.c</filename>. Struktura <literal>ml</literal> opisana
        jest w <olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="epffy">Defining the Module Linkage
        Structures</olink>.</para>

        <programlisting>int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}</programlisting>
      </sect3>

      <sect3 xml:id="epmnl">
        <title>Including Loadable Module Configuration Header Files</title>

        <para>Funkcje <olink remap="external" targetdoc="819-2255"
        targetptr="u-init-9e"> <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <olink remap="external" targetdoc="819-2256"
        targetptr="mod-install-9f"> <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wymagają włączenia pliku nagłówkowego
        <literal>modctl.h</literal>. Funkcja <olink remap="external"
        targetdoc="819-2256" targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wymaga włączenia plików nagłówkowych
        <literal>cmn_err.h</literal>, <literal>ddi.h </literal>i
        <literal>sunddi.h</literal>.</para>

        <para>Poniższe pliki nagłówkowe są wymagane przez trzy funkcje
        konfiguracji modułu ładowalnego napisane w tym rozdziale. Poniższy kod
        należy włączyć na początku pliku <filename>dummy.c</filename>.</para>

        <programlisting>#include &lt;sys/modctl.h&gt;  /* używane przez _init, _info, _fini */
#include &lt;sys/cmn_err.h&gt; /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/ddi.h&gt;     /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/sunddi.h&gt;  /* używane przez wszystkie punkty wejścia w tym sterowniku */</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="epmnh">
      <title>Writing the Autoconfiguration Entry Points</title>

      <indexterm xml:id="indexterm-204">
        <primary>entry points</primary>

        <secondary>autoconfiguration</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-205">
        <primary>entry points</primary>

        <secondary><function>attach </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-206">
        <primary><function>attach </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-207">
        <primary><function>ddi_create_minor_node </function> kernel
        function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-208">
        <primary>kernel functions</primary>

        <secondary><function>ddi_create_minor_node </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-209">
        <primary>entry points</primary>

        <secondary><function>detach </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-210">
        <primary><function>detach </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-211">
        <primary><function>ddi_remove_minor_node </function> kernel
        function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-212">
        <primary>kernel functions</primary>

        <secondary><function>ddi_remove_minor_node </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-213">
        <primary>entry points</primary>

        <secondary><function>getinfo </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-214">
        <primary><function>getinfo </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-215">
        <primary>entry points</primary>

        <secondary><function>prop_op </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-216">
        <primary><function>prop_op </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-217">
        <primary><function>ddi_prop_op </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-218">
        <primary>kernel functions</primary>

        <secondary><function>ddi_prop_op </function></secondary>
      </indexterm>

      <itemizedlist>
        <para>Każdy sterownik znakowy musi zdefiniować przynajmniej poniższe
        punkty wejścia autokonfiguracji. Jądro wywołuje te funkcje kiedy
        sterownik jest ładowany.</para>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="attach-9e"> <citerefentry>
              <refentrytitle>attach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> musi wywołać <olink remap="external"
          targetdoc="819-2256" targetptr="ddi-create-minor-node-9f">
          <citerefentry>
              <refentrytitle>ddi_create_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink>. Funkcja <citerefentry>
              <refentrytitle>ddi_create_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> dostarcza informacji potrzebnych systemowi do
          stworzenia plików urządzenia.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="detach-9e"> <citerefentry>
              <refentrytitle>detach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> musi wywołać <olink remap="external"
          targetdoc="819-2256" targetptr="ddi-remove-minor-node-9f">
          <citerefentry>
              <refentrytitle>ddi_remove_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> do uwolnienia wszystkiego, co zostało
          zaalokowane przez <citerefentry>
              <refentrytitle>ddi_create_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>. Funkcja <citerefentry>
              <refentrytitle>detach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wykonać pracę odwrotną do pracy wykonanej
          przez <citerefentry>
              <refentrytitle>attach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="getinfo-9e"> <citerefentry>
              <refentrytitle>getinfo</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zwraca informacje o wskazanym sterowniku
          przez jeden ze swoich argumentów.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="prop-op-9e"> <citerefentry>
              <refentrytitle>prop_op</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zwraca przez wskaźnik informacje o
          wskazanym sterowniku. Zamiast pisać własny punkt wywołania
          <citerefentry>
              <refentrytitle>prop_op</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> można użyć <olink remap="external"
          targetdoc="819-2256" targetptr="ddi-prop-op-9f"> <citerefentry>
              <refentrytitle>ddi_prop_op</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink>. Punktu wejścia <citerefentry>
              <refentrytitle>prop_op</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> można użyć do zmodyfikowania zachowania funkcji
          <citerefentry>
              <refentrytitle>ddi_prop_op</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>.</para>
        </listitem>
      </itemizedlist>

      <para>W tej sekcji dodano następujący kod:</para>

      <programlisting>/* Punkty wejścia autokonfiguracji sterownika */
static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}</programlisting>

      <sect3 xml:id="epmqa">
        <title>Declaring the Autoconfiguration Entry Points</title>

        <para>Punkty wejścia <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> muszą mieć nazwy unikalne dla danego sterownika.
        Należy wybrać prefiks dla każdej funkcji punktu wejścia.</para>

        <note>
          <para><indexterm xml:id="indexterm-219">
              <primary>prefixes</primary>
            </indexterm> <indexterm xml:id="indexterm-220">
              <primary>devices</primary>

              <secondary>prefixes</secondary>
            </indexterm>Konwencja nakazuje, aby prefiks używany dla funkcji i
          danych unikalnych dla sterownika jest albo nazwą sterownika, albo
          jej skrótem. Prefiksu należy używać w całym sterowniku. Ułatwia to
          poszukiwanie błędów.</para>
        </note>

        <para>W przykładzie omawianym w tym rozdziale jako prefiksu dla każdej
        funkcji i danej unikalnej dla modułu używa się
        <literal>dummy_</literal>.</para>

        <para>Poniższe deklaracje to punkty wejścia autokonfiguracji wymagane
        w pliku <filename>dummy.c</filename>. Należy zauważyć, że każda z tych
        funkcji zadeklarowana jest jako <literal>static</literal>.</para>

        <programlisting>static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);</programlisting>
      </sect3>

      <sect3 xml:id="epmqc">
        <title>Defining the Device Attach Entry Point</title>

        <indexterm xml:id="indexterm-221">
          <primary>entry points</primary>

          <secondary><function>attach </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-222">
          <primary><function>attach </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-223">
          <primary><function>ddi_soft_state </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-224">
          <primary>kernel functions</primary>

          <secondary><function>ddi_soft_state </function></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="attach-9e"> <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> równy
        <literal>DDI_SUCCESS</literal> albo <literal>DDI_FAILURE</literal>. Te
        dwie stałe są zdefiniowane w <filename>sunddi.h</filename>. Wszystkie
        funkcje punktów wejścia autokonfiguracji, za wyjątkiem <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, zwracają <literal>DDI_SUCCESS</literal> lub
        <literal>DDI_FAILURE</literal>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> pobiera dwa argumenty. Pierwszy to wstaźnik do
        struktury <literal>dev_info</literal> sterownika. Wszystkie funkcje
        punktów wejścia autokonfiguracji pobierają <literal>dev_info</literal>
        jako argument. Drugi argument to stała wskazująca typ podłączenia.
        Wartość to <literal>DDI_ATTACH</literal> lub
        <literal>DDI_RESUME</literal>. Każda funkcja <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> mudi zdefiniować zachowanie przynajmniej dla
        <literal>DDI_ATTACH</literal>.</para>

        <para>Kod <literal>DDI_ATTACH</literal>musi inicjalizować instancę
        urządzenia. W rzeczywistym sterowniku definiuje się i zarządza wieloma
        instancjami sterownika przy użyciu struktury stanu i funkcji <olink
        remap="external" targetdoc="819-2256" targetptr="ddi-soft-state-9f">
        <citerefentry>
            <refentrytitle>ddi_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Każda instancja ma swoją kopię struktury
        stanu zawierającą dane lokalne dla tej instancji. Jedną z takich
        danych lokalnych dla instancji jest jest wskaźnik instancji
        urządzenia. Każda instancja sterownika reprezentowana jest osobnym
        plikiem urządzenia w katalogu <filename>/devices</filename>. Na każdy
        plik wskazuje inny wskaźnik instancji urządzenia. Więcej informacji o
        funkcjach <citerefentry>
            <refentrytitle>ddi_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w <olink remap="external" targetdoc="chapter-3.xml"
        targetptr="fcowf">Managing Device State</olink>. Więcej informacji o
        instancjach w <olink remap="external" targetdoc="chapter-1.xml"
        targetptr="fgomr">Devices as Files</olink>.</para>

        <para>Opisywany sterownik <literal>dummy</literal> pozwala na tylko
        jedną instancję. Z tego względu sterownik nie zawiera struktury stanu,
        ale nadal musi zadeklarować wskaźnik na instancję urządzenia i
        zainicjować wskaźnik w funkcji <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Poniższy kod wprowadzony blisko początku pliku
        <filename>dummy.c</filename> zadeklaruje wskaźnik na instancję
        sterownika:</para>

        <programlisting>dev_info_t *dummy_dip;  /* śledzenie jednej instancji */</programlisting>

        <para>Poniższy kod to funkcja <function>dummy_attach</function> z
        pliku <filename>dummy.c</filename>. Nazwę funkcji można skopiować
        bezpośrednio z deklaracji wprowadzonej w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epmqa">Declaring the
        Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</programlisting>

        <para><indexterm xml:id="indexterm-225">
            <primary><function>ddi_get_instance </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-226">
            <primary>kernel functions</primary>

            <secondary><function>ddi_get_instance </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-227">
            <primary><function>ddi_create_minor_node </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-228">
            <primary>kernel functions</primary>

            <secondary><function>ddi_create_minor_node </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-229">
            <primary>device instance pointer (dip)</primary>
          </indexterm> <indexterm xml:id="indexterm-230">
            <primary><literal>dev_info</literal> device structure</primary>
          </indexterm> <indexterm xml:id="indexterm-231">
            <primary>device structures</primary>

            <secondary><literal>dev_info</literal></secondary>
          </indexterm> <indexterm xml:id="indexterm-232">
            <primary>devices</primary>

            <secondary>numbers</secondary>
          </indexterm> <indexterm xml:id="indexterm-233">
            <primary>minor number</primary>
          </indexterm> <indexterm xml:id="indexterm-234">
            <primary>instance number</primary>
          </indexterm> <indexterm xml:id="indexterm-235">
            <primary>devices</primary>

            <secondary>instances</secondary>
          </indexterm>Najpierw należy użyć <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do zapisania wiadomości do logu systemu, jak w
        punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Potem trzeba zdefiniować zachowanie
        <literal>DDI_ATTACH</literal>. W kodzie <literal>DDI_ATTACH</literal>
        najpierw przypisany zostanie wskaźnik instancji urządzenia
        przekazywany jako argument <function>dummy_attach </function>do
        zmiennej the <literal>dummy_dip</literal> zadeklarowanej wyżej.
        Wartość wskaźńika trzeba zapisać w zmiennej globalnej aby móc
        wykorzystać go do uzyskania informacji o instancji sterownika z
        <function>dummy_getinfo </function>i odłączyć go za pomocą
        <function>dummy_detach</function>. W funkcji
        <function>dummy_attach</function> wskaźnik instacji urządzenia jest
        używany przez funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-get-instance-9f"> <citerefentry>
            <refentrytitle>ddi_get_instance</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do uzyskania numeru instancji. Wskaźnik
        instancji i numer instancji są używane przez <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-create-minor-node-9f">
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do stworzenia nowego node'u
        urządzenia.</para>

        <para>Rzeczywisty sterownik prawdopodobnie użyłby funkcji
        <citerefentry>
            <refentrytitle>ddi_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do stworzenia i zarządzania nodem urządzenia.
        Opisywany prosty sterownik <literal>dummy</literal> używa funkcji
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do stworzenia node'u urządzenia. Funkcja
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera sześć argumentów. Pierwszy argument to
        wskaźnik instacji urządzenia wskazujący na strukturę
        <literal>dev_info</literal> danego urządzenia. Drugi argument to nazwa
        mniejszego node'u. Trzeci argument to <literal>S_IFCHR</literal> jeśli
        urządzenie jest znakowe, lub <literal>S_IFBLK</literal> jeśli
        urządzenie jest blokowe. Sterownik <literal>dummy</literal> to
        urządzenie znakowe.</para>

        <para>Czwarty argument funkcji <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> to młodszy numer młodszego urządzenia nazywany także
        numerem instancji. Funkcja <citerefentry>
            <refentrytitle>ddi_get_instance</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwraca ten numer instancji. Piąty argument to rodzaj
        node'u. Strona man dla funkcji <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zawiera listę możliwych typów node'ów. Node
        <literal>DDI_PSEUDO</literal> jest pseudourządzeniem. Szósty argument
        wskazuje, czy jest to urządzenie-klon. W przypadku przykładowego
        urządzenia tak nie jest, należy więc przekazać 0.</para>

        <para>Jeśli wywołanie <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zakończy się błędem, zapisana zostanie wiadomość do
        logów systemowych i zwrócona zostanie wartość
        <literal>DDI_FAILURE</literal>. Jeśli wywołanie <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zakończy się sukcesem, funkcja zwróci
        <literal>DDI_SUCCESS</literal>. Jeśli
        <function>dummy_attach</function> otrzyma inne <literal>cmd</literal>
        niż <literal>DDI_ATTACH</literal>, należy zwrócić
        <literal>DDI_FAILURE</literal>.</para>
      </sect3>

      <sect3 xml:id="epmqi">
        <title>Defining the Device Detach Entry Point</title>

        <indexterm xml:id="indexterm-236">
          <primary>entry points</primary>

          <secondary><function>detach </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-237">
          <primary><function>detach </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-238">
          <primary><function>ddi_remove_minor_node </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-239">
          <primary>kernel functions</primary>

          <secondary><function>ddi_remove_minor_node </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-240">
          <primary>device instance pointer (dip)</primary>
        </indexterm>

        <indexterm xml:id="indexterm-241">
          <primary><literal>dev_info</literal> device structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-242">
          <primary>device structures</primary>

          <secondary><literal>dev_info</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-243">
          <primary>instance number</primary>
        </indexterm>

        <indexterm xml:id="indexterm-244">
          <primary>devices</primary>

          <secondary>instances</secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="detach-9e"> <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> pobiera dwa arumenty. Pierwszy argument
        jest wskaźnikiem na struktury <literal>dev_info</literal> tego
        sterownika. Drugi argument jest stałą wskazująca rodzaj odłączenia.
        Argumentem może być albo <literal>DDI_DETACH</literal>, alboor
        <literal>DDI_SUSPEND</literal>. Każda funkcja <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi zdefiniować zachowanie przynajmniej dla
        <literal>DDI_DETACH</literal>.</para>

        <para>Kod <literal>DDI_DETACH</literal> musi wykonać pracę odwrotną do
        tej wykonanej przez <literal>DDI_ATTACH</literal>. W kodzie
        <literal>DDI_ATTACH</literal> funkcja <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zapisała adres nowej struktury
        <literal>dev_info</literal> i wywołała funkcję <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do stworzenia nowego node'u. W kodzie
        <literal>DDI_DETACH</literal> w funkcji <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> należy zresetować zmienną wskazującą na strukturę
        <literal>dev_info</literal> tego node'u. Należy także wywołać <olink
        remap="external" targetdoc="819-2256"
        targetptr="ddi-remove-minor-node-9f"> <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> aby usunąć node. Funkcja <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi uwolnić wszystko, co było zaalokowane, zamknąć
        wszystko, co było otwarte i zniszczyć wszystko, co było utworzone w
        funkcji <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod to funkcja <function>dummy_detach</function>, który
        należy dołączyć do pliku <filename>dummy.c</filename>. Nazwę funkcji
        można skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="epmqa">Declaring
        the Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</programlisting>

        <para>Użyto <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do zapisania wiadomości w logu systemowym, jak w
        punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Następnie zdefiniowano zachowanie
        <literal>DDI_DETACH</literal>. Wewnątrz kodu
        <literal>DDI_DETACH</literal> zresetowano zmienną<literal>
        dummy_dip</literal> ustawioną wcześniej w
        <function>dummy_attach</function>. Nie można zresetować tego wskaźnika
        instancji zanim usunie się wszystkie instancje urządzenia. Sterownik
        <literal>dummy</literal> obsługuje tylko jedną instancję.</para>

        <para>Następnie funkcja <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> usuwa node urządzenia. Funkcja <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera dwa argumenty. Pierwszy argument jest
        wskaźnikiem instancji urządzenia wskazującym strukturę
        <literal>dev_info</literal> tego urządzenia. Drugi argument to nazwa
        młodszego node'u do usunięcia. Jeśli wartość młodszego node'u równa
        jest <literal>NULL</literal>, funkcja <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> usunie wszystkie instancje urządzenia. Kod
        <literal>DDI_DETACH</literal> tego sterownika usuwa zawsze wszystkie
        instancje, dlatego <literal>dummy</literal> obsługuje tylko jedną
        instancję.</para>

        <para>Jeśli wartość argumentu <literal>cmd</literal> funkcji
        <function>dummy_detach</function> równy jest
        <literal>DDI_DETACH</literal>, usuwa się wszystkie instancje
        urządzenia i zwraca <literal>DDI_SUCCESS</literal>. Jeśli funkcja
        <function>dummy_detach</function> dostanie inny argument
        <literal>cmd</literal>, zwraca <literal>DDI_FAILURE</literal>.</para>
      </sect3>

      <sect3 xml:id="epmql">
        <title>Defining the Get Driver Information Entry Point</title>

        <indexterm xml:id="indexterm-245">
          <primary>entry points</primary>

          <secondary><function>getinfo </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-246">
          <primary><function>getinfo </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-247">
          <primary>device instance pointer (dip)</primary>
        </indexterm>

        <indexterm xml:id="indexterm-248">
          <primary><literal>dev_info</literal> device structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-249">
          <primary>device structures</primary>

          <secondary><literal>dev_info</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-250">
          <primary>instance number</primary>
        </indexterm>

        <indexterm xml:id="indexterm-251">
          <primary>devices</primary>

          <secondary>instances</secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="getinfo-9e"> <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> pobiera wskaźnik do numeru urządzenia i
        zwraca wskaźnik do struktury informacji urządzenia lub numer instancji
        urządzenia. Wartość zwracana przez tę funkcję jest równa stałej
        <literal>DDI_SUCCESS</literal> lub <literal>DDI_FAILURE</literal>.
        Wskaźnik lub numer instancji żądany od funkcji <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zwracany jest przez argument wskaźnikowy.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> pobiera cztery argumenty. Pierwszy to wskaźnik do
        struktury <literal>dev_info</literal> dla danego sterownika. Argument
        ten jest przestarzały (ang. obsolete) i nieużywany przez
        funkcję.</para>

        <para>Drugi argument to stała wskazująca, jaki rodzaj informacji
        żądany jest od <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Wartość tego argumentu to albo
        <literal>DDI_INFO_DEVT2DEVINFO</literal>, albo
        <literal>DDI_INFO_DEVT2INSTANCE</literal>. Trzeci argument to wskaźnik
        do numeru urządzenia. Czwarty argument jest wskaźnikiem do miejsca, w
        którym funkcja <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi zapisać żądane dane. Dane zapisane w tym
        miejscu zależą od wartości drugiego argumentu przekazanego
        funkcji.</para>

        <para>Poniższa tabela opisuje związek międxzy drugim i czwartym
        argumentem funkcji <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <table frame="topbot" xml:id="eqbiy">
          <title>Get Driver Information Entry Point Arguments</title>

          <tgroup cols="3" colsep="0" rowsep="0">
            <colspec colwidth="33*" />

            <colspec colwidth="33*" />

            <colspec colwidth="33*" />

            <thead>
              <row rowsep="1">
                <entry><para> <replaceable>cmd</replaceable> </para></entry>

                <entry><para> <replaceable>arg</replaceable> </para></entry>

                <entry><para> <replaceable>resultp</replaceable>
                </para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para> <literal>DDI_INFO_DEVT2DEVINFO</literal>
                </para></entry>

                <entry><para>Numer urządzenia</para></entry>

                <entry><para>Wkaźnik do struktury informacji
                urządzenia</para></entry>
              </row>

              <row>
                <entry><para> <literal>DDI_INFO_DEVT2INSTANCE</literal>
                </para></entry>

                <entry><para>Numer urządzenia</para></entry>

                <entry><para>Numer instancji urządzenia</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Poniższy kod to funkcja <function>dummy_getinfo</function> do
        włączenia do kodu pliku <filename>dummy.c</filename>. Nazwę funkcji
        można skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="epmqa">Declaring
        the Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</programlisting>

        <para>Użyto <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do zapisania wiadomości w logu systemowym, jak w
        punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Później zdefiniowano zachowanie
        <literal>DDI_INFO_DEVT2DEVINFO</literal>. Prawdziwy sterownik użyłby
        <replaceable>arg</replaceable> do uzyskania numeru instancji tego
        node'u urządzenia, a później wywołałby <citerefentry>
            <refentrytitle>ddi_get_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> i zwrócił wskaźnik do struktury informacji z tej
        struktury. Sterownik <literal>dummy</literal> obsługuje tylko
        jedną instancję urządzenia, dlatego w kodzie
        <literal>DDI_INFO_DEVT2DEVINFO</literal> funkcji
        <function>dummy_getinfo</function> po prostu zwracany jest jedyny
        wskaźnik do struktury informacji o urządzeniu, który zapisała funkcja
        <function>dummy_attach</function>.</para>

        <para>Następnie zdefiniowano zachowanie
        <literal>DDI_INFO_DEVT2INSTANCE</literal>. Kod
        <literal>DDI_INFO_DEVT2INSTANCE</literal> po prostu zwraca 0.
        Sterownik <literal>dummy</literal> obsługuje tylko jedeną instancję
        urządzenia, której numerem jest 0.</para>
      </sect3>

      <sect3 xml:id="epmqj">
        <title>Defining the Report Driver Property Information Entry
        Point</title>

        <indexterm xml:id="indexterm-252">
          <primary>devices</primary>

          <secondary>properties</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-253">
          <primary>entry points</primary>

          <secondary><function>prop_op </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-254">
          <primary><function>prop_op </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-255">
          <primary><function>ddi_prop_op </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-256">
          <primary>kernel functions</primary>

          <secondary><function>ddi_prop_op </function></secondary>
        </indexterm>

        <para>The <olink remap="external" targetdoc="819-2255"
        targetptr="prop-op-9e"> <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> entry point is required for every driver.
        If your driver does not need to customize the behavior of the
        <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry point, then your driver can use the <olink
        remap="external" targetdoc="819-2256" targetptr="ddi-prop-op-9f">
        <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function for the <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry point. Drivers that create and manage their
        own properties need a custom <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine. This <literal>dummy</literal> driver uses a
        <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine to call <olink remap="external"
        targetdoc="819-2256" targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> before calling the <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function.</para>

        <para>The <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry point and the <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function both require that you include the
        <literal>types.h</literal> header file. The <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry point and the <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function both take the same seven arguments. These
        arguments are not discussed here because this <literal>dummy</literal>
        driver does not create and manage its own properties. See the
        <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> man page to learn about the <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> arguments.</para>

        <para>The following code is the <function>dummy_prop_op </function>
        routine that you should enter into your <filename>dummy.c</filename>
        file. You can copy the name portion of this function definition
        directly from the declaration you entered in <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epmqa">Declaring the
        Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}</programlisting>

        <para>First, use <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> to write a message to the system log, as you did in
        your <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry point. Then call the <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function with exactly the same arguments as the
        <function>dummy_prop_op </function> function.</para>
      </sect3>

      <sect3 xml:id="epmqe">
        <title>Including Autoconfiguration Header Files</title>

        <para>All of the autoconfiguration entry point routines and all of the
        user context entry point routines require that you include the
        <filename>ddi.h</filename> and <filename>sunddi.h</filename> header
        files. You already included these two header files for the
        <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function.</para>

        <para>The <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-create-minor-node-9f"> <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function requires the
        <filename>stat.h</filename> header file. The <function>dummy_attach
        </function> routine calls the <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function. The <olink remap="external"
        targetdoc="819-2255" targetptr="prop-op-9e"> <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> and the <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-prop-op-9f"> <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> functions require the
        <filename>types.h</filename> header file.</para>

        <para>The following code is the list of header files that you now
        should have included in your <filename>dummy.c</filename> file for the
        four autoconfiguration routines you have written in this section and
        the three loadable module configuration routines you wrote in the
        previous section.</para>

        <programlisting>#include &lt;sys/modctl.h&gt;  /* used by _init, _info, _fini */
#include &lt;sys/types.h&gt;   /* used by prop_op, ddi_prop_op */
#include &lt;sys/stat.h&gt;    /* defines S_IFCHR used by ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* used by all entry points for this driver */
#include &lt;sys/ddi.h&gt;     /* used by all entry points for this driver */
                         /* also used by ddi_get_instance, ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* used by all entry points for this driver */
                         /* also used by ddi_create_minor_node, */
                         /* ddi_get_instance, and ddi_prop_op */</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="epmni">
      <title>Writing the User Context Entry Points</title>

      <indexterm xml:id="indexterm-257">
        <primary>entry points</primary>

        <secondary>user context</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-258">
        <primary>entry points</primary>

        <secondary><function>open </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-259">
        <primary><function>open </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-260">
        <primary><function>nulldev </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-261">
        <primary>kernel functions</primary>

        <secondary><function>nulldev </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-262">
        <primary>entry points</primary>

        <secondary><function>close </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-263">
        <primary><function>close </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-264">
        <primary>entry points</primary>

        <secondary><function>read </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-265">
        <primary><function>read </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-266">
        <primary>entry points</primary>

        <secondary><function>write </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-267">
        <primary><function>write </function> entry point</primary>
      </indexterm>

      <para>User context entry points correspond closely to system calls. When
      a system call opens a device file, then the <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> routine in the driver for that device is
      called.</para>

      <para>All character and block drivers must define the <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> user context entry point. However, the <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> routine can be <olink remap="external"
      targetdoc="819-2256" targetptr="nulldev-9f"> <citerefentry>
          <refentrytitle>nulldev</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink>. The <citerefentry>
          <refentrytitle>close</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>read</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, and <citerefentry>
          <refentrytitle>write</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> user context routines are optional.</para>

      <itemizedlist>
        <listitem>
          <para>The <olink remap="external" targetdoc="819-2255"
          targetptr="open-9e"> <citerefentry>
              <refentrytitle>open</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> routine gains access to the
          device.</para>
        </listitem>

        <listitem>
          <para>The <olink remap="external" targetdoc="819-2255"
          targetptr="close-9e"> <citerefentry>
              <refentrytitle>close</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> routine relinquishes access to the
          device. The <citerefentry>
              <refentrytitle>close</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> routine must undo everything that the
          <citerefentry>
              <refentrytitle>open</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> routine did.</para>
        </listitem>

        <listitem>
          <para>The <olink remap="external" targetdoc="819-2255"
          targetptr="read-9e"> <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> routine reads data from the device
          node.</para>
        </listitem>

        <listitem>
          <para>The <olink remap="external" targetdoc="819-2255"
          targetptr="write-9e"> <citerefentry>
              <refentrytitle>write</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> routine writes data to the device
          node.</para>
        </listitem>
      </itemizedlist>

      <para>In this section, the following code is added:</para>

      <programlisting>/* Use context entry points */
static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}

static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}

static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}

static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</programlisting>

      <sect3 xml:id="eqbim">
        <title>Declaring the User Context Entry Points</title>

        <para>The user context entry point routines need to be uniquely named
        for this driver. Use the same prefix for each of the user context
        entry points that you used for each of the autoconfiguration entry
        point routines. The following declarations are the entry point
        declarations you should have in your <filename>dummy.c</filename>
        file:</para>

        <programlisting>static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);
static int dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred);
static int dummy_close(dev_t dev, int flag, int otyp, cred_t *cred);
static int dummy_read(dev_t dev, struct uio *uiop, cred_t *credp);
static int dummy_write(dev_t dev, struct uio *uiop, cred_t *credp);</programlisting>
      </sect3>

      <sect3 xml:id="eqbii">
        <title>Defining the Open Device Entry Point</title>

        <indexterm xml:id="indexterm-268">
          <primary>entry points</primary>

          <secondary><function>open </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-269">
          <primary><function>open </function> entry point</primary>
        </indexterm>

        <para>The <olink remap="external" targetdoc="819-2255"
        targetptr="open-9e"> <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> routine returns type
        <literal>int</literal>. The <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine should return either
        <literal>DDI_SUCCESS</literal> or the appropriate error number.</para>

        <para>The <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine takes four arguments. This
        <literal>dummy</literal> driver is so simple that this
        <function>dummy_open </function> routine does not use any of the
        <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> arguments. The examples in <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> show the <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine in more detail.</para>

        <para>The following code is the <function>dummy_open </function>
        routine that you should enter into your <filename>dummy.c</filename>
        file. You can copy the name portion of this function definition
        directly from the declaration you entered in <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eqbim">Declaring the User Context
        Entry Points</olink>. Write a message to the system log and return
        success.</para>

        <programlisting>static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbil">
        <title>Defining the Close Device Entry Point</title>

        <indexterm xml:id="indexterm-270">
          <primary>entry points</primary>

          <secondary><function>close </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-271">
          <primary><function>close </function> entry point</primary>
        </indexterm>

        <para>The <olink remap="external" targetdoc="819-2255"
        targetptr="close-9e"> <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> routine returns type
        <literal>int</literal>. The <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine should return either
        <literal>DDI_SUCCESS</literal> or the appropriate error number.</para>

        <para>The <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine takes four arguments. This
        <literal>dummy</literal> driver is so simple that this
        <function>dummy_close </function> routine does not use any of the
        <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> arguments. The examples in <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> show the <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine in more detail.</para>

        <para>The <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine must undo everything that the <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine did. The <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine must deallocate anything that was allocated,
        close anything that was opened, and destroy anything that was created
        in the <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine. In this <literal>dummy</literal> driver,
        the <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine is so simple that nothing needs to be
        reclaimed or undone in the <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine.</para>

        <para>The following code is the <function>dummy_close </function>
        routine that you should enter into your <filename>dummy.c</filename>
        file. You can copy the name portion of this function definition
        directly from the declaration you entered in <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eqbim">Declaring the User Context
        Entry Points</olink>. Write a message to the system log and return
        success.</para>

        <programlisting>static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbjc">
        <title>Defining the Read Device Entry Point</title>

        <indexterm xml:id="indexterm-272">
          <primary>entry points</primary>

          <secondary><function>read </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-273">
          <primary><function>read </function> entry point</primary>
        </indexterm>

        <para>The <olink remap="external" targetdoc="819-2255"
        targetptr="read-9e"> <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> routine returns type
        <literal>int</literal>. The <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine should return either
        <literal>DDI_SUCCESS</literal> or the appropriate error number.</para>

        <para>The <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine takes three arguments. This
        <literal>dummy</literal> driver is so simple that this
        <function>dummy_read </function> routine does not use any of the
        <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> arguments. The examples in <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> show the <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine in more detail.</para>

        <para>The following code is the <function>dummy_read </function>
        routine that you should enter into your <filename>dummy.c</filename>
        file. You can copy the name portion of this function definition
        directly from the declaration you entered in <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eqbim">Declaring the User Context
        Entry Points</olink>. Write a message to the system log and return
        success.</para>

        <programlisting>static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbjb">
        <title>Defining the Write Device Entry Point</title>

        <indexterm xml:id="indexterm-274">
          <primary>entry points</primary>

          <secondary><function>write </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-275">
          <primary><function>write </function> entry point</primary>
        </indexterm>

        <para>The <olink remap="external" targetdoc="819-2255"
        targetptr="write-9e"> <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> routine returns type
        <literal>int</literal>. The <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine should return either
        <literal>DDI_SUCCESS</literal> or the appropriate error number.</para>

        <para>The <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine takes three arguments. This
        <literal>dummy</literal> driver is so simple that this
        <function>dummy_write </function> routine does not use any of the
        <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> arguments. The examples in <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> show the <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine in more detail.</para>

        <para>The following code is the <function>dummy_write </function>
        routine that you should enter into your <filename>dummy.c</filename>
        file. You can copy the name portion of this function definition
        directly from the declaration you entered in <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eqbim">Declaring the User Context
        Entry Points</olink>. Write a message to the system log and return
        success.</para>

        <programlisting>static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbit">
        <title>Including User Context Header Files</title>

        <para>The four user context entry point routines require your module
        to include several header files. You already have included the
        <filename>types.h</filename> header file, the
        <filename>ddi.h</filename> header file, and the
        <filename>sunddi.h</filename> header file. You need to include the
        <filename>file.h</filename>, <filename>errno.h</filename>,
        <filename>open.h</filename>, <filename>cred.h</filename>, and
        <filename>uio.h</filename> header files.</para>

        <para>The following code is the list of header files that you now
        should have included in your <filename>dummy.c</filename> file for all
        the entry points you have written in this section and the previous two
        sections:</para>

        <programlisting>#include &lt;sys/modctl.h&gt;  /* used by modlinkage, modldrv, _init, _info, */
                         /* and _fini */
#include &lt;sys/types.h&gt;   /* used by open, close, read, write, prop_op, */
                         /* and ddi_prop_op */
#include &lt;sys/file.h&gt;    /* used by open, close */
#include &lt;sys/errno.h&gt;   /* used by open, close, read, write */
#include &lt;sys/open.h&gt;    /* used by open, close, read, write */
#include &lt;sys/cred.h&gt;    /* used by open, close, read */
#include &lt;sys/uio.h&gt;     /* used by read */
#include &lt;sys/stat.h&gt;    /* defines S_IFCHR used by ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* used by all entry points for this driver */
#include &lt;sys/ddi.h&gt;     /* used by all entry points for this driver */
                         /* also used by ddi_get_instance and */
                         /* ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* used by all entry points for this driver */
                         /* also used by ddi_create_minor_node, */
                         /* ddi_get_instance, and ddi_prop_op */</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="eoxzx">
      <title>Writing the Driver Data Structures</title>

      <indexterm xml:id="indexterm-276">
        <primary><literal>dev_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-277">
        <primary>driver structures</primary>

        <secondary><literal>dev_ops</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-278">
        <primary><literal>cb_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-279">
        <primary>driver structures</primary>

        <secondary><literal>cb_ops</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-280">
        <primary><literal>modldrv</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-281">
        <primary>driver structures</primary>

        <secondary><literal>modldrv</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-282">
        <primary><literal>modlinkage</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-283">
        <primary>driver structures</primary>

        <secondary><literal>modlinkage</literal></secondary>
      </indexterm>

      <para>All of the data structures described in this section are required
      for every device driver. All drivers must define a <olink
      remap="external" targetdoc="819-2257" targetptr="dev-ops-9s">
      <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> device operations structure. Because the
      <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> structure includes a pointer to the <olink
      remap="external" targetdoc="819-2257" targetptr="cb-ops-9s">
      <citerefentry>
          <refentrytitle>cb_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> character and block operations structure, you
      must define the <citerefentry>
          <refentrytitle>cb_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> structure first. The <olink remap="external"
      targetdoc="819-2257" targetptr="modldrv-9s"> <citerefentry>
          <refentrytitle>modldrv</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> linkage structure for loadable drivers
      includes a pointer to the <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> structure. The <olink remap="external"
      targetdoc="819-2257" targetptr="modlinkage-9s"> <citerefentry>
          <refentrytitle>modlinkage</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> module linkage structure includes a pointer
      to the <citerefentry>
          <refentrytitle>modldrv</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> structure.</para>

      <para>Except for the loadable module configuration entry points, all of
      the required entry points for a driver are initialized in the character
      and block operations structure or in the device operations structure.
      Some optional entry points and other related data also are initialized
      in these data structures. Initializing the entry points in these data
      structures enables the driver to be dynamically loaded.</para>

      <para>The loadable module configuration entry points are not initialized
      in driver data structures. The <citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>_info</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, and <citerefentry>
          <refentrytitle>_fini</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> entry points are required for all kernel modules and
      are not specific to device driver modules.</para>

      <para>In this section, the following code is added:</para>

      <programlisting>/* cb_ops structure */
static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* no strategy - nodev returns ENXIO */
    nodev,              /* no print */
    nodev,              /* no dump */
    dummy_read,
    dummy_write,
    nodev,              /* no ioctl */
    nodev,              /* no devmap */
    nodev,              /* no mmap */
    nodev,              /* no segmap */
    nochpoll,           /* returns ENXIO for non-pollable devices */
    dummy_prop_op,
    NULL,               /* streamtab struct; if not NULL, all above */
                        /* fields are ignored */
    D_NEW | D_MP,       /* compatibility flags: see conf.h */
    CB_REV,             /* cb_ops revision number */
    nodev,              /* no aread */
    nodev               /* no awrite */
};

/* dev_ops structure */
static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                  /* reference count */
    dummy_getinfo,
    nulldev,            /* no identify - nulldev returns 0 */
    nulldev,            /* no probe */
    dummy_attach,
    dummy_detach,
    nodev,              /* no reset - nodev returns ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev               /* no power */
};

/* modldrv structure */
static struct modldrv md = {
    &amp;mod_driverops,     /* Type of module. This is a driver. */
    "dummy driver",     /* Name of the module. */
    &amp;dummy_dev_ops
};

/* modlinkage structure */
static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};

/* dev_info structure */
dev_info_t *dummy_dip;  /* keep track of one instance */</programlisting>

      <sect3 xml:id="eoyag">
        <title>Defining the Character and Block Operations Structure</title>

        <indexterm xml:id="indexterm-284">
          <primary>driver structures</primary>

          <secondary>character and block operations structure</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-285">
          <primary><literal>cb_ops</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-286">
          <primary>driver structures</primary>

          <secondary><literal>cb_ops</literal></secondary>
        </indexterm>

        <para>The <olink remap="external" targetdoc="819-2257"
        targetptr="cb-ops-9s"> <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> structure initializes standard character
        and block interfaces. See the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> man page to learn what each element is and what the
        value of each element should be. This <literal>dummy</literal> driver
        does not use all of the elements in the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure. See the description that follows the code
        sample.</para>

        <para>When you name this structure, use the same
        <literal>dummy_</literal> prefix that you used for the names of the
        autoconfiguration routines and the names of the user context routines.
        Prepend the <literal>static</literal> type modifier to the
        declaration.</para>

        <para>The following code is the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure that you should enter into your
        <filename>dummy.c</filename> file:</para>

        <programlisting>static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* no strategy - nodev returns ENXIO */
    nodev,              /* no print */
    nodev,              /* no dump */
    dummy_read,
    dummy_write,
    nodev,              /* no ioctl */
    nodev,              /* no devmap */
    nodev,              /* no mmap */
    nodev,              /* no segmap */
    nochpoll,           /* returns ENXIO for non-pollable devices */
    dummy_prop_op,
    NULL,               /* streamtab struct; if not NULL, all above */
                        /* fields are ignored */
    D_NEW | D_MP,       /* compatibility flags: see conf.h */
    CB_REV,             /* cb_ops revision number */
    nodev,              /* no aread */
    nodev               /* no awrite */
};</programlisting>

        <para>Enter the names of the <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> and <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry points for this driver as the values of the
        first two elements of this structure. Enter the names of the
        <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> and <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry points for this driver as the values of the
        sixth and seventh elements of this structure. Enter the name of the
        <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry point for this driver as the value of the
        thirteenth element in this structure.</para>

        <para><indexterm xml:id="indexterm-287">
            <primary><function>nodev </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-288">
            <primary>kernel functions</primary>

            <secondary><function>nodev </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-289">
            <primary><function>nochpoll </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-290">
            <primary>kernel functions</primary>

            <secondary><function>nochpoll </function></secondary>
          </indexterm>The <citerefentry>
            <refentrytitle>strategy</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>print</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, and <citerefentry>
            <refentrytitle>dump</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routines are for block drivers only. This
        <literal>dummy</literal> driver does not define these three routines
        because this driver is a character driver. This driver does not define
        an <citerefentry>
            <refentrytitle>ioctl</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry point because this driver does not use I/O
        control commands. This driver does not define <citerefentry>
            <refentrytitle>devmap</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>mmap</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, or <citerefentry>
            <refentrytitle>segmap</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry points because this driver does not support
        memory mapping. This driver does not does not define <citerefentry>
            <refentrytitle>aread</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> or <citerefentry>
            <refentrytitle>awrite</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> entry points because this driver does not perform
        any asynchronous reads or writes. Initialize all of these unused
        function elements to <olink remap="external" targetdoc="819-2256"
        targetptr="nodev-9f"> <citerefentry>
            <refentrytitle>nodev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. The <citerefentry>
            <refentrytitle>nodev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function returns the <literal>ENXIO</literal> error
        code.</para>

        <para>Specify the <olink remap="external" targetdoc="819-2256"
        targetptr="nochpoll-9f"> <citerefentry>
            <refentrytitle>nochpoll</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> function for the <citerefentry>
            <refentrytitle>chpoll</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> element of the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure because this driver is not for a pollable
        device. Specify <literal>NULL</literal> for the <citerefentry>
            <refentrytitle>streamtab</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> STREAMS entity declaration structure because this
        driver is not a STREAMS driver.</para>

        <para>The compatibility flags are defined in the
        <filename>conf.h</filename> header file. The <literal>D_NEW</literal>
        flag means this driver is a new-style driver. The
        <literal>D_MP</literal> flag means this driver safely allows multiple
        threads of execution. All drivers must be multithreaded-safe, and must
        specify this <literal>D_MP</literal> flag. The
        <literal>D_64BIT</literal> flag means this driver supports 64-bit
        offsets and block numbers. See the <filename>conf.h</filename> header
        file for more compatibility flags.</para>

        <para>The <literal>CB_REV</literal> element of the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> revision number. <literal>CB_REV</literal> is
        defined in the <filename>devops.h</filename> header file.</para>
      </sect3>

      <sect3 xml:id="eoyaf">
        <title>Defining the Device Operations Structure</title>

        <indexterm xml:id="indexterm-291">
          <primary>driver structures</primary>

          <secondary>device operations structure</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-292">
          <primary><literal>dev_ops</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-293">
          <primary>driver structures</primary>

          <secondary><literal>dev_ops</literal></secondary>
        </indexterm>

        <para>The <olink remap="external" targetdoc="819-2257"
        targetptr="dev-ops-9s"> <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> structure initializes interfaces that are
        used for operations such as attaching and detaching the driver. See
        the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> man page to learn what each element is and what the
        value of each element should be. This <literal>dummy</literal> driver
        does not use all of the elements in the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure. See the description that follows the code
        sample.</para>

        <para>When you name this structure, use the same
        <literal>dummy_</literal> prefix that you used for the names of the
        autoconfiguration routines and the names of the user context routines.
        Prepend the <literal>static</literal> type modifier to the
        declaration.</para>

        <para>The following code is the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure that you should enter into your
        <filename>dummy.c</filename> file:</para>

        <programlisting>static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                  /* reference count */
    dummy_getinfo,
    nulldev,            /* no identify - nulldev returns 0 */
    nulldev,            /* no probe */
    dummy_attach,
    dummy_detach,
    nodev,              /* no reset - nodev returns ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev               /* no power */
};</programlisting>

        <para>The <literal>DEVO_REV</literal> element of the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is the driver build version.
        <literal>DEVO_REV</literal> is defined in the
        <literal>devops.h</literal> header file. The second element in this
        structure is the driver reference count. Initialize this value to
        zero. The driver reference count is the number of instances of this
        driver that are currently open. The driver cannot be unloaded if any
        instances of the driver are still open.</para>

        <para><indexterm xml:id="indexterm-294">
            <primary><function>nulldev </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-295">
            <primary>kernel functions</primary>

            <secondary><function>nulldev </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-296">
            <primary><function>nodev </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-297">
            <primary>kernel functions</primary>

            <secondary><function>nodev </function></secondary>
          </indexterm>The next six elements of the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure are the names of the <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>identify</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>probe</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, and <function>reset </function> functions for this
        particular driver. The <citerefentry>
            <refentrytitle>identify</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> function is obsolete. Initialize this structure
        element to <olink remap="external" targetdoc="819-2256"
        targetptr="nulldev-9f"> <citerefentry>
            <refentrytitle>nulldev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. The <citerefentry>
            <refentrytitle>probe</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> function determines whether the corresponding device
        exists and is valid. This <literal>dummy</literal> driver does not
        define a <citerefentry>
            <refentrytitle>probe</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> function. Initialize this structure element to
        <literal>nulldev</literal>. The <citerefentry>
            <refentrytitle>nulldev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> function returns success. The <function>reset
        </function> function is obsolete. Initialize the <function>reset
        </function> function to <olink remap="external" targetdoc="819-2256"
        targetptr="nodev-9f"> <citerefentry>
            <refentrytitle>nodev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <para>The next element of the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is a pointer to the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure for this driver. You initialized the
        <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure for this driver in <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eoyag">Defining the Character and
        Block Operations Structure</olink>. Enter
        <literal>&amp;dummy_cb_ops</literal> for the value of the pointer to
        the <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure.</para>

        <para>The next element of the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is a pointer to the bus operations
        structure. Only nexus drivers have bus operations structures. This
        <literal>dummy</literal> driver is not a nexus driver. Set this value
        to <literal>NULL</literal> because this driver is a leaf
        driver.</para>

        <para>The last element of the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is the name of the <citerefentry>
            <refentrytitle>power</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine for this driver. The <citerefentry>
            <refentrytitle>power</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routine operates on a hardware device. This driver
        does not drive a hardware device. Set the value of this structure
        element to <literal>nodev</literal>.</para>
      </sect3>

      <sect3 xml:id="epffy">
        <title>Defining the Module Linkage Structures</title>

        <indexterm xml:id="indexterm-298">
          <primary>driver structures</primary>

          <secondary>module linkage structures</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-299">
          <primary><literal>modldrv</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-300">
          <primary>driver structures</primary>

          <secondary><literal>modldrv</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-301">
          <primary><literal>modlinkage</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-302">
          <primary>driver structures</primary>

          <secondary><literal>modlinkage</literal></secondary>
        </indexterm>

        <para>Two other module loading structures are required for every
        driver. The <olink remap="external" targetdoc="819-2257"
        targetptr="modlinkage-9s"> <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> module linkage structure is used by the
        <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, and <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> routines to install, remove, and retrieve
        information from a module. The <olink remap="external"
        targetdoc="819-2257" targetptr="modldrv-9s"> <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> linkage structure for loadable drivers
        exports driver-specific information to the kernel. See the man pages
        for each structure to learn what each element is and what the value of
        each element should be.</para>

        <para>The following code defines the <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> and <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structures for the driver shown in this
        chapter:</para>

        <programlisting>static struct modldrv md = {
    &amp;mod_driverops,     /* Type of module. This is a driver. */
    "dummy driver",     /* Name of the module. */
    &amp;dummy_dev_ops
};

static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};</programlisting>

        <para>The first element in the <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is a pointer to a structure that tells the
        kernel what kind of module this is. Set this value to the address of
        the <literal>mod_driverops</literal> structure. The
        <literal>mod_driverops</literal> structure tells the kernel that the
        <filename>dummy.c</filename> module is a loadable driver module. The
        <literal>mod_driverops</literal> structure is declared in the
        <filename>modctl.h</filename> header file. You already included the
        <filename>modctl.h</filename> header file in your
        <filename>dummy.c</filename> file, so do not declare the
        <literal>mod_driverops</literal> structure in
        <filename>dummy.c</filename>. The <literal>mod_driverops</literal>
        structure is defined in the <filename>modctl.c</filename> source
        file.</para>

        <para>The second element in the <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is a string that describes this module.
        Usually this string contains the name of this module and the version
        number of this module. The last element of the <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is a pointer to the <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure for this driver. You initialized the
        <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure for this driver in <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eoyaf">Defining the Device
        Operations Structure</olink>.</para>

        <para>The first element in the <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is the revision number of the loadable
        modules system. Set this value to <literal>MODREV_1</literal>. The
        next element of the <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure is the address of a null-terminated array
        of pointers to linkage structures. Driver modules have only one
        linkage structure. Enter the address of the <literal>md</literal>
        structure for the value of this element of the <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> structure. Enter the value <literal>NULL</literal>
        to terminate this list of linkage structures.</para>
      </sect3>

      <sect3 xml:id="eqbni">
        <title>Including Data Structures Header Files</title>

        <para>The <olink remap="external" targetdoc="819-2257"
        targetptr="cb-ops-9s"> <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> and <olink remap="external"
        targetdoc="819-2257" targetptr="dev-ops-9s"> <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> structures require you to include the
        <filename>conf.h</filename> and <filename>devops.h</filename> header
        files. The <olink remap="external" targetdoc="819-2257"
        targetptr="modlinkage-9s"> <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> and <olink remap="external"
        targetdoc="819-2257" targetptr="modldrv-9s"> <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> structures require you to include the
        <literal>modctl.h</literal> header file. You already included the
        <filename>modctl.h</filename> header file for the loadable module
        configuration entry points.</para>

        <para>The following code is the complete list of header files that you
        now should have included in your <filename>dummy.c</filename>
        file:</para>

        <programlisting>#include &lt;sys/devops.h&gt;  /* used by dev_ops */
#include &lt;sys/conf.h&gt;    /* used by dev_ops and cb_ops */
#include &lt;sys/modctl.h&gt;  /* used by modlinkage, modldrv, _init, _info, */
                         /* and _fini */
#include &lt;sys/types.h&gt;   /* used by open, close, read, write, prop_op, */
                         /* and ddi_prop_op */
#include &lt;sys/file.h&gt;    /* used by open, close */
#include &lt;sys/errno.h&gt;   /* used by open, close, read, write */
#include &lt;sys/open.h&gt;    /* used by open, close, read, write */
#include &lt;sys/cred.h&gt;    /* used by open, close, read */
#include &lt;sys/uio.h&gt;     /* used by read */
#include &lt;sys/stat.h&gt;    /* defines S_IFCHR used by ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* used by all entry points for this driver */
#include &lt;sys/ddi.h&gt;     /* used by all entry points for this driver */
                         /* also used by cb_ops, ddi_get_instance, and */
                         /* ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* used by all entry points for this driver */
                         /* also used by cb_ops, ddi_create_minor_node, */
                         /* ddi_get_instance, and ddi_prop_op */</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="eoxzw">
    <title>Writing the Device Configuration File</title>

    <indexterm xml:id="indexterm-303">
      <primary>configuration files</primary>
    </indexterm>

    <indexterm xml:id="indexterm-304">
      <primary>devices</primary>

      <secondary>configuration files</secondary>
    </indexterm>

    <para>This driver requires a configuration file. The minimum information
    that a configuration file must contain is the name of the device node and
    the name or type of the device's parent. In this simple example, the node
    name of the device is the same as the file name of the driver. Create a
    file named <filename>dummy.conf</filename> in your working directory. Put
    the following single line of information into
    <filename>dummy.conf</filename>:</para>

    <programlisting>name="dummy" parent="pseudo";</programlisting>
  </sect1>

  <sect1 xml:id="eoxzr">
    <title>Building and Installing the Template Driver</title>

    <para>This section shows you how to build and install the driver for a
    32-bit platform. See <olink remap="external" targetdoc="chapter-1.xml"
    targetptr="fgouv">Building a Driver</olink> and <olink remap="external"
    targetdoc="chapter-1.xml" targetptr="fsfqv">Installing a Driver</olink>
    for build and install instructions for SPARC architectures and for 64-bit
    x86 architectures.</para>

    <para>Compile and link the driver. Use the <option> D_KERNEL</option>
    option to indicate that this code defines a kernel module. The following
    example shows compiling and linking for a 32-bit architecture using the
    Sun Studio C compiler:</para>

    <screen>% <userinput>cc -D_KERNEL -c dummy.c</userinput>
% <userinput>ld -r -o dummy dummy.o</userinput>
</screen>

    <para>Make sure you are user <literal>root</literal> when you install the
    driver.</para>

    <para>Install drivers in the <filename>/tmp</filename> directory until you
    are finished modifying and testing the <function>_info </function>,
    <function>_init </function>, and <function>attach </function> routines.
    Copy the driver binary to the <filename>/tmp</filename> directory. Link to
    the driver from the kernel driver directory. See <olink remap="external"
    targetdoc="chapter-4.xml" targetptr="fdlbq">Device Driver Testing
    Tips</olink> for more information.</para>

    <screen># <userinput>cp dummy /tmp</userinput>
</screen>

    <para>Link to the following directory for a 32-bit architecture:</para>

    <screen># <userinput>ln -s /tmp/dummy /usr/kernel/drv/dummy</userinput>
</screen>

    <para>Copy the configuration file to the kernel driver area of the
    system.</para>

    <screen># <userinput>cp dummy.conf /usr/kernel/drv</userinput>
</screen>
  </sect1>

  <sect1 xml:id="eoxzu">
    <title>Testing the Template Driver</title>

    <indexterm xml:id="indexterm-305">
      <primary>files</primary>

      <secondary><filename>/var/adm/messages</filename></secondary>
    </indexterm>

    <indexterm xml:id="indexterm-306">
      <primary><filename>/var/adm/messages</filename> file</primary>
    </indexterm>

    <indexterm xml:id="indexterm-307">
      <primary>commands</primary>

      <secondary><command>syslogd</command></secondary>
    </indexterm>

    <indexterm xml:id="indexterm-308">
      <primary><command>syslogd</command> command</primary>
    </indexterm>

    <indexterm xml:id="indexterm-309">
      <primary><function>cmn_err </function> kernel function</primary>
    </indexterm>

    <indexterm xml:id="indexterm-310">
      <primary>kernel functions</primary>

      <secondary><function>cmn_err </function></secondary>
    </indexterm>

    <para>This <literal>dummy</literal> driver merely writes a message to a
    system log each time an entry point routine is entered. To test this
    driver, watch for these messages to confirm that each entry point routine
    is successfully entered.</para>

    <para>The <olink remap="external" targetdoc="819-2256"
    targetptr="cmn-err-9f"> <citerefentry>
        <refentrytitle>cmn_err</refentrytitle>

        <manvolnum>9F</manvolnum>
      </citerefentry> </olink> function writes low priority messages such as
    the messages defined in this <literal>dummy</literal> driver to
    <filename>/dev/log</filename>. The <olink remap="external"
    targetdoc="819-2240" targetptr="syslogd-1m"> <citerefentry>
        <refentrytitle>syslogd</refentrytitle>

        <manvolnum>1M</manvolnum>
      </citerefentry> </olink> daemon reads messages from
    <filename>/dev/log</filename> and writes low priority messages to
    <filename>/var/adm/messages</filename>.</para>

    <para>In a separate window, enter the following command and monitor the
    output as you perform the tests described in the remainder of this
    section:</para>

    <screen>% <userinput>tail -f /var/adm/messages</userinput>
</screen>

    <sect2 xml:id="eqbqx">
      <title>Adding the Template Driver</title>

      <indexterm xml:id="indexterm-311">
        <primary>device drivers</primary>

        <secondary>loading</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-312">
        <primary>commands</primary>

        <secondary><command>add_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-313">
        <primary><command>add_drv</command> command</primary>
      </indexterm>

      <para>Make sure you are user <literal>root</literal> when you add the
      driver. Use the <olink remap="external" targetdoc="819-2240"
      targetptr="add-drv-1m"> <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to add the driver:</para>

      <screen># <userinput>add_drv dummy</userinput>
</screen>

      <para>You should see the following messages in the window where you are
      viewing <filename>/var/adm/messages</filename>:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 513080 kern.notice] NOTICE: Inside _info
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 874762 kern.notice] NOTICE: Inside _init
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 678704 kern.notice] NOTICE: Inside dummy_attach</screen>

      <para>The <citerefentry>
          <refentrytitle>_info</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, and <citerefentry>
          <refentrytitle>attach</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> entry points are called in that order when you add a
      driver.</para>

      <para><indexterm xml:id="indexterm-314">
          <primary><literal>/devices/pseudo</literal> directory</primary>
        </indexterm>The <literal>dummy</literal> driver has been added to the
      <filename>/devices</filename> directory:</para>

      <screen>% <userinput>ls -l /devices/pseudo | grep dummy</userinput>
drwxr-xr-x   2 root     sys          512 <replaceable>date</replaceable> <replaceable>time</replaceable> dummy@0
crw-------   1 root     sys       92,  0 <replaceable>date</replaceable> <replaceable>time</replaceable> dummy@0:0</screen>

      <para><indexterm xml:id="indexterm-315">
          <primary>commands</primary>

          <secondary><command>modinfo</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-316">
          <primary><command>modinfo</command> command</primary>
        </indexterm>The <literal>dummy</literal> driver also is the most
      recent module listed by <olink remap="external" targetdoc="819-2240"
      targetptr="modinfo-1m"> <citerefentry>
          <refentrytitle>modinfo</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>:</para>

      <screen>% <userinput>modinfo</userinput>
 Id Loadaddr   Size Info Rev Module Name
180 ed192b70    544  92   1  dummy (dummy driver)</screen>

      <para><indexterm xml:id="indexterm-317">
          <primary>files</primary>

          <secondary><filename>/etc/name_to_major</filename></secondary>
        </indexterm> <indexterm xml:id="indexterm-318">
          <primary><filename>/etc/name_to_major</filename> file</primary>
        </indexterm>The module name, <literal>dummy driver</literal>, is the
      value you entered for the second member of the <citerefentry>
          <refentrytitle>modldrv</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> structure. The value <literal>92</literal> is the
      major number of this module.</para>

      <screen>% <userinput>grep dummy /etc/name_to_major</userinput>
dummy 92</screen>

      <para>The <literal>Loadaddr</literal> address of
      <literal>ed192b70</literal> is the address of the first instruction in
      the <literal>dummy</literal> driver. This address might be useful, for
      example, in debugging.</para>

      <screen>% <userinput>mdb -k</userinput>
&gt; dummy`_init $m
    BASE    LIMIT     SIZE NAME
ed192b70 ed192ff0      480 dummy
&gt; <userinput>$q</userinput>
</screen>

      <para><indexterm xml:id="indexterm-319">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-320">
          <primary><command>prtconf</command> command</primary>
        </indexterm>The <literal>dummy</literal> driver also is the most
      recent module listed by <olink remap="external" targetdoc="819-2240"
      targetptr="prtconf-1m"> <citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> in the pseudo device section:</para>

      <screen>% <userinput>prtconf -P</userinput>
    pseudo, instance #0
        dummy, instance #0 (driver not attached)</screen>

      <para>A driver is automatically loaded when a device that the driver
      manages is accessed. A driver might be automatically unloaded when the
      driver is not in use.</para>

      <itemizedlist>
        <para>If your driver is in the <filename>/devices</filename> directory
        but <citerefentry>
            <refentrytitle>modinfo</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> does not list your driver, you can use either of the
        following methods to load your driver:</para>

        <listitem>
          <para><indexterm xml:id="indexterm-321">
              <primary>commands</primary>

              <secondary><command>modload</command></secondary>
            </indexterm> <indexterm xml:id="indexterm-322">
              <primary><command>modload</command> command</primary>
            </indexterm>Use the <olink remap="external" targetdoc="819-2240"
          targetptr="modload-1m"> <citerefentry>
              <refentrytitle>modload</refentrytitle>

              <manvolnum>1M</manvolnum>
            </citerefentry> </olink> command.</para>
        </listitem>

        <listitem>
          <para>Access the device. The driver is loaded automatically when a
          device that the driver manages is accessed. The following section
          describes how to access the <literal>dummy</literal> device.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="eqbqv">
      <title>Reading and Writing the Device</title>

      <indexterm xml:id="indexterm-323">
        <primary>devices</primary>

        <secondary>reading</secondary>
      </indexterm>

      <para>Make sure you are user <literal>root</literal> when you perform
      the tests described in this section. If you are not user
      <literal>root</literal>, you will receive “Permission denied” error
      messages when you try to access the
      <filename>/devices/pseudo/dummy@0:0</filename> special file. Notice the
      permissions that are shown for
      <filename>/devices/pseudo/dummy@0:0</filename> in <olink
      remap="internal" targetdoc="chapter-2.xml" targetptr="eqbqx">Adding the
      Template Driver</olink>.</para>

      <para><indexterm xml:id="indexterm-324">
          <primary>commands</primary>

          <secondary><command>cat</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-325">
          <primary><command>cat</command> command</primary>
        </indexterm>Test reading from the device. Your
      <literal>dummy</literal> device probably is named
      <filename>/devices/pseudo/dummy@0:0</filename>. The following command
      reads from your <literal>dummy</literal> device even if it has a
      slightly different name:</para>

      <screen># <userinput>cat /devices/pseudo/dummy*</userinput>
</screen>

      <para>You should see the following messages in the window where you are
      viewing <filename>/var/adm/messages</filename>:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 136952 kern.notice] NOTICE: Inside dummy_open
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 709590 kern.notice] NOTICE: Inside dummy_read
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 550206 kern.notice] NOTICE: Inside dummy_close</screen>

      <para><indexterm xml:id="indexterm-326">
          <primary>devices</primary>

          <secondary>writing</secondary>
        </indexterm> <indexterm xml:id="indexterm-327">
          <primary>commands</primary>

          <secondary><command>echo</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-328">
          <primary><command>echo</command> command</primary>
        </indexterm>Test writing to the device:</para>

      <screen># <userinput>echo hello &gt; `ls /devices/pseudo/dummy*`</userinput>
</screen>

      <para>You should see the following messages in the window where you are
      viewing <filename>/var/adm/messages</filename>:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 136952 kern.notice] NOTICE: Inside dummy_open
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 672780 kern.notice] NOTICE: Inside dummy_write
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 550206 kern.notice] NOTICE: Inside dummy_close</screen>

      <para>As you can see, this output from the write test is almost
      identical to the output you saw from the read test. The only difference
      is in the seventh line of the output. Using the <olink remap="external"
      targetdoc="819-2239" targetptr="cat-1"> <citerefentry>
          <refentrytitle>cat</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> </olink> command causes the kernel to access the
      <olink remap="external" targetdoc="819-2255" targetptr="read-9e">
      <citerefentry>
          <refentrytitle>read</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> </olink> entry point of the driver. Using the <olink
      remap="external" targetdoc="819-2239" targetptr="echo-1"> <citerefentry>
          <refentrytitle>echo</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> </olink> command causes the kernel to access the
      <olink remap="external" targetdoc="819-2255" targetptr="write-9e">
      <citerefentry>
          <refentrytitle>write</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> </olink> entry point of the driver. The text argument
      that you give to <olink remap="external" targetdoc="819-2239"
      targetptr="echo-1"> <citerefentry>
          <refentrytitle>echo</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> </olink> is ignored because this driver does not do
      anything with that data.</para>
    </sect2>

    <sect2 xml:id="eqbqw">
      <title>Removing the Template Driver</title>

      <indexterm xml:id="indexterm-329">
        <primary>device drivers</primary>

        <secondary>removing</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-330">
        <primary>commands</primary>

        <secondary><command>rem_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-331">
        <primary><command>rem_drv</command> command</primary>
      </indexterm>

      <para>Make sure you are user <literal>root</literal> when you unload the
      driver. Use the <olink remap="external" targetdoc="819-2240"
      targetptr="rem-drv-1m"> <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to unload the driver and remove the
      device from the <filename>/devices</filename> directory:</para>

      <screen># <userinput>rem_drv dummy</userinput>
</screen>

      <para>You should see the following messages in the window where you are
      viewing <filename>/var/adm/messages</filename>:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 513080 kern.notice] NOTICE: Inside _info
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 617648 kern.notice] NOTICE: Inside dummy_detach
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 812373 kern.notice] NOTICE: Inside _fini</screen>

      <para>The <literal>dummy</literal> device is no longer in the
      <filename>/devices</filename> directory:</para>

      <screen># <userinput>ls /devices/pseudo/dummy*</userinput>
/devices/pseudo/dummy*: No such file or directory</screen>

      <para>The next time you want to read from or write to the
      <literal>dummy</literal> device, you must load the driver again using
      <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry>.</para>

      <para><indexterm xml:id="indexterm-332">
          <primary>device drivers</primary>

          <secondary>unloading</secondary>
        </indexterm> <indexterm xml:id="indexterm-333">
          <primary>commands</primary>

          <secondary><command>modunload</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-334">
          <primary><command>modunload</command> command</primary>
        </indexterm>You can use the <olink remap="external"
      targetdoc="819-2240" targetptr="modunload-1m"> <citerefentry>
          <refentrytitle>modunload</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> command to unload the driver but not remove
      the device from <filename>/devices</filename>. Then the next time you
      read from or write to the <literal>dummy</literal> device, the driver is
      automatically loaded.</para>

      <para>Press Control-C to stop tailing the
      <filename>/var/adm/messages</filename> messages.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="eqbof">
    <title>Complete Template Driver Source</title>

    <para>Poniższy kod to kompletny kod źródłowy dla sterownika
    <literal>dummy</literal> opisywanego w tym rozdziale:</para>

    <programlisting>/*
 * Proste pseudourządzenie.
 * Wypisuje informację zawsze, gdy następuje wejście do funkcji.
 *
 * Budowanie sterownika:
 *      cc -D_KERNEL -c dummy.c
 *      ld -r -o dummy dummy.o
 * Kopiowanie sterownika i pliku konfiguracyjnego do /usr/kernel/drv:
 *      cp dummy.conf /usr/kernel/drv
 *      cp dummy /tmp
 *      ln -s /tmp/dummy /usr/kernel/drv/dummy
 * Dodanie sterownika:
 *      add_drv dummy
 * Próbny (1) odczyt ze sterownika (2) zapis do sterownika:
 *      cat /devices/pseudo/dummy@*
 *      echo hello &gt; `ls /devices/pseudo/dummy@*`
 * Sprawdzenie wyników testu w innym oknie:
 *      tail -f /var/adm/messages
 * Usunięcie sterownika:
 *      rem_drv dummy
 */

#include &lt;sys/devops.h&gt;  /* używane przez dev_ops */
#include &lt;sys/conf.h&gt;    /* używane przez dev_ops i cb_ops */
#include &lt;sys/modctl.h&gt;  /* używane przez modlinkage, modldrv, _init, _info */
                         /* i _fini */
#include &lt;sys/types.h&gt;   /* używane przez open, close, read, write, prop_op */
                         /* i ddi_prop_op */
#include &lt;sys/file.h&gt;    /* używane przez open, close */
#include &lt;sys/errno.h&gt;   /* używane przez open, close, read, write */
#include &lt;sys/open.h&gt;    /* używane przez open, close, read, write */
#include &lt;sys/cred.h&gt;    /* używane przez open, close, read */
#include &lt;sys/uio.h&gt;     /* używane przez read */
#include &lt;sys/stat.h&gt;    /* definiuje S_IFCHR używane przez ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/ddi.h&gt;     /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* również używane przez cb_ops, ddi_get_instance */
                         /* i ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* także używane przez cb_ops, ddi_create_minor_node, */
                         /* ddi_get_instance i ddi_prop_op */

static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);
static int dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred);
static int dummy_close(dev_t dev, int flag, int otyp, cred_t *cred);
static int dummy_read(dev_t dev, struct uio *uiop, cred_t *credp);
static int dummy_write(dev_t dev, struct uio *uiop, cred_t *credp);

/* struktura cb_ops */
static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* brak strategy - nodev zwraca ENXIO */
    nodev,              /* brak print */
    nodev,              /* brak dump */
    dummy_read,
    dummy_write,
    nodev,              /* brak ioctl */
    nodev,              /* brak devmap */
    nodev,              /* brak mmap */
    nodev,              /* brak segmap */
    nochpoll,           /* zwraca ENXIO dla urządzeń, z ktorych nie można */
                        /* pobierać danych (ang. non-pollable) */
    dummy_prop_op,
    NULL,               /* struktura streamtab; jeśli nie NULL, to wszystkie */
                        /* powyższe pola są ignorowane */
    D_NEW | D_MP,       /* flagi kompatybilności: więcej w conf.h */
    CB_REV,             /* numer wersji cb_ops */
    nodev,              /* brak aread */
    nodev               /* brak awrite */
};

/* struktura dev_ops */
static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                  /* licznik odwołań */
    dummy_getinfo,
    nulldev,            /* brak identify - nulldev zwraca 0 */
    nulldev,            /* brak probe */
    dummy_attach,
    dummy_detach,
    nodev,              /* brak reset - nodev zwraca ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev               /* brak power */
};

/* struktura modldrv */
static struct modldrv md = {
    &amp;mod_driverops,     /* Typ modułu. To jest sterownik. */
    "dummy driver",     /* Nazwa modułu. */
    &amp;dummy_dev_ops
};

/* struktura modlinkage */
static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};

/* struktura dev_info */
dev_info_t *dummy_dip;  /* śledzenie instacji */


/* Punkty wejścia konfiguracji ładowalnego modułu */
int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}

int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}

int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}

/* Punkty wejścia konfiguracji urządzenia */
static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

/* Główne punkty wejścia */
static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}

static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}

static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}

static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}

static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</programlisting>
  </sect1>
</chapter>