<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN"
"docbook.dtd" [
<!ENTITY % xinclude SYSTEM "xinclude.mod">
%xinclude;
]>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook" xml:id="eoqrt">
  <title>Przykładowy sterownik urządzenia</title>

  <toc>
    <para>W tym rozdziale przedstawiono przykładowy proces tworzenia prostego,
    działającego sterownika. Wyjaśniono jak pisać sterownik, plik
    konfiguracyjny, skompilować sterownik, załadować go i przetestować.</para>

    <para><indexterm xml:id="indexterm-165">
        <primary>devices</primary>

        <secondary>pseudo</secondary>
      </indexterm>Sterownik przedstawiony w tym rozdziale to sterownik
    pseudourządzenia, wypisujący zaledwie wiadomość do logów systemowych za
    każdym razem, gdy następuje wejście przez punkt wejścia. Zawiera minimalną
    strukturę wymaganą od sterownika urządzenia znakowego. Można użyć go jako
    punkt wyjścia do napisania skomplikowanego sterownika.</para>

    <itemizedlist>
      <para>W rozdziale omawiane są następujące kroki tworzenia
      sterownika:</para>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="ffzpv">Overview of the Template Driver
        Example</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="writedriver">Writing the Template Driver</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eoxzw">Writing the Device Configuration File</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eoxzr">Building and Installing the Template
        Driver</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eoxzu">Testing the Template Driver</olink></para>
      </listitem>

      <listitem>
        <para><olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="eqbof">Complete Template Driver Source</olink></para>
      </listitem>
    </itemizedlist>
  </toc>

  <sect1 xml:id="ffzpv">
    <title>Overview of the Template Driver Example</title>

    <orderedlist>
      <para>Przykład przedstawia następujące kroki:</para>

      <listitem>
        <para>Stworzenie katalogu służącego do pisania sterownika i stworzenie
        pustego pliku <filename>dummy.c</filename>.</para>
      </listitem>

      <listitem>
        <para>Napisanie punktów wejścia dla konfiguracji ładowanego modułu:
        <olink remap="external" targetdoc="819-2255" targetptr="u-init-9e">
        <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="u-info-9e"> <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="u-fini-9e"> <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Napisanie puntków wejścia dla autokonfiguracji: <olink
        remap="external" targetdoc="819-2255" targetptr="attach-9e">
        <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="detach-9e"> <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="getinfo-9e"> <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="prop-op-9e"> <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Napisanie punktów wejścia dla kontekstu użytkownika: <olink
        remap="external" targetdoc="819-2255" targetptr="open-9e">
        <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="close-9e"> <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <olink remap="external"
        targetdoc="819-2255" targetptr="read-9e"> <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2255" targetptr="write-9e"> <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Zdefiniowanie struktur danych: struktury operacji znakowych i
        blokowych <olink remap="external" targetdoc="819-2257"
        targetptr="cb-ops-9s"> <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink>, struktury operacji urządzenia <olink
        remap="external" targetdoc="819-2257" targetptr="dev-ops-9s">
        <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> i struktur konsolidacji modułu <olink
        remap="external" targetdoc="819-2257" targetptr="modldrv-9s">
        <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2257" targetptr="modlinkage-9s"> <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink>.</para>
      </listitem>

      <listitem>
        <para>Stworzenie pliku konfiguracyjnego
        <filename>dummy.conf</filename>.</para>
      </listitem>

      <listitem>
        <para>Zbudowanie i zainstalowanie sterownika.</para>
      </listitem>

      <listitem>
        <para>Testowanie sterownika przez załadowanie go, odczytanie i zapis
        do node'u urządzenia oraz wyładowanie sterownika.</para>
      </listitem>
    </orderedlist>

    <para><indexterm xml:id="indexterm-166">
        <primary>device drivers</primary>

        <secondary>entry points</secondary>
      </indexterm>Punkty wejścia do napisania dla sterownika pokazane są na
    diagramie poniżej.</para>

    <figure xml:id="fgotp">
      <title>Entry Points for the <literal>dummy</literal> Example</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figures/epoints.dummy.gif"></imagedata>
        </imageobject>

        <textobject>
          <simpara>Diagram pokazuje punkty wejścia do stworzenia w
          przykładowym sterowniku.</simpara>
        </textobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1 xml:id="writedriver">
    <title>Writing the Template Driver</title>

    <indexterm xml:id="indexterm-167">
      <primary>devices</primary>

      <secondary>character</secondary>
    </indexterm>

    <para>Podrozdział ten opisuje punkty wejścia i struktury danych włączone
    do sterownika oraz opisuje jak je zdefiniować. Wszystkie te struktury
    danych i niemal wszystkie te punkty wejścia są wymagane dla każdego
    sterownika urządzenia znakowego.</para>

    <itemizedlist>
      <para>Podrozdział ten opisuje następujące punkty wejścia i struktury
      danych:</para>

      <listitem>
        <para>Punkty wejścia konfiguracji ładowalnych modułów</para>
      </listitem>

      <listitem>
        <para>Punkty wejścia autokonfiguracji</para>
      </listitem>

      <listitem>
        <para>Punkty wejścia kontekstu użytkownika</para>
      </listitem>

      <listitem>
        <para>Struktury operacji znakowych i blokowych</para>
      </listitem>

      <listitem>
        <para>Struktura operacji urządzenia</para>
      </listitem>

      <listitem>
        <para>Struktura konsolidacji modułu</para>
      </listitem>
    </itemizedlist>

    <para>Najpierw należy stworzyć katalog, w którym tworzony będzie
    sterownik. Sterownik nazywa się <literal>dummy</literal>, poniewż nie
    wykonuje żadnej prawdziwej pracy. W katalogu należy otworzyć do edycji
    nowy, pusty plik <filename>dummy.c</filename>.</para>

    <sect2 xml:id="eoxzy">
      <title>Writing the Loadable Module Configuration Entry Points</title>

      <indexterm xml:id="indexterm-168">
        <primary>entry points</primary>

        <secondary>loadable module configuration</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-169">
        <primary>entry points</primary>

        <secondary><function>_init </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-170">
        <primary><function>_init </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-171">
        <primary>entry points</primary>

        <secondary><function>_info </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-172">
        <primary><function>_info </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-173">
        <primary>entry points</primary>

        <secondary><function>_fini </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-174">
        <primary><function>_fini </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-175">
        <primary><function>mod_install </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-176">
        <primary>kernel functions</primary>

        <secondary><function>mod_install </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-177">
        <primary><function>mod_info </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-178">
        <primary>kernel functions</primary>

        <secondary><function>mod_info </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-179">
        <primary><function>mod_remove </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-180">
        <primary>kernel functions</primary>

        <secondary><function>mod_remove </function></secondary>
      </indexterm>

      <itemizedlist>
        <para>Każdy moduł jądra dowolnego typu musi zawierać przynajmniej trzy
        punkty wejścia konfiguracji ładowalnego modułu:</para>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="u-init-9e"> <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> inicjalizuje moduł ładowalny. Funkcja
          <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wywołać przynajmniej funkcję <olink
          remap="external" targetdoc="819-2256" targetptr="mod-install-9f">
          <citerefentry>
              <refentrytitle>mod_install</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> i zwrócić wartość sukcesu albo błędu
          zwracaną przez <citerefentry>
              <refentrytitle>mod_install</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="u-info-9e"> <citerefentry>
              <refentrytitle>_info</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zwraca informację o ładowalnym module.
          Funkcja <citerefentry>
              <refentrytitle>_info</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wywołać przynajmniej funkcję <olink
          remap="external" targetdoc="819-2256" targetptr="mod-info-9f">
          <citerefentry>
              <refentrytitle>mod_info</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> i zwrócić wartość zwracaną przez
          <citerefentry>
              <refentrytitle>mod_info</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="u-fini-9e"> <citerefentry>
              <refentrytitle>_fini</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> przygotowuje ładowalny moduł do
          wyładowania. Funkcja <citerefentry>
              <refentrytitle>_fini</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wywołać przynajmniej funkcję <olink
          remap="external" targetdoc="819-2256" targetptr="mod-remove-9f">
          <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> i zwrócić wartość sukcesu albo błędu
          zwróconą przez <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>. Jeśli <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> zwróci informację o powodzeniu, funkcja
          <citerefentry>
              <refentrytitle>_fini</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wykonać pracę odwrotną wykonała funkcja
          <citerefentry>
              <refentrytitle>_init</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>.</para>
        </listitem>
      </itemizedlist>

      <para>Funkcje <citerefentry>
          <refentrytitle>mod_install</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>mod_info</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>mod_remove</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> używane są dokładnie tak samo we wszystkich
      sterownikach, niezależnie od możliwości sterownika. Nie ma potrzeby
      dowiadywać się jakie powinny być wartości pzrekazywane tym funkcjom.
      Wywołania tych funkcji można skopiować z poniższego przykładu i
      bezpiecznie wkleić do dowolnego sterownika.</para>

      <para>Do pliku żródłowego the <filename>dummy.c</filename> dodano
      poniższy kod:</para>

      <programlisting>/* Punkty wejścia konfiguracji ładowalnego modułu */
int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}

int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}

int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}</programlisting>

      <sect3 xml:id="epmnj">
        <title>Declaring the Loadable Module Configuration Entry
        Points</title>

        <para>Nazwy funkcji <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> nie są unikalne dla żadnego modułu jądra. Ich
        działanie podlega modyfikacji podczas definiowania w module, ale ich
        nazwy nie są unikalne. Zadeklarowane są w pliku nagłówkowym
        <filename>modctl.h</filename> i trzeba go włączyć do pliku
        <filename>dummy.c</filename>. Funkcji tych nie należy samodzielnie
        deklarować w pliku <filename>dummy.c</filename>.</para>
      </sect3>

      <sect3 xml:id="epmnk">
        <title>Defining the Module Initialization Entry Point</title>

        <indexterm xml:id="indexterm-181">
          <primary>entry points</primary>

          <secondary><function>_init </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-182">
          <primary><function>_init </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-183">
          <primary><function>mod_install </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-184">
          <primary>kernel functions</primary>

          <secondary><function>mod_install </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-185">
          <primary><literal>modlinkage</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-186">
          <primary>driver structures</primary>

          <secondary><literal>modlinkage</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-187">
          <primary><function>cmn_err </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-188">
          <primary>kernel functions</primary>

          <secondary><function>cmn_err </function></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="u-init-9e"> <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> i nie
        pobiera argumentów. Funkcja <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wywołać funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="mod-install-9f"> <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i zwrócić wartość wskazującą powodzenie lub
        błąd zwracaną przez <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera argument będący strukturą <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry>. Więcej informacji w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epffy">Defining the Module
        Linkage Structures</olink>.</para>

        <para>Sterownik ma za zadanie wypisywać wiadomość za każdym razem, gdy
        następuje wejście przez punkt wejścia. Wiadomości w logu systemoweym
        zapisuje się funkcją <olink remap="external" targetdoc="819-2256"
        targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Funkcji <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> używa się zazwyczaj do zapisania informacji o
        błędzie, ale bywa też przydatna przy szukaniu błędów w sposób podobny
        do wyrażeń print w programie użytkownika.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> wymaga włączenia plików nagłówkowych
        <filename>cmn_err.h</filename>, <filename>ddi.h</filename> i the
        <filename>sunddi.h</filename>. Funkcja <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera dwa arumenty. Pierwszy argument to stała
        wskazująca powagę błędu. Wiadomości pisane przez ten sterownik nie są
        informacjami o błędzie, ale zwykłymi informacjami testowymi, więc
        wartość tej stałej będzie wynosić <literal>CE_NOTE</literal>. Drugi
        argument funkcji <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> to łańcuch znakowy z wiadomością do
        zapisania.</para>

        <para>Poniżej zamieszczono kod z definicją funkcji <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> do włączenia do pliku <filename>dummy.c</filename>.
        Struktura <literal>ml</literal> to struktura <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> opisana w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epffy">Defining the Module
        Linkage Structures</olink>.</para>

        <programlisting>int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}</programlisting>
      </sect3>

      <sect3 xml:id="epmnm">
        <title>Defining the Module Information Entry Point</title>

        <indexterm xml:id="indexterm-189">
          <primary>entry points</primary>

          <secondary><function>_info </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-190">
          <primary><function>_info </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-191">
          <primary><function>mod_info </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-192">
          <primary>kernel functions</primary>

          <secondary><function>mod_info </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-193">
          <primary><literal>modinfo</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-194">
          <primary>driver structures</primary>

          <secondary><literal>modinfo</literal></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="u-info-9e"> <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> i pobiera
        argument będący wskaźnikiem do struktury <literal>modinfo</literal>.
        Funkcja <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi zwrócić wartość zwracaną przez funkcję <olink
        remap="external" targetdoc="819-2256" targetptr="mod-info-9f">
        <citerefentry>
            <refentrytitle>mod_info</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>mod_info</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera dwa argumenty. Pierwszy argument to
        struktura <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry>. Więcej informacji w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epffy">Defining the Module
        Linkage Structures</olink>. Drugi argument to ten sam wskażnik do
        struktury <literal>modinfo</literal>, który został przekazany funkcji
        <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Funkcja <citerefentry>
            <refentrytitle>mod_info</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwraca informację o module lub zwraca zero, jeśli
        wystąpił błąd.</para>

        <para>Do zapisania infgormacji w logach systemowych użyta zostanie
        funkcja <olink remap="external" targetdoc="819-2256"
        targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> w taki sam sposób jak w funkcji
        <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod funkcji <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> powinien zostać włączony do pliku<filename>
        dummy.c</filename>. Struktura <literal>ml</literal> opisana jest w
        <olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="epffy">Defining the Module Linkage Structures</olink>.
        Argument <literal>modinfop</literal> jest wskaźniekiem do struktury
        używanej przez system do przekazywania informacji o modułach.</para>

        <programlisting>int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}</programlisting>
      </sect3>

      <sect3 xml:id="epmnn">
        <title>Defining the Module Unload Entry Point</title>

        <indexterm xml:id="indexterm-195">
          <primary>entry points</primary>

          <secondary><function>_fini </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-196">
          <primary><function>_fini </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-197">
          <primary><function>mod_remove </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-198">
          <primary>kernel functions</primary>

          <secondary><function>mod_remove </function></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="u-fini-9e"> <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> i nie
        pobiera argumentów. Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wywołać funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="mod-remove-9f"> <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> i zwrócić wartość powodzenia lub błędu
        zwracaną przez <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>.</para>

        <para>Jeśli <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> się uda funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wykonać pracę odwrotną do tej wykonanej przez
        funkcję <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wywołać <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>, ponieważ <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wywołała <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>. Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi uwolnić wszystko, co zostało zalokowane,
        zamknąć wszystko, co zostało otwarte i zniszczyć wszystko, co zostało
        stworzone przez funkcję <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> może być wywołana w dowolnym momencie, gdy moduł
        jest załadowany. W normalnym działaniu funkcja <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> często zwraca błąd. To jest normalne, ponieważ jądro
        pozwala modułowi na ustalenie, czy moduł może być wyładowany, czy
        też nie. Jeśli wywołanie <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwróciło powodzenie, moduł uznaje, że urządzenie
        zostało odłączone i moduł można wyładować. Jeśli <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> nie powiedzie się, moduł uznaje, że urządzenie nie
        zostało odłączone i modułu nie można wyładować.</para>

        <itemizedlist>
          <para>Po wywołaniu <citerefentry>
              <refentrytitle>mod_remove</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> wykonywane są następujące akcje:</para>

          <listitem>
            <itemizedlist>
              <para>Jądro sprawdza, czy sterownik jest zajęty. Sterownik jest
              zajęty, jeśli spełniony jest jeden z poniższych warunków:</para>

              <listitem>
                <para>Node zarządzany przez sterownik jest otwarty.</para>
              </listitem>

              <listitem>
                <para><indexterm xml:id="indexterm-199">
                    <primary>linking</primary>
                  </indexterm> <indexterm xml:id="indexterm-200">
                    <primary>commands</primary>

                    <secondary><command>ld</command></secondary>
                  </indexterm> <indexterm xml:id="indexterm-201">
                    <primary><command>ld</command> command</primary>
                  </indexterm>Inny moduł, który zależy od sterownika jet
                otwarty. Moduł zależy od sterownika jeśli był konsolidowany z
                opcją <option>N</option> ze sterownikiem jako argumentem dla
                opcji <option>N</option>. Więcej informacji w <olink
                remap="external" targetdoc="819-2239" targetptr="ld-1">
                <citerefentry>
                    <refentrytitle>ld</refentrytitle>

                    <manvolnum>1</manvolnum>
                  </citerefentry> </olink>.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Jeśli sterownik jest zajęty, <citerefentry>
                <refentrytitle>mod_remove</refentrytitle>

                <manvolnum>9F</manvolnum>
              </citerefentry> zwraca błąd i <citerefentry>
                <refentrytitle>_fini</refentrytitle>

                <manvolnum>9E</manvolnum>
              </citerefentry> zwraca błąd.</para>
          </listitem>

          <listitem>
            <para><indexterm xml:id="indexterm-202">
                <primary>entry points</primary>

                <secondary><function>detach </function></secondary>
              </indexterm> <indexterm xml:id="indexterm-203">
                <primary><function>detach </function> entry point</primary>
              </indexterm>Jeśli sterownik nie jest zajęty, jądro wywołuje
            punkt wejścia <olink remap="external" targetdoc="819-2255"
            targetptr="detach-9e"> <citerefentry>
                <refentrytitle>detach</refentrytitle>

                <manvolnum>9E</manvolnum>
              </citerefentry> </olink>.</para>

            <itemizedlist>
              <listitem>
                <para>Jeśli <citerefentry>
                    <refentrytitle>detach</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> się nie powiedzie, to <citerefentry>
                    <refentrytitle>mod_remove</refentrytitle>

                    <manvolnum>9F</manvolnum>
                  </citerefentry> zwraca błąd i <citerefentry>
                    <refentrytitle>_fini</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> zwraca błąd.</para>
              </listitem>

              <listitem>
                <para><citerefentry>
                    <refentrytitle>Jeśli detach</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> się powiedzie, to <citerefentry>
                    <refentrytitle>mod_remove</refentrytitle>

                    <manvolnum>9F</manvolnum>
                  </citerefentry> się powiedzie i <citerefentry>
                    <refentrytitle>_fini</refentrytitle>

                    <manvolnum>9E</manvolnum>
                  </citerefentry> kontynuuje sprzątanie.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>Funkcja <citerefentry>
            <refentrytitle>mod_remove</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera strukturę <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> jako argument. Więcej informacji w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="epffy">Defining
        the Module Linkage Structures</olink>.</para>

        <para>Podobnie jak w punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, do zapisania informacji posłuży funkcja <olink
        remap="external" targetdoc="819-2256" targetptr="cmn-err-9f">
        <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <para>Poniższy kod funkcji <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> należy włączyć do pliku
        <filename>dummy.c</filename>. Struktura <literal>ml</literal> opisana
        jest w <olink remap="internal" targetdoc="chapter-2.xml"
        targetptr="epffy">Defining the Module Linkage
        Structures</olink>.</para>

        <programlisting>int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}</programlisting>
      </sect3>

      <sect3 xml:id="epmnl">
        <title>Including Loadable Module Configuration Header Files</title>

        <para>Funkcje <olink remap="external" targetdoc="819-2255"
        targetptr="u-init-9e"> <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink>, <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <olink remap="external" targetdoc="819-2256"
        targetptr="mod-install-9f"> <citerefentry>
            <refentrytitle>mod_install</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wymagają włączenia pliku nagłówkowego
        <literal>modctl.h</literal>. Funkcja <olink remap="external"
        targetdoc="819-2256" targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wymaga włączenia plików nagłówkowych
        <literal>cmn_err.h</literal>, <literal>ddi.h </literal>i
        <literal>sunddi.h</literal>.</para>

        <para>Poniższe pliki nagłówkowe są wymagane przez trzy funkcje
        konfiguracji modułu ładowalnego napisane w tym rozdziale. Poniższy kod
        należy włączyć na początku pliku <filename>dummy.c</filename>.</para>

        <programlisting>#include &lt;sys/modctl.h&gt;  /* używane przez _init, _info, _fini */
#include &lt;sys/cmn_err.h&gt; /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/ddi.h&gt;     /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/sunddi.h&gt;  /* używane przez wszystkie punkty wejścia w tym sterowniku */</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="epmnh">
      <title>Writing the Autoconfiguration Entry Points</title>

      <indexterm xml:id="indexterm-204">
        <primary>entry points</primary>

        <secondary>autoconfiguration</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-205">
        <primary>entry points</primary>

        <secondary><function>attach </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-206">
        <primary><function>attach </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-207">
        <primary><function>ddi_create_minor_node </function> kernel
        function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-208">
        <primary>kernel functions</primary>

        <secondary><function>ddi_create_minor_node </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-209">
        <primary>entry points</primary>

        <secondary><function>detach </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-210">
        <primary><function>detach </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-211">
        <primary><function>ddi_remove_minor_node </function> kernel
        function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-212">
        <primary>kernel functions</primary>

        <secondary><function>ddi_remove_minor_node </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-213">
        <primary>entry points</primary>

        <secondary><function>getinfo </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-214">
        <primary><function>getinfo </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-215">
        <primary>entry points</primary>

        <secondary><function>prop_op </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-216">
        <primary><function>prop_op </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-217">
        <primary><function>ddi_prop_op </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-218">
        <primary>kernel functions</primary>

        <secondary><function>ddi_prop_op </function></secondary>
      </indexterm>

      <itemizedlist>
        <para>Każdy sterownik znakowy musi zdefiniować przynajmniej poniższe
        punkty wejścia autokonfiguracji. Jądro wywołuje te funkcje kiedy
        sterownik jest ładowany.</para>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="attach-9e"> <citerefentry>
              <refentrytitle>attach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> musi wywołać <olink remap="external"
          targetdoc="819-2256" targetptr="ddi-create-minor-node-9f">
          <citerefentry>
              <refentrytitle>ddi_create_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink>. Funkcja <citerefentry>
              <refentrytitle>ddi_create_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> dostarcza informacji potrzebnych systemowi do
          stworzenia plików urządzenia.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="detach-9e"> <citerefentry>
              <refentrytitle>detach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> musi wywołać <olink remap="external"
          targetdoc="819-2256" targetptr="ddi-remove-minor-node-9f">
          <citerefentry>
              <refentrytitle>ddi_remove_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink> do uwolnienia wszystkiego, co zostało
          zaalokowane przez <citerefentry>
              <refentrytitle>ddi_create_minor_node</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>. Funkcja <citerefentry>
              <refentrytitle>detach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wykonać pracę odwrotną do pracy wykonanej
          przez <citerefentry>
              <refentrytitle>attach</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="getinfo-9e"> <citerefentry>
              <refentrytitle>getinfo</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zwraca informacje o wskazanym sterowniku
          przez jeden ze swoich argumentów.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="prop-op-9e"> <citerefentry>
              <refentrytitle>prop_op</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zwraca przez wskaźnik informacje o
          wskazanym sterowniku. Zamiast pisać własny punkt wywołania
          <citerefentry>
              <refentrytitle>prop_op</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> można użyć <olink remap="external"
          targetdoc="819-2256" targetptr="ddi-prop-op-9f"> <citerefentry>
              <refentrytitle>ddi_prop_op</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry> </olink>. Punktu wejścia <citerefentry>
              <refentrytitle>prop_op</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> można użyć do zmodyfikowania zachowania funkcji
          <citerefentry>
              <refentrytitle>ddi_prop_op</refentrytitle>

              <manvolnum>9F</manvolnum>
            </citerefentry>.</para>
        </listitem>
      </itemizedlist>

      <para>W tej sekcji dodano następujący kod:</para>

      <programlisting>/* Punkty wejścia autokonfiguracji sterownika */
static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}</programlisting>

      <sect3 xml:id="epmqa">
        <title>Declaring the Autoconfiguration Entry Points</title>

        <para>Punkty wejścia <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> muszą mieć nazwy unikalne dla danego sterownika.
        Należy wybrać prefiks dla każdej funkcji punktu wejścia.</para>

        <note>
          <para><indexterm xml:id="indexterm-219">
              <primary>prefixes</primary>
            </indexterm> <indexterm xml:id="indexterm-220">
              <primary>devices</primary>

              <secondary>prefixes</secondary>
            </indexterm>Konwencja nakazuje, aby prefiks używany dla funkcji i
          danych unikalnych dla sterownika jest albo nazwą sterownika, albo
          jej skrótem. Prefiksu należy używać w całym sterowniku. Ułatwia to
          poszukiwanie błędów.</para>
        </note>

        <para>W przykładzie omawianym w tym rozdziale jako prefiksu dla każdej
        funkcji i danej unikalnej dla modułu używa się
        <literal>dummy_</literal>.</para>

        <para>Poniższe deklaracje to punkty wejścia autokonfiguracji wymagane
        w pliku <filename>dummy.c</filename>. Należy zauważyć, że każda z tych
        funkcji zadeklarowana jest jako <literal>static</literal>.</para>

        <programlisting>static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);</programlisting>
      </sect3>

      <sect3 xml:id="epmqc">
        <title>Defining the Device Attach Entry Point</title>

        <indexterm xml:id="indexterm-221">
          <primary>entry points</primary>

          <secondary><function>attach </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-222">
          <primary><function>attach </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-223">
          <primary><function>ddi_soft_state </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-224">
          <primary>kernel functions</primary>

          <secondary><function>ddi_soft_state </function></secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="attach-9e"> <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal> równy
        <literal>DDI_SUCCESS</literal> albo <literal>DDI_FAILURE</literal>. Te
        dwie stałe są zdefiniowane w <filename>sunddi.h</filename>. Wszystkie
        funkcje punktów wejścia autokonfiguracji, za wyjątkiem <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, zwracają <literal>DDI_SUCCESS</literal> lub
        <literal>DDI_FAILURE</literal>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> pobiera dwa argumenty. Pierwszy to wstaźnik do
        struktury <literal>dev_info</literal> sterownika. Wszystkie funkcje
        punktów wejścia autokonfiguracji pobierają <literal>dev_info</literal>
        jako argument. Drugi argument to stała wskazująca typ podłączenia.
        Wartość to <literal>DDI_ATTACH</literal> lub
        <literal>DDI_RESUME</literal>. Każda funkcja <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> mudi zdefiniować zachowanie przynajmniej dla
        <literal>DDI_ATTACH</literal>.</para>

        <para>Kod <literal>DDI_ATTACH</literal>musi inicjalizować instancę
        urządzenia. W rzeczywistym sterowniku definiuje się i zarządza wieloma
        instancjami sterownika przy użyciu struktury stanu i funkcji <olink
        remap="external" targetdoc="819-2256" targetptr="ddi-soft-state-9f">
        <citerefentry>
            <refentrytitle>ddi_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Każda instancja ma swoją kopię struktury
        stanu zawierającą dane lokalne dla tej instancji. Jedną z takich
        danych lokalnych dla instancji jest jest wskaźnik instancji
        urządzenia. Każda instancja sterownika reprezentowana jest osobnym
        plikiem urządzenia w katalogu <filename>/devices</filename>. Na każdy
        plik wskazuje inny wskaźnik instancji urządzenia. Więcej informacji o
        funkcjach <citerefentry>
            <refentrytitle>ddi_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> w <olink remap="external" targetdoc="chapter-3.xml"
        targetptr="fcowf">Managing Device State</olink>. Więcej informacji o
        instancjach w <olink remap="external" targetdoc="chapter-1.xml"
        targetptr="fgomr">Devices as Files</olink>.</para>

        <para>Opisywany sterownik <literal>dummy</literal> pozwala na tylko
        jedną instancję. Z tego względu sterownik nie zawiera struktury stanu,
        ale nadal musi zadeklarować wskaźnik na instancję urządzenia i
        zainicjować wskaźnik w funkcji <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Poniższy kod wprowadzony blisko początku pliku
        <filename>dummy.c</filename> zadeklaruje wskaźnik na instancję
        sterownika:</para>

        <programlisting>dev_info_t *dummy_dip;  /* śledzenie jednej instancji */</programlisting>

        <para>Poniższy kod to funkcja <function>dummy_attach</function> z
        pliku <filename>dummy.c</filename>. Nazwę funkcji można skopiować
        bezpośrednio z deklaracji wprowadzonej w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epmqa">Declaring the
        Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</programlisting>

        <para><indexterm xml:id="indexterm-225">
            <primary><function>ddi_get_instance </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-226">
            <primary>kernel functions</primary>

            <secondary><function>ddi_get_instance </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-227">
            <primary><function>ddi_create_minor_node </function> kernel
            function</primary>
          </indexterm> <indexterm xml:id="indexterm-228">
            <primary>kernel functions</primary>

            <secondary><function>ddi_create_minor_node </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-229">
            <primary>device instance pointer (dip)</primary>
          </indexterm> <indexterm xml:id="indexterm-230">
            <primary><literal>dev_info</literal> device structure</primary>
          </indexterm> <indexterm xml:id="indexterm-231">
            <primary>device structures</primary>

            <secondary><literal>dev_info</literal></secondary>
          </indexterm> <indexterm xml:id="indexterm-232">
            <primary>devices</primary>

            <secondary>numbers</secondary>
          </indexterm> <indexterm xml:id="indexterm-233">
            <primary>minor number</primary>
          </indexterm> <indexterm xml:id="indexterm-234">
            <primary>instance number</primary>
          </indexterm> <indexterm xml:id="indexterm-235">
            <primary>devices</primary>

            <secondary>instances</secondary>
          </indexterm>Najpierw należy użyć <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do zapisania wiadomości do logu systemu, jak w
        punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Potem trzeba zdefiniować zachowanie
        <literal>DDI_ATTACH</literal>. W kodzie <literal>DDI_ATTACH</literal>
        najpierw przypisany zostanie wskaźnik instancji urządzenia
        przekazywany jako argument <function>dummy_attach </function>do
        zmiennej the <literal>dummy_dip</literal> zadeklarowanej wyżej.
        Wartość wskaźńika trzeba zapisać w zmiennej globalnej aby móc
        wykorzystać go do uzyskania informacji o instancji sterownika z
        <function>dummy_getinfo </function>i odłączyć go za pomocą
        <function>dummy_detach</function>. W funkcji
        <function>dummy_attach</function> wskaźnik instacji urządzenia jest
        używany przez funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-get-instance-9f"> <citerefentry>
            <refentrytitle>ddi_get_instance</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do uzyskania numeru instancji. Wskaźnik
        instancji i numer instancji są używane przez <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-create-minor-node-9f">
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> do stworzenia nowego node'u
        urządzenia.</para>

        <para>Rzeczywisty sterownik prawdopodobnie użyłby funkcji
        <citerefentry>
            <refentrytitle>ddi_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do stworzenia i zarządzania nodem urządzenia.
        Opisywany prosty sterownik <literal>dummy</literal> używa funkcji
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do stworzenia node'u urządzenia. Funkcja
        <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera sześć argumentów. Pierwszy argument to
        wskaźnik instacji urządzenia wskazujący na strukturę
        <literal>dev_info</literal> danego urządzenia. Drugi argument to nazwa
        mniejszego node'u. Trzeci argument to <literal>S_IFCHR</literal> jeśli
        urządzenie jest znakowe, lub <literal>S_IFBLK</literal> jeśli
        urządzenie jest blokowe. Sterownik <literal>dummy</literal> to
        urządzenie znakowe.</para>

        <para>Czwarty argument funkcji <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> to młodszy numer młodszego urządzenia nazywany także
        numerem instancji. Funkcja <citerefentry>
            <refentrytitle>ddi_get_instance</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwraca ten numer instancji. Piąty argument to rodzaj
        node'u. Strona man dla funkcji <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zawiera listę możliwych typów node'ów. Node
        <literal>DDI_PSEUDO</literal> jest pseudourządzeniem. Szósty argument
        wskazuje, czy jest to urządzenie-klon. W przypadku przykładowego
        urządzenia tak nie jest, należy więc przekazać 0.</para>

        <para>Jeśli wywołanie <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zakończy się błędem, zapisana zostanie wiadomość do
        logów systemowych i zwrócona zostanie wartość
        <literal>DDI_FAILURE</literal>. Jeśli wywołanie <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zakończy się sukcesem, funkcja zwróci
        <literal>DDI_SUCCESS</literal>. Jeśli
        <function>dummy_attach</function> otrzyma inne <literal>cmd</literal>
        niż <literal>DDI_ATTACH</literal>, należy zwrócić
        <literal>DDI_FAILURE</literal>.</para>
      </sect3>

      <sect3 xml:id="epmqi">
        <title>Defining the Device Detach Entry Point</title>

        <indexterm xml:id="indexterm-236">
          <primary>entry points</primary>

          <secondary><function>detach </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-237">
          <primary><function>detach </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-238">
          <primary><function>ddi_remove_minor_node </function> kernel
          function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-239">
          <primary>kernel functions</primary>

          <secondary><function>ddi_remove_minor_node </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-240">
          <primary>device instance pointer (dip)</primary>
        </indexterm>

        <indexterm xml:id="indexterm-241">
          <primary><literal>dev_info</literal> device structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-242">
          <primary>device structures</primary>

          <secondary><literal>dev_info</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-243">
          <primary>instance number</primary>
        </indexterm>

        <indexterm xml:id="indexterm-244">
          <primary>devices</primary>

          <secondary>instances</secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="detach-9e"> <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> pobiera dwa arumenty. Pierwszy argument
        jest wskaźnikiem na struktury <literal>dev_info</literal> tego
        sterownika. Drugi argument jest stałą wskazująca rodzaj odłączenia.
        Argumentem może być albo <literal>DDI_DETACH</literal>, alboor
        <literal>DDI_SUSPEND</literal>. Każda funkcja <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi zdefiniować zachowanie przynajmniej dla
        <literal>DDI_DETACH</literal>.</para>

        <para>Kod <literal>DDI_DETACH</literal> musi wykonać pracę odwrotną do
        tej wykonanej przez <literal>DDI_ATTACH</literal>. W kodzie
        <literal>DDI_ATTACH</literal> funkcja <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zapisała adres nowej struktury
        <literal>dev_info</literal> i wywołała funkcję <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do stworzenia nowego node'u. W kodzie
        <literal>DDI_DETACH</literal> w funkcji <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> należy zresetować zmienną wskazującą na strukturę
        <literal>dev_info</literal> tego node'u. Należy także wywołać <olink
        remap="external" targetdoc="819-2256"
        targetptr="ddi-remove-minor-node-9f"> <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> aby usunąć node. Funkcja <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi uwolnić wszystko, co było zaalokowane, zamknąć
        wszystko, co było otwarte i zniszczyć wszystko, co było utworzone w
        funkcji <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod to funkcja <function>dummy_detach</function>, który
        należy dołączyć do pliku <filename>dummy.c</filename>. Nazwę funkcji
        można skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="epmqa">Declaring
        the Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</programlisting>

        <para>Użyto <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do zapisania wiadomości w logu systemowym, jak w
        punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Następnie zdefiniowano zachowanie
        <literal>DDI_DETACH</literal>. Wewnątrz kodu
        <literal>DDI_DETACH</literal> zresetowano zmienną<literal>
        dummy_dip</literal> ustawioną wcześniej w
        <function>dummy_attach</function>. Nie można zresetować tego wskaźnika
        instancji zanim usunie się wszystkie instancje urządzenia. Sterownik
        <literal>dummy</literal> obsługuje tylko jedną instancję.</para>

        <para>Następnie funkcja <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> usuwa node urządzenia. Funkcja <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobiera dwa argumenty. Pierwszy argument jest
        wskaźnikiem instancji urządzenia wskazującym strukturę
        <literal>dev_info</literal> tego urządzenia. Drugi argument to nazwa
        młodszego node'u do usunięcia. Jeśli wartość młodszego node'u równa
        jest <literal>NULL</literal>, funkcja <citerefentry>
            <refentrytitle>ddi_remove_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> usunie wszystkie instancje urządzenia. Kod
        <literal>DDI_DETACH</literal> tego sterownika usuwa zawsze wszystkie
        instancje, dlatego <literal>dummy</literal> obsługuje tylko jedną
        instancję.</para>

        <para>Jeśli wartość argumentu <literal>cmd</literal> funkcji
        <function>dummy_detach</function> równy jest
        <literal>DDI_DETACH</literal>, usuwa się wszystkie instancje
        urządzenia i zwraca <literal>DDI_SUCCESS</literal>. Jeśli funkcja
        <function>dummy_detach</function> dostanie inny argument
        <literal>cmd</literal>, zwraca <literal>DDI_FAILURE</literal>.</para>
      </sect3>

      <sect3 xml:id="epmql">
        <title>Defining the Get Driver Information Entry Point</title>

        <indexterm xml:id="indexterm-245">
          <primary>entry points</primary>

          <secondary><function>getinfo </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-246">
          <primary><function>getinfo </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-247">
          <primary>device instance pointer (dip)</primary>
        </indexterm>

        <indexterm xml:id="indexterm-248">
          <primary><literal>dev_info</literal> device structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-249">
          <primary>device structures</primary>

          <secondary><literal>dev_info</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-250">
          <primary>instance number</primary>
        </indexterm>

        <indexterm xml:id="indexterm-251">
          <primary>devices</primary>

          <secondary>instances</secondary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="getinfo-9e"> <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> pobiera wskaźnik do numeru urządzenia i
        zwraca wskaźnik do struktury informacji urządzenia lub numer instancji
        urządzenia. Wartość zwracana przez tę funkcję jest równa stałej
        <literal>DDI_SUCCESS</literal> lub <literal>DDI_FAILURE</literal>.
        Wskaźnik lub numer instancji żądany od funkcji <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zwracany jest przez argument wskaźnikowy.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> pobiera cztery argumenty. Pierwszy to wskaźnik do
        struktury <literal>dev_info</literal> dla danego sterownika. Argument
        ten jest przestarzały (ang. obsolete) i nieużywany przez
        funkcję.</para>

        <para>Drugi argument to stała wskazująca, jaki rodzaj informacji
        żądany jest od <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Wartość tego argumentu to albo
        <literal>DDI_INFO_DEVT2DEVINFO</literal>, albo
        <literal>DDI_INFO_DEVT2INSTANCE</literal>. Trzeci argument to wskaźnik
        do numeru urządzenia. Czwarty argument jest wskaźnikiem do miejsca, w
        którym funkcja <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi zapisać żądane dane. Dane zapisane w tym
        miejscu zależą od wartości drugiego argumentu przekazanego
        funkcji.</para>

        <para>Poniższa tabela opisuje związek międxzy drugim i czwartym
        argumentem funkcji <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <table frame="topbot" xml:id="eqbiy">
          <title>Get Driver Information Entry Point Arguments</title>

          <tgroup cols="3" colsep="0" rowsep="0">
            <colspec colwidth="33*" />

            <colspec colwidth="33*" />

            <colspec colwidth="33*" />

            <thead>
              <row rowsep="1">
                <entry><para> <replaceable>cmd</replaceable> </para></entry>

                <entry><para> <replaceable>arg</replaceable> </para></entry>

                <entry><para> <replaceable>resultp</replaceable>
                </para></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><para> <literal>DDI_INFO_DEVT2DEVINFO</literal>
                </para></entry>

                <entry><para>Numer urządzenia</para></entry>

                <entry><para>Wkaźnik do struktury informacji
                urządzenia</para></entry>
              </row>

              <row>
                <entry><para> <literal>DDI_INFO_DEVT2INSTANCE</literal>
                </para></entry>

                <entry><para>Numer urządzenia</para></entry>

                <entry><para>Numer instancji urządzenia</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Poniższy kod to funkcja <function>dummy_getinfo</function> do
        włączenia do kodu pliku <filename>dummy.c</filename>. Nazwę funkcji
        można skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="epmqa">Declaring
        the Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}</programlisting>

        <para>Użyto <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do zapisania wiadomości w logu systemowym, jak w
        punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Później zdefiniowano zachowanie
        <literal>DDI_INFO_DEVT2DEVINFO</literal>. Prawdziwy sterownik użyłby
        <replaceable>arg</replaceable> do uzyskania numeru instancji tego
        node'u urządzenia, a później wywołałby <citerefentry>
            <refentrytitle>ddi_get_soft_state</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> i zwrócił wskaźnik do struktury informacji z tej
        struktury. Sterownik <literal>dummy</literal> obsługuje tylko
        jedną instancję urządzenia, dlatego w kodzie
        <literal>DDI_INFO_DEVT2DEVINFO</literal> funkcji
        <function>dummy_getinfo</function> po prostu zwracany jest jedyny
        wskaźnik do struktury informacji o urządzeniu, który zapisała funkcja
        <function>dummy_attach</function>.</para>

        <para>Następnie zdefiniowano zachowanie
        <literal>DDI_INFO_DEVT2INSTANCE</literal>. Kod
        <literal>DDI_INFO_DEVT2INSTANCE</literal> po prostu zwraca 0.
        Sterownik <literal>dummy</literal> obsługuje tylko jedeną instancję
        urządzenia, której numer równy jest 0.</para>
      </sect3>

      <sect3 xml:id="epmqj">
        <title>Defining the Report Driver Property Information Entry
        Point</title>

        <indexterm xml:id="indexterm-252">
          <primary>devices</primary>

          <secondary>properties</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-253">
          <primary>entry points</primary>

          <secondary><function>prop_op </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-254">
          <primary><function>prop_op </function> entry point</primary>
        </indexterm>

        <indexterm xml:id="indexterm-255">
          <primary><function>ddi_prop_op </function> kernel function</primary>
        </indexterm>

        <indexterm xml:id="indexterm-256">
          <primary>kernel functions</primary>

          <secondary><function>ddi_prop_op </function></secondary>
        </indexterm>

        <para>Punkt wejścia <olink remap="external" targetdoc="819-2255"
        targetptr="prop-op-9e"> <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> jest wymagany w każdym sterowniku. Jeśli
        sterownik nie musi dostosowywać zachowania punktu wejścia
        <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, może wykorzystać funkcję <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-prop-op-9f"> <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> jako punkt wejścia <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Sterowniki tworzące i zarządzające własnymi
        wląściwościami muszą dostosować działanie funkcji <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Sterownik <literal>dummy</literal> wywołuje w
        funkcji <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="cmn-err-9f"> <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> przed wywołaniem <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>.</para>

        <para>Punkt wejścia <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> oraz funkcja <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> wymagają włączenia pliku nagłówkowego
        <literal>types.h</literal>. Punkt wejścia <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> oraz funkcja <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> pobierają te same siedem argumentów. Argumenty te
        nie są omawiane, ponieważ <literal>dummy</literal> nie tworzy i nie
        zarządza swoimi właściwościami. Więcej o argumentach do tych funkcji
        na stronie man <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod <function>dummy_prop_op </function>należy włączyć
        do pliku <filename>dummy.c</filename>. Nazwę funkcji można skopiować
        bezpośrednio z deklaracji wprowadzonej w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="epmqa">Declaring the
        Autoconfiguration Entry Points</olink>.</para>

        <programlisting>static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}</programlisting>

        <para>Użyto <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> do zapisania wiadomości w logu systemowym, jak w
        punkcie wejścia <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, a następnie wywołano <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> z identycznymi argumentami jak funkcję
        <function>dummy_prop_op</function>.</para>
      </sect3>

      <sect3 xml:id="epmqe">
        <title>Including Autoconfiguration Header Files</title>

        <para>Wszystkie funkcje punktów wejścia autokonfiguracji i wszystkie
        funkcje punktów wejścia kontekstu użytkownika wymagają włączenia
        plików nagłówkowych <filename>ddi.h</filename> i
        <filename>sunddi.h</filename>, które zostały już włączone wcześniej
        zer względu na funkcję <citerefentry>
            <refentrytitle>cmn_err</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>.</para>

        <para>Funkcja <olink remap="external" targetdoc="819-2256"
        targetptr="ddi-create-minor-node-9f"> <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wymaga pliku nagłówkowego
        <filename>stat.h</filename>. Funkcja <function>dummy_attach
        </function> wywołuje <citerefentry>
            <refentrytitle>ddi_create_minor_node</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry>. Funkcje <olink remap="external"
        targetdoc="819-2255" targetptr="prop-op-9e"> <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2256" targetptr="ddi-prop-op-9f"> <citerefentry>
            <refentrytitle>ddi_prop_op</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wymagają pliku nagłówkowego
        <filename>types.h</filename>.</para>

        <para>Poniżej zamieszczono listę plików nagłówkowych, które powinny
        być wlączone do pliku <filename>dummy.c</filename> ze względu na
        funkcje autokonfiguracji napisane w tym podrozdziale oraz trzy funkcje
        konfiguracji ładowalnego modułu z poprzedniego podrozdziału.</para>

        <programlisting>#include &lt;sys/modctl.h&gt;  /* używane przez _init, _info, _fini */
#include &lt;sys/types.h&gt;   /* używane przez prop_op, ddi_prop_op */
#include &lt;sys/stat.h&gt;    /* definiuje S_IFCHR używane przez ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/ddi.h&gt;     /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* także używane przez ddi_get_instance, ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* także używane przez ddi_create_minor_node, */
                         /* ddi_get_instance, ddi_prop_op */</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="epmni">
      <title>Writing the User Context Entry Points</title>

      <indexterm xml:id="indexterm-257">
        <primary>entry points</primary>

        <secondary>user context</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-258">
        <primary>entry points</primary>

        <secondary><function>open </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-259">
        <primary><function>open </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-260">
        <primary><function>nulldev </function> kernel function</primary>
      </indexterm>

      <indexterm xml:id="indexterm-261">
        <primary>kernel functions</primary>

        <secondary><function>nulldev </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-262">
        <primary>entry points</primary>

        <secondary><function>close </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-263">
        <primary><function>close </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-264">
        <primary>entry points</primary>

        <secondary><function>read </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-265">
        <primary><function>read </function> entry point</primary>
      </indexterm>

      <indexterm xml:id="indexterm-266">
        <primary>entry points</primary>

        <secondary><function>write </function></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-267">
        <primary><function>write </function> entry point</primary>
      </indexterm>

      <para>Punkty wejścia kontelstu użytkownika ściśle odpowiadają wywołaniom
      systemowym. Kiedy wywołanie systemowe otwiera plik urządzenia,
      wywoływana jest funkcja <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> w sterowniku dla tego urządzenia.</para>

      <para>Wszystkie sterowniki znakowe i blokowe muszą zdefiniować punkt
      wejścia <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> dla kontekstu użytkownika, jednakże funkcja
      <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> może być <olink remap="external" targetdoc="819-2256"
      targetptr="nulldev-9f"> <citerefentry>
          <refentrytitle>nulldev</refentrytitle>

          <manvolnum>9F</manvolnum>
        </citerefentry> </olink>. Funkcje kontekstu użytkownika <citerefentry>
          <refentrytitle>close</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>read</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>write</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> są opcjonalne.</para>

      <itemizedlist>
        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="open-9e"> <citerefentry>
              <refentrytitle>open</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> otwiera dostęp do urządzenia.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="close-9e"> <citerefentry>
              <refentrytitle>close</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zamyka dostęp do urządzenia. Funkcja
          <citerefentry>
              <refentrytitle>close</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> musi wykonać pracę odwrotną do wykonanej przez
          <citerefentry>
              <refentrytitle>open</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry>.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="read-9e"> <citerefentry>
              <refentrytitle>read</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> czyta dane z node'u urządzenia.</para>
        </listitem>

        <listitem>
          <para>Funkcja <olink remap="external" targetdoc="819-2255"
          targetptr="write-9e"> <citerefentry>
              <refentrytitle>write</refentrytitle>

              <manvolnum>9E</manvolnum>
            </citerefentry> </olink> zapisuje dane do node'u
          urządzenia.</para>
        </listitem>
      </itemizedlist>

      <para>W tym podrozdziale napisano poniższy kod:</para>

      <programlisting>/* Punkty wejścia kontekstu użytkownika */
static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}

static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}

static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}

static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</programlisting>

      <sect3 xml:id="eqbim">
        <title>Declaring the User Context Entry Points</title>

        <para>Funkcje punktów wejścia kontekstu użytkownika muszą mieć nazwy
        unikalne dla danego sterownika. W tym celu użytko dla każdego punktu
        wejścia kontekstu użytkownika takiego samego prefiksu jak przy
        punktach wejścia autokonfiguracji. Poniższe deklaracje punktów wejścia
        powinny znaleźć się w pliku <filename>dummy.c</filename>:</para>

        <programlisting>static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);
static int dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred);
static int dummy_close(dev_t dev, int flag, int otyp, cred_t *cred);
static int dummy_read(dev_t dev, struct uio *uiop, cred_t *credp);
static int dummy_write(dev_t dev, struct uio *uiop, cred_t *credp);</programlisting>
      </sect3>

      <sect3 xml:id="eqbii">
        <title>Defining the Open Device Entry Point</title>

        <indexterm xml:id="indexterm-268">
          <primary>entry points</primary>

          <secondary><function>open </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-269">
          <primary><function>open </function> entry point</primary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="open-9e"> <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca <literal>int</literal>. Funkcja
        <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> powinna zwrócić albo <literal>DDI_SUCCESS</literal>,
        albo odpowiedni numer błędu.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> Pobiera dwa argumenty. Sterownik
        <literal>dummy</literal> jest tak prosty, że funkcja
        <function>dummy_open</function> nie używa żadnego z argumentów funkcji
        <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Przykłady w <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> demonstrują więcej szczegółów
        funkcji <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod dla funkcji <function>dummy_open</function> należy
        włączyć do pliku <filename>dummy.c</filename>. Nazwę funkcji można
        skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="eqbim">Declaring
        the User Context Entry Points</olink>. Do logu systemowego zapisywana
        jest wiadomość i zwracany jest symbol sukcesu.</para>

        <programlisting>static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbil">
        <title>Defining the Close Device Entry Point</title>

        <indexterm xml:id="indexterm-270">
          <primary>entry points</primary>

          <secondary><function>close </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-271">
          <primary><function>close </function> entry point</primary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="close-9e"> <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal>. Funkcja
        <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> powinna zwracać <literal>DDI_SUCCESS</literal> lub
        właściwy numer błędu.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> pobiera cztery argumenty. Ten sterownik
        <literal>dummy</literal> jest tak prosty, że funkcja
        <function>dummy_close </function>nie używa żadnego z argumentów
        funkcji <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Przykłady w <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> demonstrują więcej szczegółów
        funkcji <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> musi wykonać pracę odwrotną do tej wykonanej przez
        funkcję <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Musi uwolnić wszystie zaalokowane zasoby, zamknąć
        wszystko co było otwarte i zniszczyć wszystko co było utworzone w
        funkcji <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. W sterowniku <literal>dummy</literal> funkcja
        <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> jest tak prosta, że nie w kodzie funkcji
        <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> nie trzeba nic wykonywać.</para>

        <para>Poniższy kod funkcji <function>dummy_close </function>należy
        włączyć do pliku <filename>dummy.c</filename>. Nazwę funkcji można
        skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="eqbim">Declaring
        the User Context Entry Points</olink>. Do logu systemowego zapisywana
        jest wiadomość i zwracany jest symbol sukcesu.</para>

        <programlisting>static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbjc">
        <title>Defining the Read Device Entry Point</title>

        <indexterm xml:id="indexterm-272">
          <primary>entry points</primary>

          <secondary><function>read </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-273">
          <primary><function>read </function> entry point</primary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="read-9e"> <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal>. Funkcja
        <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> powinna zwrócić <literal>DDI_SUCCESS</literal> albo
        właściwy numer błędu.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> pobiera trzy argumenty. Sterownik
        <literal>dummy</literal> jest tak prosty, że funkcja
        <function>dummy_read </function>nie używa żadnego z argumentów funkcji
        <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Przykłady w <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> demonstrują więcej szczegółów
        funkcji <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod funkcji <function>dummy_read </function>należy
        włączyć do pliku <filename>dummy.c</filename>. Nazwę funkcji można
        skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="eqbim">Declaring
        the User Context Entry Points</olink>. Do logu systemowego zapisywana
        jest wiadomość i zwracany jest symbol sukcesu.</para>

        <programlisting>static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbjb">
        <title>Defining the Write Device Entry Point</title>

        <indexterm xml:id="indexterm-274">
          <primary>entry points</primary>

          <secondary><function>write </function></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-275">
          <primary><function>write </function> entry point</primary>
        </indexterm>

        <para>Funkcja <olink remap="external" targetdoc="819-2255"
        targetptr="write-9e"> <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> </olink> zwraca typ <literal>int</literal>. Funkcja
        <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> zwraca <literal>DDI_SUCCESS</literal> albo właściwy
        numer błędu.</para>

        <para>Funkcja <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> pobiera trzy argumenty. Sterownik
        <literal>dummy</literal> jest tak prosty, że funkcja
        <function>dummy_write </function>nie używa żadnego z argumentów
        funkcji <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>. Przykłady w <olink remap="external"
        targetdoc="chapter-3.xml" targetptr="faatl">Chapter 3, Reading and
        Writing Data in Kernel Memory</olink> demonstrują więcej szczegółów
        funkcji <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>.</para>

        <para>Poniższy kod funkcji<function>dummy_write </function>należy
        włączyć do pliku <filename>dummy.c</filename>. Nazwę funkcji można
        skopiować bezpośrednio z deklaracji wprowadzonej w <olink
        remap="internal" targetdoc="chapter-2.xml" targetptr="eqbim">Declaring
        the User Context Entry Points</olink>. Do logu systemowego zapisywana
        jest wiadomość i zwracany jest symbol sukcesu.</para>

        <programlisting>static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</programlisting>
      </sect3>

      <sect3 xml:id="eqbit">
        <title>Including User Context Header Files</title>

        <para>Funkcje punktów wejścia kontekstu użytkownika wymagają włączenia
        kilku plików nagłówkowych. Pliki <filename>types.h</filename>, the
        <filename>ddi.h</filename> i <filename>sunddi.h</filename> zostały
        włączone wcześniej. Do listy należy dopisać
        <filename>file.h</filename>, <filename>errno.h</filename>,
        <filename>open.h</filename>, <filename>cred.h</filename> i
        <filename>uio.h</filename>.</para>

        <para>Poniżej wydrukowana jest lista plików nagłówkowych, które - ze
        względu na punkty wejście z tego i dwóch poprzednich podrozdziałów -
        powinny być włączone do pliku <filename>dummy.c</filename>:</para>

        <programlisting>#include &lt;sys/modctl.h&gt;  /* używane przez modlinkage, modldrv, _init, _info, */
                         /* and _fini */
#include &lt;sys/types.h&gt;   /* używane przez open, close, read, write, prop_op, */
                         /* ddi_prop_op */
#include &lt;sys/file.h&gt;    /* używane przez open, close */
#include &lt;sys/errno.h&gt;   /* używane przez open, close, read, write */
#include &lt;sys/open.h&gt;    /* używane przez open, close, read, write */
#include &lt;sys/cred.h&gt;    /* używane przez open, close, read */
#include &lt;sys/uio.h&gt;     /* używane przez read */
#include &lt;sys/stat.h&gt;    /* definiuje S_IFCHR używane przez ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* używane przez wszystkie punkty wejścia tego sterownik */
#include &lt;sys/ddi.h&gt;     /* używane przez wszystkie punkty wejścia tego sterownik */
                         /* oraz używane przez ddi_get_instance i */
                         /* ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* używane przez wszystkie punkty wejścia tego sterownik */
                         /* oraz używane przez ddi_create_minor_node, */
                         /* ddi_get_instance, ddi_prop_op */</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="eoxzx">
      <title>Writing the Driver Data Structures</title>

      <indexterm xml:id="indexterm-276">
        <primary><literal>dev_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-277">
        <primary>driver structures</primary>

        <secondary><literal>dev_ops</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-278">
        <primary><literal>cb_ops</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-279">
        <primary>driver structures</primary>

        <secondary><literal>cb_ops</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-280">
        <primary><literal>modldrv</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-281">
        <primary>driver structures</primary>

        <secondary><literal>modldrv</literal></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-282">
        <primary><literal>modlinkage</literal> driver structure</primary>
      </indexterm>

      <indexterm xml:id="indexterm-283">
        <primary>driver structures</primary>

        <secondary><literal>modlinkage</literal></secondary>
      </indexterm>

      <para>Opisane w tym podrozdziale struktury danych wymagane są w każdym
      sterowniku urządzenia. Każdy sterownik musi zdefiniować strukturę
      operacji urządzenia <olink remap="external" targetdoc="819-2257"
      targetptr="dev-ops-9s"> <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink>, natomiast struktura <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> zawiera wskaźnik do struktury operacji znakowych i
      blokowych <olink remap="external" targetdoc="819-2257"
      targetptr="cb-ops-9s"> <citerefentry>
          <refentrytitle>cb_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> i dlatego napierw trzeba zdefiniować
      strukturę <citerefentry>
          <refentrytitle>cb_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry>. Struktura powiązań dla ładowalnych sterowników <olink
      remap="external" targetdoc="819-2257" targetptr="modldrv-9s">
      <citerefentry>
          <refentrytitle>modldrv</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> zawiera wskaźnik do struktury <citerefentry>
          <refentrytitle>dev_ops</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry>. Struktura powiązań modułu <olink remap="external"
      targetdoc="819-2257" targetptr="modlinkage-9s"> <citerefentry>
          <refentrytitle>modlinkage</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry> </olink> zawiera wskaźnik do struktury <citerefentry>
          <refentrytitle>modldrv</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry>.</para>

      <para>Za wyjątkiem punktów wejścia modułów ładowalnych, wszystkie
      wymagane punkty wejścia dla sterownika są inicjalizowane w strukturze
      operacji znakowych i blokowych lub w strukturze operacji urządzenia.
      Niektóre opcjonalne punkty wejścia i powiązane dane są również
      inicjalizowane w tcy strukturach. Inicjalizacja punktów wejścia w tych
      strukturach umożliwia dynamiczne ładowanie sterownika.</para>

      <para>Punkty wejścia konfiguracji ładowalnego modułu nie są
      inicjalizowane w strukturach danych sterownika, ponieważ punkty wejścia
      <citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>_info</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>_fini</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> są wymagane przez wszystkie moduły jądra i nie są
      specyficzne dla modułów sterowników</para>

      <para>W tym podrozdziale dodano następujący kod:</para>

      <programlisting>/* struktura cb_ops */
static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* brak strategy - nodev zwraca ENXIO */
    nodev,              /* brak print */
    nodev,              /* brak dump */
    dummy_read,
    dummy_write,
    nodev,              /* brak ioctl */
    nodev,              /* brak devmap */
    nodev,              /* brak mmap */
    nodev,              /* brak segmap */
    nochpoll,           /* zwraca ENXIO dla urządzeń, z ktorych nie można */
                        /* pobierać danych (ang. non-pollable) */
    dummy_prop_op,
    NULL,               /* struktura streamtab; jeśli nie NULL, to wszystkie */
                        /* powyższe pola są ignorowane */
    D_NEW | D_MP,       /* flagi kompatybilności: więcej w conf.h */
    CB_REV,             /* numer wersji cb_ops */
    nodev,              /* brak aread */
    nodev               /* brak awrite */
};

/* struktura dev_ops */
static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                  /* licznik referencji */
    dummy_getinfo,
    nulldev,            /* brak identify - nulldev zwraca 0 */
    nulldev,            /* brak probe */
    dummy_attach,
    dummy_detach,
    nodev,              /* brak reset - nodev zwraca ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev               /* brak power */
};

/* struktura modldrv */
static struct modldrv md = {
    &amp;mod_driverops,     /* Typ modułu. To jest sterownik. */
    "dummy driver",     /* Nazwa modułu. */
    &amp;dummy_dev_ops
};

/* struktura modlinkage */
static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};

/* struktura dev_info */
dev_info_t *dummy_dip;  /* śledzenie jednej instancji */</programlisting>

      <sect3 xml:id="eoyag">
        <title>Defining the Character and Block Operations Structure</title>

        <indexterm xml:id="indexterm-284">
          <primary>driver structures</primary>

          <secondary>character and block operations structure</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-285">
          <primary><literal>cb_ops</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-286">
          <primary>driver structures</primary>

          <secondary><literal>cb_ops</literal></secondary>
        </indexterm>

        <para>Struktura <olink remap="external" targetdoc="819-2257"
        targetptr="cb-ops-9s"> <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> inicjalizuje standardowe interfejsy znakowe
        i blokowe. Więcej informacji o poszczególnych elementach na stronie
        man s<citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry>. Sterownik <literal>dummy</literal> nie używa
        wszystkich elementów struktury <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry>. Więcej w opisie pod kodem.</para>

        <para>Podczas nazywa struktury użyto prefiksu
        <literal>dummy_</literal>, podobnie jak w przypadku punktów wejścia
        autokonfiguracji i nazw funkcji kontekstu użytkownika. Deklarację
        należy poprzedzić modyfikatorem <literal>static</literal>.</para>

        <para>Poniższy kod struktury <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> należy włączyć do pliku
        <filename>dummy.c</filename>:</para>

        <programlisting>static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* brak strategy - nodev zwraca ENXIO */
    nodev,              /* brak print */
    nodev,              /* brak dump */
    dummy_read,
    dummy_write,
    nodev,              /* brak ioctl */
    nodev,              /* brak devmap */
    nodev,              /* brak mmap */
    nodev,              /* brak segmap */
    nochpoll,           /* zwraca ENXIO dla urządzeń, z ktorych nie można */
                        /* pobierać danych (ang. non-pollable) */
    dummy_prop_op,
    NULL,               /* struktura streamtab; jeśli nie NULL, to wszystkie */
                        /* powyższe pola są ignorowane */
    D_NEW | D_MP,       /* flagi kompatybilności: więcej w conf.h */
    CB_REV,             /* numer wersji cb_ops */
    nodev,              /* brak aread */
    nodev               /* brak awrite */
};</programlisting>

        <para>Nazwy punktów wejścia <citerefentry>
            <refentrytitle>open</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>close</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> dla tego sterownika (z prefiksem) muszą pojawić
        się jako dwa pierwsz elementy struktury. Nazwy punktów wejścia
        <citerefentry>
            <refentrytitle>read</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>write</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> dla tego sterownika muszą pojawić się jako szósty i
        siódmy element. Nazwa punktu wejścia <citerefentry>
            <refentrytitle>prop_op</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> dla tego sterownika powinna pojawić się jako
        trzynasty element struktury.</para>

        <para><indexterm xml:id="indexterm-287">
            <primary><function>nodev </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-288">
            <primary>kernel functions</primary>

            <secondary><function>nodev </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-289">
            <primary><function>nochpoll </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-290">
            <primary>kernel functions</primary>

            <secondary><function>nochpoll </function></secondary>
          </indexterm>Funkcje <citerefentry>
            <refentrytitle>strategy</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>print</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>dump</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> istnieją tylko dla sterowników blokowych. Sterownik
        <literal>dummy</literal> nie definiuje ich, ponieważ jest sterownikiem
        znakowym. Nie definiuje też punktu wejścia <citerefentry>
            <refentrytitle>ioctl</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, ponieważ nie używa komend kontrolujących I/O. Nie
        definiuje punktów wejścia <citerefentry>
            <refentrytitle>devmap</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>mmap</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>segmap</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, ponieważ nie obsługuje mapowania pamięci. Nie
        definiuje punktów wejścia <citerefentry>
            <refentrytitle>aread</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>awrite</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, ponieważ nie wykonuje asynchronicznych operacji
        zapisu i odczytu. Wszystkie te nieużywane elementy są inicjalizowane
        funkcją <olink remap="external" targetdoc="819-2256"
        targetptr="nodev-9f"> <citerefentry>
            <refentrytitle>nodev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>, zwracającą kod błędu
        <literal>ENXIO</literal>.</para>

        <para>Funkcję <olink remap="external" targetdoc="819-2256"
        targetptr="nochpoll-9f"> <citerefentry>
            <refentrytitle>nochpoll</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink> wskazuje się dla elementu struktury
        <citerefentry>
            <refentrytitle>chpoll</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, ponieważ sterownik nie obsługuje urządzeń, które
        można odpytywać o dane. Dla jednostki STREAMS <citerefentry>
            <refentrytitle>streamtab</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> wskazuje się <literal>NULL</literal>, ponieważ
        sterownik ten nie jest sterownikiem STREAMS.</para>

        <para>Flagi kompatybilności zdefiniowane są w pliku nagłówkowym
        <filename>conf.h</filename>. Flaga <literal>D_NEW</literal> oznacfza,
        że jest to sterownik nowego typu. Flaga <literal>D_MP</literal>
        oznacza, że sterownik bezpiecznie obsługuje wiele wątków wykonania.
        Wszystkie sterowniki muszą bezpiecznie obsługiwać wiele wątków
        wykonania i muszą zawierać flagę <literal>D_MP</literal>. Flaga
        <literal>D_64BIT</literal> oznacza, że sterownik obsługuje 64bitowe
        offsety i numery bloków. Wszystkie flagi kompatybilności można
        sprawdzić w pliku nagłówkowym <filename>conf.h</filename>.</para>

        <para>Element <literal>CB_REV</literal> struktury <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> jest numerem wersji <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> i zdefiniowany jest w pliku nagłówkowym
        <filename>devops.h</filename>.</para>
      </sect3>

      <sect3 xml:id="eoyaf">
        <title>Defining the Device Operations Structure</title>

        <indexterm xml:id="indexterm-291">
          <primary>driver structures</primary>

          <secondary>device operations structure</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-292">
          <primary><literal>dev_ops</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-293">
          <primary>driver structures</primary>

          <secondary><literal>dev_ops</literal></secondary>
        </indexterm>

        <para>Struktura <olink remap="external" targetdoc="819-2257"
        targetptr="dev-ops-9s"> <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> inicjalizuje interfejsy używane podczas
        operacji podłączania i odłączania sterownika. Szczegółowe informacje o
        wszystkich elementach tej struktury znajdują się na stronie man
        <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry>. Sterownik <literal>dummy</literal> nie używa
        wszystkich elementów tej struktury. Dokładniejszy opis znajduje się
        pod fragmentem kodu.</para>

        <para>Podczas nazywa struktury użyto prefiksu
        <literal>dummy_</literal>, podobnie jak w przypadku punktów wejścia
        autokonfiguracji i nazw funkcji kontekstu użytkownika. Deklarację
        należy poprzedzić modyfikatorem <literal>static</literal>.</para>

        <para>Poniższy kod opisujący strukturę <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> należy włączyć do pliku
        <filename>dummy.c</filename>:</para>

        <programlisting>static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                  /* licznik referencji */
    dummy_getinfo,
    nulldev,            /* brak identify - nulldev zwraca 0 */
    nulldev,            /* brak probe */
    dummy_attach,
    dummy_detach,
    nodev,              /* brak reset - nodev zwraca ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev               /* brak power */
};</programlisting>

        <para>Element <literal>DEVO_REV</literal> struktury <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> to wersja zbudowanego sterownika.
        <literal>DEVO_REV</literal> zdefiniowany jest w pliku nagłówkowym
        <literal>devops.h</literal>. Drugim elementem struktury jest licznik
        referencji sterownika, któremu należy nadać wartosć zero. Licznik
        referencji sterownika to liczba aktualnie otwartych instancji
        sterownika. Sterownika nie można wyładować, jeśli jest choć jedna
        otwarta instancja.</para>

        <para><indexterm xml:id="indexterm-294">
            <primary><function>nulldev </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-295">
            <primary>kernel functions</primary>

            <secondary><function>nulldev </function></secondary>
          </indexterm> <indexterm xml:id="indexterm-296">
            <primary><function>nodev </function> kernel function</primary>
          </indexterm> <indexterm xml:id="indexterm-297">
            <primary>kernel functions</primary>

            <secondary><function>nodev </function></secondary>
          </indexterm>Następne sześć elementów struktury <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> to nazwy funkcji <citerefentry>
            <refentrytitle>getinfo</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>identify</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>probe</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>attach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>detach</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <function>reset </function> dla sterownika.
        Funkcja <citerefentry>
            <refentrytitle>identify</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> jest przestarzała, a jej element w strukturze należy
        zainicjalizować funkcją <olink remap="external" targetdoc="819-2256"
        targetptr="nulldev-9f"> <citerefentry>
            <refentrytitle>nulldev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>. Funkcja <citerefentry>
            <refentrytitle>probe</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> sprawdza, czy odpowiednie urządzenie istnieje i jest
        poprawne. Sterownik <literal>dummy</literal> nie definiuje funkcji
        <citerefentry>
            <refentrytitle>probe</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, element ten należy zainicjalizować wartością
        <literal>nulldev</literal>. Funkcja <citerefentry>
            <refentrytitle>nulldev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> zwraca wartość sukcesu. Funkcja <function>reset
        </function> jest przestarzała i należy incjalizować ją funkcją <olink
        remap="external" targetdoc="819-2256"
        targetptr="nodev-9f"><citerefentry>
            <refentrytitle>nodev</refentrytitle>

            <manvolnum>9F</manvolnum>
          </citerefentry> </olink>.</para>

        <para>Następny element struktury to wskaźnik do struktury
        <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> dla sterownika. Strukturę <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> zainicjalizowano w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eoyag">Defining the Character and
        Block Operations Structure</olink>. Jako wartość wskaźnika do
        struktury <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> należy podać
        <literal>&amp;dummy_cb_ops</literal>.</para>

        <para>Następny element struktury <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> to wskaźnik do struktury operacji szyny danych.
        Tylko sterowniki zbiorcze (ang. nexus drivers) mają struktury operacji
        szyny danych. Sterownik <literal>dummy</literal> nie jest takim
        sterownikiem, dlatego wskaźnikowi przypisano wartość
        <literal>NULL</literal>, wskazującą, że sterorownik jest
        liściem.</para>

        <para>Ostatni element to nazwa funkcji <citerefentry>
            <refentrytitle>power</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> sterownika. Funkcja <citerefentry>
            <refentrytitle>power</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> wykonuje operacje na urządzeniu sprzętowym,
        natomiast opisywany sterownik nie jest zarządza urządzeniem
        sprzętowym. Elementowi struktury należy przypisać wartość
        <literal>nodev</literal>.</para>
      </sect3>

      <sect3 xml:id="epffy">
        <title>Defining the Module Linkage Structures</title>

        <indexterm xml:id="indexterm-298">
          <primary>driver structures</primary>

          <secondary>module linkage structures</secondary>
        </indexterm>

        <indexterm xml:id="indexterm-299">
          <primary><literal>modldrv</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-300">
          <primary>driver structures</primary>

          <secondary><literal>modldrv</literal></secondary>
        </indexterm>

        <indexterm xml:id="indexterm-301">
          <primary><literal>modlinkage</literal> driver structure</primary>
        </indexterm>

        <indexterm xml:id="indexterm-302">
          <primary>driver structures</primary>

          <secondary><literal>modlinkage</literal></secondary>
        </indexterm>

        <para>Następne dwie struktury ładowania modułu są wymagane dla każdego
        sterownika. Struktura łączenia modułu <olink remap="external"
        targetdoc="819-2257" targetptr="modlinkage-9s"> <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> używana jest przez funkcje <citerefentry>
            <refentrytitle>_init</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry>, <citerefentry>
            <refentrytitle>_info</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>_fini</refentrytitle>

            <manvolnum>9E</manvolnum>
          </citerefentry> do instalacji, usuwania i uzyskiwania informacji z
        modułu. Struktura łączenia dla ładowalnych sterowników <olink
        remap="external" targetdoc="819-2257" targetptr="modldrv-9s">
        <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> eksportuje unikalne dla sterownika
        informacje do jądra. Więcej informacji o tych strukturach i ich
        elementach na odpowiednich stronach man.</para>

        <para>Poniższy kod definiuje struktury <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> i <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> dla opisywanego w tym rozdziale sterownika:</para>

        <programlisting>static struct modldrv md = {
    &amp;mod_driverops,     /* Typ modułu. To jest sterownik. */
    "dummy driver",     /* Nazwa modułu. */
    &amp;dummy_dev_ops
};

static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};</programlisting>

        <para>Pierwszy element struktury <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> to wskaźnik do struktury opisującej typ sterownika;
        należy przypisać mu wartość wskaźnika do struktury
        <literal>mod_driverops</literal>. Struktura
        <literal>mod_driverops</literal> mówi jądru systemu, że moduł
        <filename>dummy.c</filename> jest ładowalnym modułem sterownika
        urządzenia. Struktura <literal>mod_driverops</literal> zadeklarowana
        jest w pliku nagłówkowym <filename>modctl.h</filename>, włączonym już
        do kodu <filename>dummy.c</filename>, stąd nie należy deklarować
        struktury <literal>mod_driverops</literal> w pliku
        <filename>dummy.c</filename>. Struktura
        <literal>mod_driverops</literal> zdefiniowana jest w pliku źródłowym
        <filename>modctl.c</filename>.</para>

        <para>Drugi element to łańcuch znaków opisujący moduł. Zazwyczaj
        zawiera nazwę modułu i numer wersji. Ostatni element struktury to
        wskaźnik do struktury <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> dla tego sterownika. Strukturę <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> zainicjalizowano w <olink remap="internal"
        targetdoc="chapter-2.xml" targetptr="eoyaf">Defining the Device
        Operations Structure</olink>.</para>

        <para>Pierwszym elementem struktury <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> jest numer wersji systemu ładowalnych modułów;
        należy nadać mu wartość <literal>MODREV_1</literal>. Następny element
        to adres null-terminated tablicy wskaźników do struktury łączenia.
        Moduły sterowników mają tylko strukturę łączenia. Należy zmiennej
        nadać adres struktury <literal>md</literal>. Listę struktur kończy się
        wartością <literal>NULL</literal>.</para>
      </sect3>

      <sect3 xml:id="eqbni">
        <title>Including Data Structures Header Files</title>

        <para>Struktury <olink remap="external" targetdoc="819-2257"
        targetptr="cb-ops-9s"> <citerefentry>
            <refentrytitle>cb_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2257" targetptr="dev-ops-9s"> <citerefentry>
            <refentrytitle>dev_ops</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> wymagają włączenia plików nagłówkowych
        <filename>conf.h</filename> i <filename>devops.h</filename>. Struktury
        <olink remap="external" targetdoc="819-2257"
        targetptr="modlinkage-9s"> <citerefentry>
            <refentrytitle>modlinkage</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="819-2257" targetptr="modldrv-9s"> <citerefentry>
            <refentrytitle>modldrv</refentrytitle>

            <manvolnum>9S</manvolnum>
          </citerefentry> </olink> wymagają wlączenia pliku nagłówkowego
        <literal>modctl.h</literal>. Plik <filename>modctl.h</filename> został
        włączony wcześniej, podczas pisania punktów wejścia konfiguracji
        ładowalnych modułów.</para>

        <para>Poniżej zamieszono pełną listę plików nagłówkowych do włączenia
        do pliku <filename>dummy.c</filename>:</para>

        <programlisting>#include &lt;sys/devops.h&gt;  /* używane przez dev_ops */
#include &lt;sys/conf.h&gt;    /* używane przez dev_ops i cb_ops */
#include &lt;sys/modctl.h&gt;  /* używane przez modlinkage, modldrv, _init, _info */
                         /* i _fini */
#include &lt;sys/types.h&gt;   /* używane przez open, close, read, write, prop_op */
                         /* i ddi_prop_op */
#include &lt;sys/file.h&gt;    /* używane przez open, close */
#include &lt;sys/errno.h&gt;   /* używane przez open, close, read, write */
#include &lt;sys/open.h&gt;    /* używane przez open, close, read, write */
#include &lt;sys/cred.h&gt;    /* używane przez open, close, read */
#include &lt;sys/uio.h&gt;     /* używane przez read */
#include &lt;sys/stat.h&gt;    /* definiuje S_IFCHR używane przez ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/ddi.h&gt;     /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* również używane przez cb_ops, ddi_get_instance */
                         /* i ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* także używane przez cb_ops, ddi_create_minor_node, */
                         /* ddi_get_instance i ddi_prop_op */</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="eoxzw">
    <title>Writing the Device Configuration File</title>

    <indexterm xml:id="indexterm-303">
      <primary>configuration files</primary>
    </indexterm>

    <indexterm xml:id="indexterm-304">
      <primary>devices</primary>

      <secondary>configuration files</secondary>
    </indexterm>

    <para>Opisywany sterownik wymaga pliku konfiguracyjnego. Minimalna ilość
    informacji zawartych pliku konfiguracyjnym to nazwa node'u urządzenia i
    nazwa lub typ rodzica urządzenia. W tym prostym przykładzie nazwa node'u
    urządzenia jest taka sama jak nazwa urządzenia. W pliku
    <filename>dummy.conf</filename> w katalogu roboczym należy umieścić
    poniższą linijkę:</para>

    <programlisting>name="dummy" parent="pseudo";</programlisting>
  </sect1>

  <sect1 xml:id="eoxzr">
    <title>Building and Installing the Template Driver</title>

    <para>W tym podrozdziale zademonstrowano kompilację i instalację
    sterownika na platformie 32bitowej. Instrukcje dla architektur SPARC i
    64bitowej x86 znajdują się w <olink remap="external"
    targetdoc="chapter-1.xml" targetptr="fgouv">Building a Driver</olink> i
    <olink remap="external" targetdoc="chapter-1.xml"
    targetptr="fsfqv">Installing a Driver</olink>.</para>

    <para>Należy skompilować i skonsolidować sterownik z opcją
    <option>D_KERNEL</option> wskazującą, że jest to moduł jądra. Poniższy
    przykład pokazuje kompilację i konsolidację dla architektury 32bitowej za
    pomocą kompilatora Sun Studio C:</para>

    <screen>% <userinput>cc -D_KERNEL -c dummy.c</userinput>
% <userinput>ld -r -o dummy dummy.o</userinput>
</screen>

    <para>Podczas instalacji sterownika należy być zalogowanym jako użytkownik
    <literal>root</literal>.</para>

    <para>Aż do momentu zakończenia testów i wprowadzania zmian w funkcjach
    <function>_info</function>, <function>_init</function> i
    <function>attach</function> sterownika należy instalować go w katalogu
    <filename>/tmp</filename>. Wykonuje się to przez skopiowanie pliku
    binarnego do katalogu <filename>/tmp</filename> i stworzenie do niego
    dowiązania z katalogu sterowników jądra. Więcej informacji w <olink
    remap="external" targetdoc="chapter-4.xml" targetptr="fdlbq">Device Driver
    Testing Tips</olink>.</para>

    <screen># <userinput>cp dummy /tmp</userinput>
</screen>

    <para>Dla architektury 32bitowej dowiązanie powinno wyglądać
    następująco:</para>

    <screen># <userinput>ln -s /tmp/dummy /usr/kernel/drv/dummy</userinput>
</screen>

    <para>Plik konfiguracyjny należy skopiować do katalogu sterowników
    jądra.</para>

    <screen># <userinput>cp dummy.conf /usr/kernel/drv</userinput>
</screen>
  </sect1>

  <sect1 xml:id="eoxzu">
    <title>Testing the Template Driver</title>

    <indexterm xml:id="indexterm-305">
      <primary>files</primary>

      <secondary><filename>/var/adm/messages</filename></secondary>
    </indexterm>

    <indexterm xml:id="indexterm-306">
      <primary><filename>/var/adm/messages</filename> file</primary>
    </indexterm>

    <indexterm xml:id="indexterm-307">
      <primary>commands</primary>

      <secondary><command>syslogd</command></secondary>
    </indexterm>

    <indexterm xml:id="indexterm-308">
      <primary><command>syslogd</command> command</primary>
    </indexterm>

    <indexterm xml:id="indexterm-309">
      <primary><function>cmn_err </function> kernel function</primary>
    </indexterm>

    <indexterm xml:id="indexterm-310">
      <primary>kernel functions</primary>

      <secondary><function>cmn_err </function></secondary>
    </indexterm>

    <para>Sterownik <literal>dummy</literal> zapisuje wiadomość do dziennika
    systemowego za każdym razem, kiedy uaktywniony jest punkt wejścia.
    Testowanie sterownika polega na szukaniu tych wiadomości w dzienniku
    systemowym, aby potwierdzić, że każdy punkt wejścia został wywołany.
    </para>

    <para>Funkcja <olink remap="external" targetdoc="819-2256"
    targetptr="cmn-err-9f"> <citerefentry>
        <refentrytitle>cmn_err</refentrytitle>

        <manvolnum>9F</manvolnum>
      </citerefentry> </olink> zapisuje wiadomości o niskim priorytecie do
    <filename>/dev/log</filename>. Daemon <olink remap="external"
    targetdoc="819-2240" targetptr="syslogd-1m"> <citerefentry>
        <refentrytitle>syslogd</refentrytitle>

        <manvolnum>1M</manvolnum>
      </citerefentry> </olink> odczytuje wiadomości z
    <filename>/dev/log</filename> i zapisuje wiadomości o niskim priorytecie
    do <filename>/var/adm/messages</filename>.</para>

    <para>W osobnym oknie należy wykonać poniższą komendę: </para>

    <screen>% <userinput>tail -f /var/adm/messages</userinput>
</screen>

    <sect2 xml:id="eqbqx">
      <title>Adding the Template Driver</title>

      <indexterm xml:id="indexterm-311">
        <primary>device drivers</primary>

        <secondary>loading</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-312">
        <primary>commands</primary>

        <secondary><command>add_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-313">
        <primary><command>add_drv</command> command</primary>
      </indexterm>

      <para>Podczas dodawania sterownika należy być zalogowany jako użytkownik
      <literal>root</literal>. Sterownik dodaje się komendą <olink
      remap="external" targetdoc="819-2240" targetptr="add-drv-1m">
      <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>:</para>

      <screen># <userinput>add_drv dummy</userinput>
</screen>

      <para>W wiadomościach zapisywanych do
      <filename>/var/adm/messages</filename> powinny pojawić się następujące
      komunikaty:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 513080 kern.notice] NOTICE: Inside _info
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 874762 kern.notice] NOTICE: Inside _init
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 678704 kern.notice] NOTICE: Inside dummy_attach</screen>

      <para>Punkty wejścia <citerefentry>
          <refentrytitle>_info</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry>, <citerefentry>
          <refentrytitle>_init</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> i <citerefentry>
          <refentrytitle>attach</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> są wywoływane podczas dodawania sterownika.</para>

      <para><indexterm xml:id="indexterm-314">
          <primary><literal>/devices/pseudo</literal> directory</primary>
        </indexterm>Sterownik <literal>dummy</literal> został dodany do
      katalogu <filename>/devices</filename>:</para>

      <screen>% <userinput>ls -l /devices/pseudo | grep dummy</userinput>
drwxr-xr-x   2 root     sys          512 <replaceable>date</replaceable> <replaceable>time</replaceable> dummy@0
crw-------   1 root     sys       92,  0 <replaceable>date</replaceable> <replaceable>time</replaceable> dummy@0:0</screen>

      <para><indexterm xml:id="indexterm-315">
          <primary>commands</primary>

          <secondary><command>modinfo</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-316">
          <primary><command>modinfo</command> command</primary>
        </indexterm>Sterownik <literal>dummy</literal> jest także najświeższym
      modułem drukowanym przez <olink remap="external" targetdoc="819-2240"
      targetptr="modinfo-1m"> <citerefentry>
          <refentrytitle>modinfo</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>:</para>

      <screen>% <userinput>modinfo</userinput>
 Id Loadaddr   Size Info Rev Module Name
180 ed192b70    544  92   1  dummy (dummy driver)</screen>

      <para><indexterm xml:id="indexterm-317">
          <primary>files</primary>

          <secondary><filename>/etc/name_to_major</filename></secondary>
        </indexterm> <indexterm xml:id="indexterm-318">
          <primary><filename>/etc/name_to_major</filename> file</primary>
        </indexterm>Nazwa modułu <literal>dummy driver</literal> jest
      wartością podaną jako drugi element struktury <citerefentry>
          <refentrytitle>modldrv</refentrytitle>

          <manvolnum>9S</manvolnum>
        </citerefentry>. Wartość <literal>92</literal> to starszy numer
      modułu.</para>

      <screen>% <userinput>grep dummy /etc/name_to_major</userinput>
dummy 92</screen>

      <para>Adres <literal>Loadaddr</literal> o wartości
      <literal>ed192b70</literal> jest adresem pierwszej instrukcji w
      sterowniku <literal>dummy</literal>. Adres ten może być przydatny na
      przykład przy usuwaniu błędów.</para>

      <screen>% <userinput>mdb -k</userinput>
&gt; dummy`_init $m
    BASE    LIMIT     SIZE NAME
ed192b70 ed192ff0      480 dummy
&gt; <userinput>$q</userinput>
</screen>

      <para><indexterm xml:id="indexterm-319">
          <primary>commands</primary>

          <secondary><command>prtconf</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-320">
          <primary><command>prtconf</command> command</primary>
        </indexterm>Sterownik <literal>dummy</literal> jest także najświeższym
      modułem drukowanym przez komendę <olink remap="external"
      targetdoc="819-2240" targetptr="prtconf-1m"><citerefentry>
          <refentrytitle>prtconf</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink> w dziale z pseudourządzeniami:</para>

      <screen>% <userinput>prtconf -P</userinput>
    pseudo, instance #0
        dummy, instance #0 (driver not attached)</screen>

      <para>Sterownik jest automatycznie ładowany kiedy do urządzenia
      urządzenia, którym sterownik zarządza, wysyłane jest żądanie dostępu.
      Sterownik może być automatycznie wyładowany, kiedy urządzenie przestaje
      być używane. </para>

      <itemizedlist>
        <para>Jeśli sterownik znajduje się w katalogu
        <filename>/devices</filename>, ale komenda <citerefentry>
            <refentrytitle>modinfo</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> nie pokazuje go, jedna z poniższych metod może
        okazać się przydatna:</para>

        <listitem>
          <para><indexterm xml:id="indexterm-321">
              <primary>commands</primary>

              <secondary><command>modload</command></secondary>
            </indexterm> <indexterm xml:id="indexterm-322">
              <primary><command>modload</command> command</primary>
            </indexterm>Należy użyć komendy <olink remap="external"
          targetdoc="819-2240" targetptr="modload-1m"> <citerefentry>
              <refentrytitle>modload</refentrytitle>

              <manvolnum>1M</manvolnum>
            </citerefentry> </olink>.</para>
        </listitem>

        <listitem>
          <para>Należy próbować uzyskać dostęp do urządzenia. Sterownik jest
          automatycznie ładowany podczas żądania dostępu do urządzenia, którym
          sterownik zarządza. Poniższy podrozdział opisuje metodę dostępu do
          urządzenia <literal>dummy</literal>.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="eqbqv">
      <title>Reading and Writing the Device</title>

      <indexterm xml:id="indexterm-323">
        <primary>devices</primary>

        <secondary>reading</secondary>
      </indexterm>

      <para>Poniższe testy należy wykonywać jako użytkownik
      <literal>root</literal>, w innym przypadku podczas próby dostępu do
      pliku specjalnego <filename>/devices/pseudo/dummy@0:0</filename> pojawi
      się komunikat błędu “Permission denied”. Należy zwrócić uwagę na
      uprawnienia drukowane dla <filename>/devices/pseudo/dummy@0:0</filename>
      w <olink remap="internal" targetdoc="chapter-2.xml"
      targetptr="eqbqx">Adding the Template Driver</olink>.</para>

      <para><indexterm xml:id="indexterm-324">
          <primary>commands</primary>

          <secondary><command>cat</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-325">
          <primary><command>cat</command> command</primary>
        </indexterm>Test odczytu z urządzenia. Urządzenie
      <literal>dummy</literal> prawdopodobnie nazywa się
      <filename>/devices/pseudo/dummy@0:0</filename>. Poniższa komenda wykona
      odczyt z urządzenia <literal>dummy</literal> nawet jeśli nazywa się
      nieco inaczej:</para>

      <screen># <userinput>cat /devices/pseudo/dummy*</userinput>
</screen>

      <para>W oknie, w którym obserwowany jest plik
      <filename>/var/adm/messages</filename> powinny pojawić się następujące
      komunikaty:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 136952 kern.notice] NOTICE: Inside dummy_open
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 709590 kern.notice] NOTICE: Inside dummy_read
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 550206 kern.notice] NOTICE: Inside dummy_close</screen>

      <para><indexterm xml:id="indexterm-326">
          <primary>devices</primary>

          <secondary>writing</secondary>
        </indexterm> <indexterm xml:id="indexterm-327">
          <primary>commands</primary>

          <secondary><command>echo</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-328">
          <primary><command>echo</command> command</primary>
        </indexterm>Test zapisu do urządzenia:</para>

      <screen># <userinput>echo hello &gt; `ls /devices/pseudo/dummy*`</userinput>
</screen>

      <para>W oknie, w którym obserwowany jest plik
      <filename>/var/adm/messages</filename> powinny pojawić się następujące
      komunikaty:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 136952 kern.notice] NOTICE: Inside dummy_open
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 891851 kern.notice] NOTICE: Inside dummy_prop_op
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 623947 kern.notice] NOTICE: Inside dummy_getinfo
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 672780 kern.notice] NOTICE: Inside dummy_write
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 550206 kern.notice] NOTICE: Inside dummy_close</screen>

      <para>Jak widać wynik jest niemal identyczny jak podczas testu odczytu.
      Jedyna różnica pojawia się w siódmej linijce. Użycie komendy <olink
      remap="external" targetdoc="819-2239" targetptr="cat-1"> <citerefentry>
          <refentrytitle>cat</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> </olink> powoduje, że jądro wywołuje punkt wejścia
      <olink remap="external" targetdoc="819-2255"
      targetptr="read-9e"><citerefentry>
          <refentrytitle>read</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> </olink> dla danego sterownika. Używanie komendy
      <olink remap="external" targetdoc="819-2239" targetptr="echo-1">
      <citerefentry>
          <refentrytitle>echo</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> </olink> powoduje, że jądro wywołuje punkt wejścia
      <olink remap="external" targetdoc="819-2255" targetptr="write-9e">
      <citerefentry>
          <refentrytitle>write</refentrytitle>

          <manvolnum>9E</manvolnum>
        </citerefentry> </olink> dla danego sterownika. Argument komendy
      <olink remap="external" targetdoc="819-2239"
      targetptr="echo-1"><citerefentry>
          <refentrytitle>echo</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> </olink> jest ignorowany, ponieważ sterownik nie
      wykonuje na danych żadnych operacji.</para>
    </sect2>

    <sect2 xml:id="eqbqw">
      <title>Removing the Template Driver</title>

      <indexterm xml:id="indexterm-329">
        <primary>device drivers</primary>

        <secondary>removing</secondary>
      </indexterm>

      <indexterm xml:id="indexterm-330">
        <primary>commands</primary>

        <secondary><command>rem_drv</command></secondary>
      </indexterm>

      <indexterm xml:id="indexterm-331">
        <primary><command>rem_drv</command> command</primary>
      </indexterm>

      <para>Podczas wyładowywania sterownika należy być zalogowanym jako
      użytkownik <literal>root</literal>. Do wyładowania sterownika służy
      komenda <olink remap="external" targetdoc="819-2240"
      targetptr="rem-drv-1m"> <citerefentry>
          <refentrytitle>rem_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>, a po jej wykonaniu należy usunąć dowiązanie
      do katalogu <filename>/devices</filename>:</para>

      <screen># <userinput>rem_drv dummy</userinput>
</screen>

      <para>W oknie, w którym obserwowany jest plik
      <filename>/var/adm/messages</filename> powinny pojawić się następujące
      komunikaty:</para>

      <screen>
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 513080 kern.notice] NOTICE: Inside _info
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 617648 kern.notice] NOTICE: Inside dummy_detach
<replaceable>date</replaceable> <replaceable>time</replaceable> <replaceable>machine</replaceable> dummy: [ID 812373 kern.notice] NOTICE: Inside _fini</screen>

      <para>Urządzenie <literal>dummy</literal> zostało usunięte z katalogu
      <filename>/devices</filename>:</para>

      <screen># <userinput>ls /devices/pseudo/dummy*</userinput>
/devices/pseudo/dummy*: No such file or directory</screen>

      <para>Przy następnych próbach zapisu lub odczytu z urządzenia
      <literal>dummy</literal> należy załadować ponownie sterownik komendą
      <citerefentry>
          <refentrytitle>add_drv</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry>.</para>

      <para><indexterm xml:id="indexterm-332">
          <primary>device drivers</primary>

          <secondary>unloading</secondary>
        </indexterm> <indexterm xml:id="indexterm-333">
          <primary>commands</primary>

          <secondary><command>modunload</command></secondary>
        </indexterm> <indexterm xml:id="indexterm-334">
          <primary><command>modunload</command> command</primary>
        </indexterm>Do wyładowania sterownika bez usuwania go z
      katalogu<filename> /devices</filename> można użyć komendy <olink
      remap="external" targetdoc="819-2240" targetptr="modunload-1m">
      <citerefentry>
          <refentrytitle>modunload</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>. W ten sposób sterownik zostanie załadowany
      automatycznie podczas próby dostępu do urządzenia
      <literal>dummy</literal>.</para>

      <para>Aby przestać śledzić komunikaty z
      <filename>/var/adm/messages</filename> należy nacisnąć kombinację
      klawiszy CTRL+C.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="eqbof">
    <title>Complete Template Driver Source</title>

    <para>Poniższy kod to kompletny kod źródłowy dla sterownika
    <literal>dummy</literal> opisywanego w tym rozdziale:</para>

    <programlisting>/*
 * Proste pseudourządzenie.
 * Wypisuje informację zawsze, gdy następuje wejście do funkcji.
 *
 * Budowanie sterownika:
 *      cc -D_KERNEL -c dummy.c
 *      ld -r -o dummy dummy.o
 * Kopiowanie sterownika i pliku konfiguracyjnego do /usr/kernel/drv:
 *      cp dummy.conf /usr/kernel/drv
 *      cp dummy /tmp
 *      ln -s /tmp/dummy /usr/kernel/drv/dummy
 * Dodanie sterownika:
 *      add_drv dummy
 * Próbny (1) odczyt ze sterownika (2) zapis do sterownika:
 *      cat /devices/pseudo/dummy@*
 *      echo hello &gt; `ls /devices/pseudo/dummy@*`
 * Sprawdzenie wyników testu w innym oknie:
 *      tail -f /var/adm/messages
 * Usunięcie sterownika:
 *      rem_drv dummy
 */

#include &lt;sys/devops.h&gt;  /* używane przez dev_ops */
#include &lt;sys/conf.h&gt;    /* używane przez dev_ops i cb_ops */
#include &lt;sys/modctl.h&gt;  /* używane przez modlinkage, modldrv, _init, _info */
                         /* i _fini */
#include &lt;sys/types.h&gt;   /* używane przez open, close, read, write, prop_op */
                         /* i ddi_prop_op */
#include &lt;sys/file.h&gt;    /* używane przez open, close */
#include &lt;sys/errno.h&gt;   /* używane przez open, close, read, write */
#include &lt;sys/open.h&gt;    /* używane przez open, close, read, write */
#include &lt;sys/cred.h&gt;    /* używane przez open, close, read */
#include &lt;sys/uio.h&gt;     /* używane przez read */
#include &lt;sys/stat.h&gt;    /* definiuje S_IFCHR używane przez ddi_create_minor_node */
#include &lt;sys/cmn_err.h&gt; /* używane przez wszystkie punkty wejścia w tym sterowniku */
#include &lt;sys/ddi.h&gt;     /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* również używane przez cb_ops, ddi_get_instance */
                         /* i ddi_prop_op */
#include &lt;sys/sunddi.h&gt;  /* używane przez wszystkie punkty wejścia w tym sterowniku */
                         /* także używane przez cb_ops, ddi_create_minor_node, */
                         /* ddi_get_instance i ddi_prop_op */

static int dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd);
static int dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd);
static int dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg,
    void **resultp);
static int dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp);
static int dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred);
static int dummy_close(dev_t dev, int flag, int otyp, cred_t *cred);
static int dummy_read(dev_t dev, struct uio *uiop, cred_t *credp);
static int dummy_write(dev_t dev, struct uio *uiop, cred_t *credp);

/* struktura cb_ops */
static struct cb_ops dummy_cb_ops = {
    dummy_open,
    dummy_close,
    nodev,              /* brak strategy - nodev zwraca ENXIO */
    nodev,              /* brak print */
    nodev,              /* brak dump */
    dummy_read,
    dummy_write,
    nodev,              /* brak ioctl */
    nodev,              /* brak devmap */
    nodev,              /* brak mmap */
    nodev,              /* brak segmap */
    nochpoll,           /* zwraca ENXIO dla urządzeń, z ktorych nie można */
                        /* pobierać danych (ang. non-pollable) */
    dummy_prop_op,
    NULL,               /* struktura streamtab; jeśli nie NULL, to wszystkie */
                        /* powyższe pola są ignorowane */
    D_NEW | D_MP,       /* flagi kompatybilności: więcej w conf.h */
    CB_REV,             /* numer wersji cb_ops */
    nodev,              /* brak aread */
    nodev               /* brak awrite */
};

/* struktura dev_ops */
static struct dev_ops dummy_dev_ops = {
    DEVO_REV,
    0,                  /* licznik odwołań */
    dummy_getinfo,
    nulldev,            /* brak identify - nulldev zwraca 0 */
    nulldev,            /* brak probe */
    dummy_attach,
    dummy_detach,
    nodev,              /* brak reset - nodev zwraca ENXIO */
    &amp;dummy_cb_ops,
    (struct bus_ops *)NULL,
    nodev               /* brak power */
};

/* struktura modldrv */
static struct modldrv md = {
    &amp;mod_driverops,     /* Typ modułu. To jest sterownik. */
    "dummy driver",     /* Nazwa modułu. */
    &amp;dummy_dev_ops
};

/* struktura modlinkage */
static struct modlinkage ml = {
    MODREV_1,
    &amp;md,
    NULL
};

/* struktura dev_info */
dev_info_t *dummy_dip;  /* śledzenie instacji */


/* Punkty wejścia konfiguracji ładowalnego modułu */
int
_init(void)
{
    cmn_err(CE_NOTE, "Inside _init");
    return(mod_install(&amp;ml));
}

int
_info(struct modinfo *modinfop)
{
    cmn_err(CE_NOTE, "Inside _info");
    return(mod_info(&amp;ml, modinfop));
}

int
_fini(void)
{
    cmn_err(CE_NOTE, "Inside _fini");
    return(mod_remove(&amp;ml));
}

/* Punkty wejścia konfiguracji urządzenia */
static int
dummy_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_attach");
    switch(cmd) {
    case DDI_ATTACH:
        dummy_dip = dip;
        if (ddi_create_minor_node(dip, "0", S_IFCHR,
            ddi_get_instance(dip), DDI_PSEUDO,0)
            != DDI_SUCCESS) {
            cmn_err(CE_NOTE,
                "%s%d: attach: could not add character node.",
                "dummy", 0);
            return(DDI_FAILURE);
        } else
            return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
    cmn_err(CE_NOTE, "Inside dummy_detach");
    switch(cmd) {
    case DDI_DETACH:
        dummy_dip = 0;
        ddi_remove_minor_node(dip, NULL);
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

static int
dummy_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, 
    void **resultp)
{
    cmn_err(CE_NOTE, "Inside dummy_getinfo");
    switch(cmd) {
    case DDI_INFO_DEVT2DEVINFO:
        *resultp = dummy_dip;
        return DDI_SUCCESS;
    case DDI_INFO_DEVT2INSTANCE:
        *resultp = 0;
        return DDI_SUCCESS;
    default:
        return DDI_FAILURE;
    }
}

/* Główne punkty wejścia */
static int
dummy_prop_op(dev_t dev, dev_info_t *dip, ddi_prop_op_t prop_op,
    int flags, char *name, caddr_t valuep, int *lengthp)
{
    cmn_err(CE_NOTE, "Inside dummy_prop_op");
    return(ddi_prop_op(dev,dip,prop_op,flags,name,valuep,lengthp));
}

static int
dummy_open(dev_t *devp, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_open");
    return DDI_SUCCESS;
}

static int
dummy_close(dev_t dev, int flag, int otyp, cred_t *cred)
{
    cmn_err(CE_NOTE, "Inside dummy_close");
    return DDI_SUCCESS;
}

static int
dummy_read(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_read");
    return DDI_SUCCESS;
}

static int
dummy_write(dev_t dev, struct uio *uiop, cred_t *credp)
{
    cmn_err(CE_NOTE, "Inside dummy_write");
    return DDI_SUCCESS;
}</programlisting>
  </sect1>
</chapter>