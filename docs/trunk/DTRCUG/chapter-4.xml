<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN"
"docbook.dtd" [
<!ENTITY % xinclude SYSTEM "xinclude.mod">
%xinclude;
]>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook" xml:id="gbxwz">
  <title>Używanie DTrace</title>

  <toc>
    <para>Rodział ten opisuje typowe przypadki użycia DTrace i zawiera
    informacje o kilku różnych rodzajach śledzenia.</para>
  </toc>

  <sect1 xml:id="gcggv">
    <title>Performance Monitoring</title>

    <para>Kilku dostawców DTrace zawiera sondy odnośne do istniejących
    narzędzi monitorowania wydajności:</para>

    <itemizedlist>
      <listitem>
        <para>Dostawca <literal>vminfo</literal> zawiera sondy odnośne do
        narzędzia <olink remap="external" targetdoc="816-5166"
        targetptr="vmstat-1m"> <citerefentry>
            <refentrytitle>vmstat</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> </olink></para>
      </listitem>

      <listitem>
        <para>Dostawca <literal>sysinfo</literal> zawiera sondy odnośne do
        narzędzia <olink remap="external" targetdoc="816-5166"
        targetptr="mpstat-1m"> <citerefentry>
            <refentrytitle>mpstat</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> </olink></para>
      </listitem>

      <listitem>
        <para>Dostawca <literal>io</literal> zawiera sondy odnośne do
        narzędzia <olink remap="external" targetdoc="816-5166"
        targetptr="iostat-1m"> <citerefentry>
            <refentrytitle>iostat</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> </olink></para>
      </listitem>

      <listitem>
        <para>Dostawca <literal>syscall</literal> zawiera sondy odnośne do
        narzędzia <olink remap="external" targetdoc="816-5165"
        targetptr="truss-1"> <citerefentry>
            <refentrytitle>truss</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink></para>
      </listitem>
    </itemizedlist>

    <para>DTrace można użyć do wyciągnięcia tych samych informacji, ale z
    większą elastycznością. Narzędzie DTrace dostarcza wybranych informacji o
    jądrze systemu, dostępnych w momencie odpalenia sondy. DTrace pozwala na
    osiągnięcie informacji typu identyfikator procesu, identyfikator wątku czy
    śledzenie stosu.</para>

    <sect2 xml:id="gcgfx">
      <title>Obserwacja zagadnień wydajnościowych z dostawcą
      <literal>sysinfo</literal></title>

      <para>Dostawca <literal>sysinfo</literal> zawiera sondy, które mają
      dostęp do statystyk jądra <literal>sys</literal>. Statystyki te są
      wejściem dla takich narzędzi monitorujących jak
      <literal>mpstat</literal>. Sondy dostawcy <literal>sysinfo</literal>
      odpalają natychmiast przed zwiększeniem wartości nazwanych
      <literal>kstat</literal> ze statystyk <literal>sys</literal>. Poniżej
      znajduje się lista sond zawartych w dostawcy
      <literal>sysinfo</literal>.</para>

      <variablelist>
        <varlistentry>
          <term><literal>bawrite</literal></term>

          <listitem>
            <para>Sonda odpala zawsze przed asynchronicznym zapisem bufora do
            urządzenia.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>bread</literal></term>

          <listitem>
            <para>Sonda odpala zawsze w momencie fizycznego odczytu bufora z
            urządzenia. <literal>bread</literal> odpala
            <emphasis>po</emphasis> wysłaniu przez urządzenie żądania dostępu
            do bufora, ale <emphasis>przed</emphasis> zakończeniem
            blokowania.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>bwrite</literal></term>

          <listitem>
            <para>Sonda odpala zawsze przed zapisem bufora do urządzenia,
            niezależnie od tego czy zapis ma być synchroniczny, czy
            asynchroniczny.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>cpu_ticks_idle</literal></term>

          <listitem>
            <para>Sonda odpala, gdy cykliczny zegar systemowy ustali, że CPU
            jest <emphasis>bezczynny</emphasis>. Należy zauważyć, że sonda
            odpla w kontekście zegara systemowego i dlatego odpala na
            procesorze, który utrzymuje zegar systemowy. Argument
            (<literal>arg2</literal>) dla <literal>cpu_t</literal> wskazuje
            bezczynny procesor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>cpu_ticks_kernel</literal></term>

          <listitem>
            <para>Sonda odpala, gdy cykliczny zegar systemowy ustali, że CPU
            wykonuje pracę na rzecz jądra. Należy zauważyć, że sonda odpla w
            kontekście zegara systemowego i dlatego odpala na procesorze,
            który utrzymuje zegar systemowy. Argument
            (<literal>arg2</literal>) dla <literal>cpu_t</literal> wskazuje
            procesor wykonujący pracę na rzecz jądra.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>cpu_ticks_user</literal></term>

          <listitem>
            <para>Sonda odpala, gdy cykliczny zegar systemowy ustali, że CPU
            wykonuje pracę na rzecz procesu użytkownika. Należy zauważyć, że
            sonda odpla w kontekście zegara systemowego i dlatego odpala na
            procesorze, który utrzymuje zegar systemowy. Argument
            (<literal>arg2</literal>) dla <literal>cpu_t</literal> wskazuje
            procesor wykonujący pracę na rzecz użytkownika.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>cpu_ticks_wait</literal></term>

          <listitem>
            <para>Sonda odpala, gdy cykliczny zegar systemowy ustali, że CPU
            jest bezczynny, ale są wątki oczekujące na I/O na tym procesorze.
            Należy zauważyć, że sonda odpla w kontekście zegara systemowego i
            dlatego odpala na procesorze, który utrzymuje zegar systemowy.
            Argument (<literal>arg2</literal>) dla <literal>cpu_t</literal>
            wskazuje procesor, na którym są wątki oczekujące na I/O.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>idlethread</literal></term>

          <listitem>
            <para>Sonda odpala, gdy CPU zaczyna pustą pętlę (ang. idle
            loop).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>intrblk</literal></term>

          <listitem>
            <para>Sonda odpala zawsze, gdy wątek przerwania nakłada
            blokadę.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>inv_swtch</literal></term>

          <listitem>
            <para>Sonda odpala gdy wykonywany wątek zostaje zmuszony do
            oddania CPU.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>lread</literal></term>

          <listitem>
            <para>Sonda odpala przy logicznym odczycie buforu z
            urządzenia.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>lwrite</literal></term>

          <listitem>
            <para>Sonda odpala przy logicznym zapisie buforu do
            urządzenia.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>modload</literal></term>

          <listitem>
            <para>Sonda odpala, gdy ładowany jest moduł jądra.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>modunload</literal></term>

          <listitem>
            <para>Sonda odpala, gdy usuwany jest moduł jądra.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>msg</literal></term>

          <listitem>
            <para>Sonda odpala zawsze, gdy wykonywane jest wywołanie systemowe
            <olink remap="external" targetdoc="816-5167" targetptr="msgsnd-2">
            <citerefentry>
                <refentrytitle>msgsnd</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink> lub <olink remap="external"
            targetdoc="816-5167" targetptr="msgrcv-2"> <citerefentry>
                <refentrytitle>msgrcv</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>, ale przed wszelkimi operacjami na
            kolejce wiadomości.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>mutex_adenters</literal></term>

          <listitem>
            <para>Sonda odpala przy próbie założenia wyłącznego zamka
            adaptującego się. Przy odpaleniu tej sondy, zawsze odpala też
            jedna z sond dostawcy <literal>lockstat</literal>:
            <literal>adaptive-block</literal> lub
            <literal>adaptive-spin</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>namei</literal></term>

          <listitem>
            <para>Sonda odpala, gdy tylko w systemie plików wykonywane jest
            rozwiązanie nazwy (ang. name lookup).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>nthreads</literal></term>

          <listitem>
            <para>Sonda odpala przy tworzeniu wątku.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>phread</literal></term>

          <listitem>
            <para>Sonda odpala przed rozpoczęciem nieprzetworzonego (ang. raw)
            odczytu I/O.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>phwrite</literal></term>

          <listitem>
            <para>Sonda odpala przed rozpoczęciem nieprzetworzonego (ang. raw)
            zapisu I/O.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>procovf</literal></term>

          <listitem>
            <para>Sonda odpala, gdy nie można utworzyć nowego procesu ze
            względu na brak miejsca w tablicy procesów.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>pswitch</literal></term>

          <listitem>
            <para>Sonda odpala przy każdej zmianie wątku wykonywanego przez
            CPU.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>readch</literal></term>

          <listitem>
            <para>Sonda odpala po każdym udanym odczycie, ale przed
            przekazaniem kontroli do wątku, który wykonywał odczyt. Odczyt
            może być efektem wywołań systemowych: <olink remap="external"
            targetdoc="816-5167" targetptr="read-2"> <citerefentry>
                <refentrytitle>read</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>, <olink remap="external"
            targetdoc="816-5167" targetptr="readv-2"> <citerefentry>
                <refentrytitle>readv</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink> lub <olink remap="external"
            targetdoc="816-5167" targetptr="pread-2"> <citerefentry>
                <refentrytitle>pread</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>. <literal>arg0</literal> zawiera liczbę
            bajtów, które udało się odczytać.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>rw_rdfails</literal></term>

          <listitem>
            <para>Sonda odpala przy próbie nałożenia zamka odczytu na
            czytelnika lub pisarza, gdy właścicielem zamka jest pisarz lub gdy
            próbę założenia zamka zgłasza pisarz. Jeśli sonda odpali, odpali
            też sonda <literal>rw-block</literal> dostawcy
            <literal>lockstat</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>rw_wrfails</literal></term>

          <listitem>
            <para>Sonda odpala przy próbie nałożenia zamka odczytu na
            czytelnika lub pisarza, gdy właścicielami zamka są czytelnicy lub
            inny pisarz. Jeśli sonda odpali, odpali też sonda
            <literal>rw-block</literal> dostawcy
            <literal>lockstat</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sema</literal></term>

          <listitem>
            <para>Sonda odpala przy wykonaniu wywołania systemowego <olink
            remap="external" targetdoc="816-5167" targetptr="semop-2">
            <citerefentry>
                <refentrytitle>semop</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>, ale zanim wykane zostaną jakiekolwiek
            czynności semaforów.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sysexec</literal></term>

          <listitem>
            <para>Sonda odpala przy wykonaniu wywołania systemowego <olink
            remap="external" targetdoc="816-5167" targetptr="exec-2">
            <citerefentry>
                <refentrytitle>exec</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sysfork</literal></term>

          <listitem>
            <para>Sonda odpala przy wykonaniu wywołania systemowego <olink
            remap="external" targetdoc="816-5167" targetptr="fork-2">
            <citerefentry>
                <refentrytitle>fork</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sysread</literal></term>

          <listitem>
            <para>Sonda odpala przy wykonaniu wywołania systemowego
            <command>read</command>, <command>readv</command> lub
            <command>pread</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sysvfork</literal></term>

          <listitem>
            <para>Sonda odpala przy wykonaniu wywołania systemowego <olink
            remap="external" targetdoc="816-5167" targetptr="vfork-2">
            <citerefentry>
                <refentrytitle>vfork</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>syswrite</literal></term>

          <listitem>
            <para>Sonda odpala przy wykonaniu wywołania systemowego <olink
            remap="external" targetdoc="816-5167" targetptr="write-2">
            <citerefentry>
                <refentrytitle>write</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>, <olink remap="external"
            targetdoc="816-5167" targetptr="writev-2"> <citerefentry>
                <refentrytitle>writev</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>, or <olink remap="external"
            targetdoc="816-5167" targetptr="pwrite-2"> <citerefentry>
                <refentrytitle>pwrite</refentrytitle>

                <manvolnum>2</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>trap</literal></term>

          <listitem>
            <para>Sonda odpala przy pjawieniu się pułapki procesora. Niektóre
            procesosy, zwłaszcza warianty UltraSPARC, obsługują niektóre
            lekkie pułapki w sposób, który nie odpala tej sondy.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>ufsdirblk</literal></term>

          <listitem>
            <para>Sonda odpala przy odczycie bloku katalogu na systemie plików
            UFS. Więcej informacji o UFS w <olink remap="external"
            targetdoc="816-5177" targetptr="ufs-7fs"> <citerefentry>
                <refentrytitle>ufs</refentrytitle>

                <manvolnum>7FS</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>ufsiget</literal></term>

          <listitem>
            <para>Sonda odpala przy sięgnięciu po inode. Więcej informacji o
            UFS w <olink remap="external" targetdoc="816-5177"
            targetptr="ufs-7fs"> <citerefentry>
                <refentrytitle>ufs</refentrytitle>

                <manvolnum>7FS</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>ufsinopage</literal></term>

          <listitem>
            <para>Sonda odpala po udostępnienieu do ponownego użytku in-core
            i-node'u <emphasis>niepowiązanego</emphasis> z żadną stroną
            zawierającą dane. Więcej informacji o UFS w <olink
            remap="external" targetdoc="816-5177" targetptr="ufs-7fs">
            <citerefentry>
                <refentrytitle>ufs</refentrytitle>

                <manvolnum>7FS</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>ufsipage</literal></term>

          <listitem>
            <para>Sonda odpala po udostępnienieu do ponownego użytku in-core
            i-node'u <emphasis>powiązanego</emphasis> ze stroną zawierającą
            dane. Sonda opdala po zrzuceniu stron z danymi na dysk. Więcej
            informacji o UFS w <olink remap="external" targetdoc="816-5177"
            targetptr="ufs-7fs"> <citerefentry>
                <refentrytitle>ufs</refentrytitle>

                <manvolnum>7FS</manvolnum>
              </citerefentry> </olink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>wait_ticks_io</literal></term>

          <listitem>
            <para>Sonda odpala, gdy cykliczny zegar systemowy ustali, że CPU
            jest bezczynny, ale są wątki oczekujące na I/O na tym procesorze.
            Należy zauważyć, że sonda odpla w kontekście zegara systemowego i
            dlatego odpala na procesorze, który utrzymuje zegar systemowy.
            Argument (<literal>arg2</literal>) dla <literal>cpu_t</literal>
            wskazuje procesor, na którym są wątki oczekujące na I/O. Nie ma
            żadnej różnicy między <literal>wait_ticks_io</literal> i
            <literal>cpu_ticks_wait</literal>;
            <literal>wait_ticks_io</literal> istnieje z czysto historycznych
            powodów.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>writech</literal></term>

          <listitem>
            <para>Sonda odpala po każdym udaym zapisie, ale przed przekazaniem
            kontroli do wątku, który wykonywał zapis. Zapis może być wynikiem
            wywołań systemowych <command>write</command>,
            <command>writev</command> lub <command>pwrite</command>.
            <literal>arg0</literal> zawiera liczbę bajtów, które udało się
            zapisać.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>xcalls</literal></term>

          <listitem>
            <para>Sonda odpala, gdy ma się wykonać międzywywołanie (ang.
            cross-call). Międzywywołanie jest mechanizmem systemu
            operacyjnego, pozwalającym procesorowi zażądać natychmiastowej
            pracy od innego procesora.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example xml:id="gcgii">
        <title>Using the <literal>quantize</literal> Aggregation Function With
        the <literal>sysinfo</literal> Probes</title>

        <para>Funkcja agregacyjna quantize drukuje słupkowy wykres
        kwadratowego rozkładu gęstości swoich argumentów. W poniższym
        przykładzie za pomocą funkcji <literal>quantize</literal> określa się
        wielkość wywołań <literal>read</literal> wykonywanych przez wszystkie
        procesy w systemie w okresie dziesięciu sekund. Argument
        <literal>arg0</literal> sond <literal>sysinfo</literal> wskazuje
        wielkość kroku zwiększania wartości statystyk. Dla większości sond
        dostawcy <literal>sysinfo</literal> wartość ta wynosi
        <literal>1</literal>. Dwoma wyjątkami są <literal>readch</literal> i
        <literal>writech</literal>, dla których <literal>arg0</literal> równy
        jest liczbie, odpowiednio, odczytanych lub zapisanych bajtów.</para>

        <screen># <userinput>cat -n read.d</userinput>
   1  #!/usr/sbin/dtrace -s
   2  sysinfo:::readch
   3  {
   4     @[execname] = quantize(arg0);
   5  }
   6
   7  tick-10sec
   8  {
   9     exit(0);
  10  }

# <userinput>dtrace -s read.d</userinput>
dtrace: script 'read.d' matched 5 probes
CPU        ID                    FUNCTION:NAME
  0     36754                      :tick-10sec

  bash
         value  ---------- Distribution ---------- count
             0 |                                   0
             1 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 13
             2 |                                   0

  file
         value  ---------- Distribution ---------- count
            -1 |                                   0
             0 |                                   2
             1 |                                   0
             2 |                                   0
             4 |                                   6
             8 |                                   0
            16 |                                   0
            32 |                                   6
            64 |                                   6
           128 |@@                                 16
           256 |@@@@                               30
           512 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      199
          1024 |                                   0
          2048 |                                   0
          4096 |                                   1
          8192 |                                   1
         16384 |                                   0

  grep
         value  ---------- Distribution ---------- count
            -1 |                                   0
             0 |@@@@@@@@@@@@@@@@@@@                99
             1 |                                   0
             2 |                                   0
             4 |                                   0
             8 |                                   0
            16 |                                   0
            32 |                                   0
            64 |                                   0
           128 |                                   1
           256 |@@@@                               25
           512 |@@@@                               23
          1024 |@@@@                               24
          2048 |@@@@                               22
          4096 |                                   4
          8192 |                                   3
         16384 |                                   0</screen>
      </example>

      <example xml:id="gcgis">
        <title>Finding the Source of Cross-Calls</title>

        <para>W poniższym przykładzie wydrukowano wynik komendy <olink
        remap="external" targetdoc="816-5166" targetptr="mpstat-1m">
        <citerefentry>
            <refentrytitle>mpstat</refentrytitle>

            <manvolnum>1M</manvolnum>
          </citerefentry> </olink>:</para>

        <screen>CPU minf mjf xcal  intr ithr  csw icsw migr smtx  srw syscl  usr sys  wt idl
  0 2189   0 1302    14    1  215   12   54   28    0 12995   13  14   0  73
  1 3385   0 1137   218  104  195   13   58   33    0 14486   19  15   0  66
  2 1918   0 1039    12    1  226   15   49   22    0 13251   13  12   0  75
  3 2430   0 1284   220  113  201   10   50   26    0 13926   10  15   0  75</screen>

        <para>Wartości kolumn <literal>xcal</literal> i
        <literal>syscl</literal> są nietypowo wysokie i być może wskazują na
        brak zasobów systemowych. System jest relatywnie bezczynny i nie
        oczekuje zbyt długo na I/O. Liczby w kolumnie <literal>xcal</literal>
        skalowane są co sekundę i odczytywane są z pola
        <literal>xcalls</literal> ze statystyk jądra <literal>sys</literal>.
        Poniższa komenda <command>dtrace</command> pozwoli odnaleźć pliki
        wykonywalne odpowiedzilane za międzywywołania:</para>

        <screen># <userinput>dtrace -n 'xcalls {@[execname] = count()}'</userinput>
dtrace: description 'xcalls ' matched 3 probes
<userinput>^C</userinput>
  find                                                   2
  cut                                                    2
  snmpd                                                  2
  mpstat                                                22
  sendmail                                             101
  grep                                                 123
  bash                                                 175
  dtrace                                               435
  sched                                                784
  xargs                                              22308
  file                                               89889
#</screen>

        <para>Wydruk komedy wskazuje, że większość międzywywołań pochodzi z
        procesów <olink remap="external" targetdoc="816-5165"
        targetptr="file-1"> <citerefentry>
            <refentrytitle>file</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="816-5165" targetptr="xargs-1"> <citerefentry>
            <refentrytitle>xargs</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink>. Można je odnaleźć za pomocą poleceń <olink
        remap="external" targetdoc="816-5165" targetptr="pgrep-1">
        <citerefentry>
            <refentrytitle>pgrep</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink> i <olink remap="external"
        targetdoc="816-5165" targetptr="ptree-1"> <citerefentry>
            <refentrytitle>ptree</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink>.</para>

        <screen># <userinput>pgrep xargs</userinput>
15973
# <userinput>ptree 15973</userinput>
204   /usr/sbin/inetd -s
  5650  in.telnetd
    5653  -sh
      5657  bash
        15970 /bin/sh ./findtxt configuration
          15971 cut -f1 -d:
            15973 xargs file
              16686 file /usr/bin/tbl /usr/bin/troff /usr/bin/ul /usr/bin/vgrind /usr/bin/catman</screen>

        <para>Wydruk ten wskazuje, że komendy <command>xargs</command> i
        <command>file</command> są częścią skryptu powłoki użytkownika. Skrypt
        ten można znaleźć w poniższy sposób:</para>

        <screen># <userinput>find / -name findtxt</userinput>
/usrs1/james/findtxt
# <userinput>cat /usrs1/james/findtxt</userinput>
#!/bin/sh
find / -type f | xargs file | grep text | cut -f1 -d: &gt; /tmp/findtxt$$
cat /tmp/findtxt$$ | xargs grep $1
rm /tmp/findtxt$$
#</screen>

        <para>Skrypt ten wykonuje uruchamia równocześnie wiele procesów.
        Procesy komunikują się intensywnie za pomocą potoków (ang. pipes).
        Liczba potoków powoduje, że skrypt jest bardzo zasobożerny. Skrypt
        wyszukuje wszystkie pliki tekstowe w systemie, a póżniej szuka w nich
        pewnego fragmentu.</para>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="gcgkk">
    <title>Śledzenie procesów użytkownika</title>

    <para>This section focuses on the DTrace facilities that are useful for
    tracing user process activity and provides examples to illustrate their
    use.</para>

    <sect2 xml:id="gcglu">
      <title>Używanie podprogramów <function>copyin </function>i
      <function>copyinstr</function></title>

      <para><indexterm xml:id="indexterm-25">
          <primary>subroutines</primary>

          <secondary><function>copyinstr </function></secondary>
        </indexterm> <indexterm xml:id="indexterm-26">
          <primary>subroutines</primary>

          <secondary><function>copyin </function></secondary>
        </indexterm> <indexterm xml:id="indexterm-27">
          <primary><function>copyinstr </function></primary>
        </indexterm> <indexterm xml:id="indexterm-28">
          <primary><function>copyin </function></primary>
        </indexterm> <indexterm xml:id="indexterm-29">
          <primary>user process tracing</primary>
        </indexterm>Sondy DTrace uruchamiane są w przestrzeni jądra Solarisa.
      Do kopiowania danych z procesów użytkownika do pamięci jądra używają
      podprogramów <function>copyin </function>i
      <function>copyinstr</function>.</para>

      <para>Niech rozważone będzie wywołanie systemowe
      <function>write</function>:</para>

      <programlisting>ssize_t write(int fd, const void *buf, size_t nbytes);</programlisting>

      <para>Poniższy D-skrypt ilustruje próbę nieprawidłowego wydrukowania
      zawartości łańcucha przekazanego wywołaniu systemowemu
      <command>write</command>:</para>

      <programlisting>syscall::write:entry
{
	printf("%s", stringof(arg1)); /* incorrect use of arg1 */
}</programlisting>

      <para>Przy próbie wykonania DTrace wydrukuje komunikat o błędzie podobny
      do poniższego:</para>

      <screen>dtrace: error on enabled probe ID 1 (ID 37: syscall::write:entry): \
    invalid address (0x10038a000) in action #1</screen>

      <para>Zmienna <literal>arg1</literal> zawiera adres w pamięci należącej
      do procesu, który wykonuje wywołanie systemowe. Zawartość łańcucha
      znaków znajdującego się pod tym adresem można odczytać za pomocą
      podprogramów <function>copyinstr</function> i zapisać akcją
      <function>printf</function>:</para>

      <programlisting>syscall::write:entry
{
	printf("%s", copyinstr(arg1)); /* correct use of arg1 */</programlisting>

      <para>Skrypt drukuje wszystkie łańcuchy przekazane do wywołania
      systemowego <command>write</command>.</para>

      <sect3 xml:id="gcgkr">
        <title>Unikanie błędów</title>

        <para>Podprogramy <function>copyin </function>i
        <function>copyinstr</function> nie mogą czytać z nieużywanych jeszcze
        adresów w przestrzeni użytkownika. Poprawny adres może spowodować
        błąd, jeśli strona zwierająca ten adres nie pojawił się błąd strony,
        do której próbowano sięgnąć. Ilustruje to poniższy przykład:</para>

        <screen># <userinput>dtrace -n syscall::open:entry'{ trace(copyinstr(arg0)); }'</userinput>
dtrace: description 'syscall::open:entry' matched 1 probe
CPU     ID                    FUNCTION:NAME
dtrace: error on enabled probe ID 2 (ID 50: syscall::open:entry): invalid address
(0x9af1b) in action #1 at DIF offset 52</screen>

        <para>W wydruku aplikacja działa poprawnie i adres przekazany w
        <literal>arg0</literal> jest poprawny. Niemniej jednak aplikacja nie
        sięgała jeszcze do strony, w której znajduje się ten adres. Aby
        uniknąć tego problemu, należy poczekać, aż jądro lub aplikacja użyje
        danych, zanim zacznie się je śledzić. Można na przykład poczekać, aż
        wróci wywołanie systemowe, zanim uruchomi się podprogram
        <function>copyinstr</function>:</para>

        <screen># <userinput>dtrace -n syscall::open:entry'{ self-&gt;file = arg0; }' \
-n syscall::open:return'{ trace(copyinstr(self-&gt;file)); self-&gt;file = 0; }'</userinput>
dtrace: description 'syscall::open:entry' matched 1 probe
CPU     ID                    FUNCTION:NAME
  2     51                      open:return   /dev/null                        </screen>
      </sect3>
    </sect2>

    <sect2 xml:id="gcgmh">
      <title>Unikanie zakłóceń z <command>dtrace</command></title>

      <para><indexterm xml:id="indexterm-30">
          <primary><literal>dtrace</literal> interference</primary>
        </indexterm>Przy śledzeniu wszystkich wywołań systemowych
      <command>write</command> łatwo spowodować lwainę wydruków. Każde
      wywołanie funkcji <function>write </function>spowoduje, że komenda
      <command>dtrace</command> wywoła funkcję <function>write</function>, aby
      wydrukować wynik pracy. To sprzężenie zwrotne świetnie ilustruje, w jaki
      sposób <command>dtrace</command> może zakłócić pożądane dane. Przy
      pomocy prostego predykatu można tego uniknąć:</para>

      <programlisting>syscall::write:entry
/pid != $pid/
{
	printf("%s", stringof(copyin(arg1, arg2)));
}</programlisting>

      <para>Zmienna makro <literal>$pid</literal> rozszerzana jest do pełnego
      identyfikatora procesu, który uruchmił sondy. Zmienna
      <literal>pid</literal> zawiera identyfikator procesu, ktrego wątek był
      wykonywany przez procesor w momencie odpalenia sondy. Predykat
      <literal>/pid != $pid/</literal> zapewnia, że skrypt nie śledzi wyników
      swojej własnej pracy.</para>
    </sect2>

    <sect2 xml:id="gcgld">
      <title>Dostawca syscall</title>

      <para><indexterm xml:id="indexterm-31">
          <primary>probes</primary>

          <secondary><function>syscall </function></secondary>
        </indexterm>Dostawca <literal>syscall</literal> pozwala na śledznie
      punktów wejścia i wyjścia z dowolnego wywołania systemowego. Zachowanie
      procesu można sprawdzić za pomocą komendy <olink remap="external"
      targetdoc="816-5166" targetptr="prstat-1m"><citerefentry>
          <refentrytitle>prstat</refentrytitle>

          <manvolnum>1M</manvolnum>
        </citerefentry> </olink>.</para>

      <screen>$ <userinput>prstat -m -p 31337</userinput>
   PID USERNAME USR SYS TRP TFL DFL LCK SLP LAT VCX ICX SCL SIG PROCESS/NLWP  
 13499 user1     53  44 0.0 0.0 0.0 0.0 2.5 0.0  4K  24  9K   0 mystery/6</screen>

      <para>W powyższym wydruku proces zużywia bardzo dużo czasu systemowego.
      Jednym z wytłumaczeń może być duża ilość wykonywanych wywołań
      systemowych. Przy pomocy prostego D-programu zapisanego w linii poleceń
      można sprawdzić, które wywołania systemowe wykonywane są
      najczęściej:</para>

      <screen># <userinput>dtrace -n syscall:::entry'/pid == 31337/{ @syscalls[probefunc] = count(); }'</userinput>
dtrace: description 'syscall:::entry' matched 215 probes
<userinput>^C</userinput>

  open                                                              1
  lwp_park                                                          2
  times                                                             4
  fcntl                                                             5
  close                                                             6
  sigaction                                                         6
  read                                                             10
  ioctl                                                            14
  sigprocmask                                                     106
  write                                                          1092</screen>

      <para>Powyższy wydruk pokazuje dużą ilość wywołań funkcji
      <function>write</function>. Źródło tych wywołań można ustalić za pomocą
      sond dostawcy <literal>syscall</literal>:</para>

      <screen>
<userinput># dtrace -n syscall::write:entry'/pid == 31337/{ @writes[arg2] = quantize(); }'</userinput>
dtrace: description 'syscall::write:entry' matched 1 probe
<userinput>^C</userinput>

           value  ------------- Distribution ------------- count    
               0 |                                         0        
               1 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   1037
               2 |@                                        3        
               4 |                                         0        
               8 |                                         0        
              16 |                                         0        
              32 |@                                        3        
              64 |                                         0        
             128 |                                         0        
             256 |                                         0        
             512 |                                         0        
            1024 |@                                        5        
            2048 |                                         0        </screen>

      <para>Proces wykonuje dużo wywołań funkcji <function>write </function>z
      relatywnie małymi porcjami danych.</para>
    </sect2>

    <sect2 xml:id="gcgma">
      <title>Akcja <function>ustack</function></title>

      <para><indexterm xml:id="indexterm-32">
          <primary><function>ustack </function></primary>
        </indexterm>Akcja <function>ustack </function>śledzi stos wątku
      użytkownika. Jeśli proces otwierający wiele plików co jakiś czas nie
      potrafi wykonać wywoałania systemowego <function>open</function>, za
      pomocą akcji <function>ustack </function>można odczytać śceżkę
      wykonania, która doprowadziła do nieudanego wywołania <function>open
      </function>:</para>

      <programlisting>syscall::open:entry
/pid == $1/
{
	self-&gt;path = copyinstr(arg0);
}

syscall::open:return
/self-&gt;path != NULL &amp;&amp; arg1 == -1/
{
	printf("open for '%s' failed", self-&gt;path);
	ustack();
}</programlisting>

      <para>Skrypt ten ilustruje także użycie zmiennej makro
      <literal>$1</literal>. Ta zmienna makro zawiera pierwszy operand
      przekazany w linii poleceń komendzie <command>dtrace</command>:</para>

      <screen># <userinput>dtrace -s ./badopen.d 31337</userinput>
dtrace: script './badopen.d' matched 2 probes
CPU     ID                    FUNCTION:NAME
  0     40                      open:return open for '/usr/lib/foo' failed
              libc.so.1`__open+0x4
              libc.so.1`open+0x6c
              420b0
              tcsh`dosource+0xe0
              tcsh`execute+0x978
              tcsh`execute+0xba0
              tcsh`process+0x50c
              tcsh`main+0x1d54
              tcsh`_start+0xdc</screen>

      <para>Akcja <function>ustack </function>zapisuje wartości licznika
      programu dla stosu (ang. program counter - <acronym>PC</acronym>).
      Komenda<command> dtrace</command> rozwiązuje wartości
      <acronym>PC</acronym> na nazwy symboiczne za pomocą tablicy symboli
      procesów. Wartości <acronym>PC</acronym>, których komenda
      <command>dtrace</command> nie potrafiła rozwiązać, drukowane są jako
      liczby całkowite w systemie szesnastkowym.</para>

      <para>Kiedy proces zakończy działanie lub zostane zabity, zanim dane
      <function>ustack </function>zostaną sformatowane do wydruku, komenda
      <command>dtrace</command> może nie dać rady przetłumaczyć wartości
      <acronym>PC</acronym> na nazwy symboliczne. W takim przypadku komenda
      <command>dtrace</command> drukuje te wartości w postaci szesnastkowych
      liczb całkowitych. Można spróbować obejść to ogranizecznie, wskazując
      proces z opcją <option>c</option> lub <option>p</option>. Jeśli ID
      procesu lub komenda nie są znane z góry, można użyć poniższego
      D-skryptu. W przykładzie używana jest sonda wywołania
      systemowego<literal> open</literal>, ale techniki tej można użyć z
      dowolnym skryptem, który korzysta z akcji
      <literal>ustack</literal>.</para>

      <programlisting> syscall::open:entry
{
	ustack();
	stop_pids[pid] = 1;
}

syscall::rexit:entry
/stop_pids[pid] != 0/
{
	printf("stopping pid %d", pid);
	stop();
	stop_pids[pid] = 0;
}</programlisting>

      <para>Skrypt zatrzymuje proces na chwilę, zanim zakończy on działanie,
      jeśli użyto wobec wątku tego procesu akcji <function>ustack</function>.
      Zapewnia to, że komenda <command>dtrace</command> będzie mogła rozwiązać
      wartości licznika <acronym>PC</acronym> na nazwy symboliczne. Wartość
      <literal>stop_pids[pid]</literal> jest zerowana po wyczyszczeniu
      zmiennej dynamicznej.</para>
    </sect2>

    <sect2 xml:id="gcgmc">
      <title>Dostawca <literal>pid</literal></title>

      <para><indexterm xml:id="indexterm-33">
          <primary><literal>pid</literal> provider</primary>
        </indexterm>Dostawca <literal>pid</literal> pozwala na śledzenie
      każdej instrukcji w procesie. W odróżnieniu od większości dostawców,
      sondy <literal>pid</literal> tworzone są na żądanie w oparciu o opis
      sondy w programie D.</para>

      <sect3 xml:id="gcglh">
        <title>Śledzenie granic wykonania funkcji użytkownika</title>

        <para><indexterm xml:id="indexterm-34">
            <primary>function boundary testing (FBT)</primary>
          </indexterm>Najprostszym sposobem użycia dostawcy
        <literal>pid</literal> jest wykorzystanie go jako odpowiednika
        dostawcy <literal>fbt</literal> dla procesów przestrzeni użytkownika.
        Poniższy przykład śledzi wszystkie wejścia i wyjścia z pojedynczej
        funkcji. Zmienna makro <literal>$1</literal> rozszerzana jest do
        pierwszego operandu w linii poleceń. Jest to PID procesu, który ma być
        śledzony. Druga zmienna makro <literal>$2</literal> jest rozszerzana
        do drugiego operandu w linii poleceń, czyli nazwy funkcji do
        śledzenia.</para>

        <example xml:id="gcgkx">
          <title><filename>userfunc.d</filename>: Trace User Function Entry
          and Return</title>

          <programlisting>pid$1::$2:entry
{
	self-&gt;trace = 1;
}

pid$1::$2:return
/self-&gt;trace/
{
	self-&gt;trace = 0;
}

pid$1:::entry,
pid$1:::return
/self-&gt;trace/
{
}</programlisting>
        </example>

        <para>Wynik działania tego skyrptu jest podobny do poniższego
        wydruku:</para>

        <screen># <userinput>./userfunc.d 15032 execute</userinput>
dtrace: script './userfunc.d' matched 11594 probes
  0  -&gt; execute                               
  0    -&gt; execute                             
  0      -&gt; Dfix                              
  0      &lt;- Dfix                              
  0      -&gt; s_strsave                         
  0        -&gt; malloc                          
  0        &lt;- malloc                          
  0      &lt;- s_strsave                         
  0      -&gt; set                               
  0        -&gt; malloc                          
  0        &lt;- malloc                          
  0      &lt;- set                               
  0      -&gt; set1                              
  0        -&gt; tglob                           
  0        &lt;- tglob                           
  0      &lt;- set1                              
  0      -&gt; setq                              
  0        -&gt; s_strcmp                        
  0        &lt;- s_strcmp                        
...</screen>

        <para>Sond dostawcy <literal>pid</literal> można używać tylko do
        procesów, które już działają. Aby uruchomić konkretny proces wraz z
        jego śledzeniem, można użyć zmiennej makro <literal>$target</literal>
        oraz opcji <command>dtrace</command> <option>c</option> i
        <option>p</option>. Poniższy D-skrypt ustala dystrybucję wywołań
        funkcji do biblioteki <literal>libc</literal> z konkretnego
        procesu:</para>

        <programlisting>pid$target:libc.so::entry
{
	@[probefunc] = count();
}</programlisting>

        <para>Poniższa komenda ustala dystrybucję wywołań z komendy <olink
        remap="external" targetdoc="816-5165" targetptr="date-1">
        <citerefentry>
            <refentrytitle>date</refentrytitle>

            <manvolnum>1</manvolnum>
          </citerefentry> </olink>:</para>

        <screen># <userinput>dtrace -s libc.d -c date</userinput>
dtrace: script 'libc.d' matched 2476 probes
Fri Jul 30 14:08:54 PDT 2004
dtrace: pid 109196 has exited

  pthread_rwlock_unlock                                             1
  _fflush_u                                                         1
  rwlock_lock                                                       1
  rw_write_held                                                     1
  strftime                                                          1
  _close                                                            1
  _read                                                             1
  __open                                                            1
  _open                                                             1
  strstr                                                            1
  load_zoneinfo                                                     1

...
  _ti_bind_guard                                                   47
  _ti_bind_clear                                                   94</screen>
      </sect3>

      <sect3 xml:id="gcgkv">
        <title>Śledzenie dowolnych instrukcji</title>

        <para><indexterm xml:id="indexterm-35">
            <primary><literal>pid</literal> provider</primary>
          </indexterm> <indexterm xml:id="indexterm-36">
            <primary>tracing instructions</primary>
          </indexterm>Za pomocą sond dostawcy <literal>pid</literal> można
        śledzić dowolną instrukcję w dowolnej funkcji użytkownika. Dostawca
        <literal>pid</literal> tworzy na żądanie sondę dla każdej instrukcji w
        funkcji. Nazwą sondy jest szesnastkowy offset instrukcji wewnątrz
        funkcji. Sondę powiązaną z instrukcją o offsecie
        <literal>0x1c</literal> w funkcji <literal>foo</literal> modułu
        <literal>bar.so</literal> w procesie o PID 123 włącza się
        następująco:</para>

        <screen># <userinput>dtrace -n pid123:bar.so:foo:1c</userinput>
</screen>

        <para>Wszystkie sondy w funkcji <literal>foo</literal> dla każdej
        instrukcji można włączyć następująco:</para>

        <screen># <userinput>dtrace -n pid123:bar.so:foo:</userinput>
</screen>

        <para>W poniższym przykładzie użyto dostawcy <literal>pid</literal> w
        połączeniu ze śledzeniem spekulatywnym do śledzenia wszystkich
        instrukcji w funkcji.</para>

        <example xml:id="gcgle">
          <title><filename>errorpath.d</filename>: Trace User Function Call
          Error Path</title>

          <programlisting>pid$1::$2:entry
{
	self-&gt;spec = speculation();
	speculate(self-&gt;spec);
	printf("%x %x %x %x %x", arg0, arg1, arg2, arg3, arg4);
}

pid$1::$2:
/self-&gt;spec/
{
	speculate(self-&gt;spec);
}

pid$1::$2:return
/self-&gt;spec &amp;&amp; arg1 == 0/
{
	discard(self-&gt;spec);
	self-&gt;spec = 0;
}

pid$1::$2:return
/self-&gt;spec &amp;&amp; arg1 != 0/
{
	commit(self-&gt;spec);
	self-&gt;spec = 0;
}</programlisting>
        </example>

        <para>Wydruk działania skryptu <filename>errorpath.d</filename> będzie
        podobny do poniższego.</para>

        <screen># <userinput>./errorpath.d 100461 _chdir</userinput>
dtrace: script './errorpath.d' matched 19 probes
CPU     ID                    FUNCTION:NAME
  0  25253                     _chdir:entry 81e08 6d140 ffbfcb20 656c73 0
  0  25253                     _chdir:entry
  0  25269                         _chdir:0
  0  25270                         _chdir:4
  0  25271                         _chdir:8
  0  25272                         _chdir:c
  0  25273                        _chdir:10
  0  25274                        _chdir:14
  0  25275                        _chdir:18
  0  25276                        _chdir:1c
  0  25277                        _chdir:20
  0  25278                        _chdir:24
  0  25279                        _chdir:28
  0  25280                        _chdir:2c
  0  25268                    _chdir:return</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="gcgln">
    <title>Anonimowe śledzenie</title>

    <para>W poniższym podrozdziale opisano śledzenie niepowiązane z żadnym
    konsumentem DTrace. Używa się go w sytuacji, gdy nie można uruchomić
    żadnego z konsumentów. Tylko superużytkownik może używać anonimowych
    uruchomień i tylko jedno anonimowe uruchomienie może pracować w danym
    momencie.</para>

    <sect2 xml:id="gcglb">
      <title>Anonimowe uruchomienia</title>

      <para><indexterm xml:id="indexterm-37">
          <primary>anonymous tracing</primary>
        </indexterm> <indexterm xml:id="indexterm-38">
          <primary>anonymous enabling</primary>
        </indexterm>Anonimowych uruchomień dokonuje się za pomcą opcji
      <option>A</option> komendy <command>dtrace</command> oraz wskazania
      sond, predykatów akcji i opcji. Komenda <command>dtrace</command>
      dołączy do pliku konfiguracyjnego sterownika <olink remap="external"
      targetdoc="816-5177" targetptr="dtrace-7d"><citerefentry>
          <refentrytitle> dtrace</refentrytitle>

          <manvolnum>7D</manvolnum>
        </citerefentry></olink> pewną liczbę właściwości sterownika
      reprezentujących żądanie. Plik konfiguracyjny to najczęściej
      <filename>/kernel/drv/dtrace.conf</filename>. Podczas ładowania
      sterownika <filename>dtrace</filename> odczytuje ten plik, a następnie
      uruchamia wskazane sondy ze wskazanymi akcjami i tworzy <firstterm>stan
      anonimowy</firstterm> do powiązania z nowymi uruchomieniami. Sterownik
      <filename>dtrace</filename> jest w normalnych warunkach ładowany na
      żądanie wraz z innymi sterownikami, które działają jako dostawcy
      <command>dtrace</command>. Aby możliwe było śledzenie procesu
      uruchomienia systemu, sterownik <filename>dtrace</filename> musi zostać
      załadowany najwcześniej jak to tylko możliwe. Komenda
      <command>dtrace</command> dodaje niezbędne wyrażenia
      <literal>forceload</literal> do <filename>/etc/system</filename> (więcej
      w <olink remap="external" targetdoc="816-5174" targetptr="system-4">
      <citerefentry>
          <refentrytitle>system</refentrytitle>

          <manvolnum>4</manvolnum>
        </citerefentry> </olink>) dla każdego wymaganego dostawcy
      <command>dtrace</command> i sterownika
      <filename>dtrace</filename>.</para>

      <para>Podczas uruchamiania systemu sterownik <filename>dtrace</filename>
      wysyła wiadomość, że plik konfiguracyjny został przetworzony prawidłowo.
      Podczas anonimowego śledzenia można używać tych samych opcji, które są
      dostępne w czasie zwyczajnego używania komendy
      <command>dtrace</command>.</para>

      <para>Anonimowe uruchamianie wyłącza się przez podanie tylko i wyłącznie
      opcji <option>A</option> komendzie <command>dtrace</command>.</para>
    </sect2>

    <sect2 xml:id="gcgkj">
      <title>Podłączanie do anonimowego stanu</title>

      <para><indexterm xml:id="indexterm-39">
          <primary>anonymous tracing</primary>

          <secondary>claiming anonymous state</secondary>
        </indexterm>Po zakończeniu procesu uruchamiania systemu można
      podłączyć się do stanu anonimowego przez podanie opcji
      <option>a</option> komendzie <command>dtrace</command>. Domyślnie
      <option>a</option> powoduje podłączenie do stanu anonimowego,
      przetworzenie danych i dalszą pracę. Aby zakończyć działanie po
      skonsumowaniu danych należy użyć opcji <option>e</option>.</para>

      <para>Po skonsumowaniu stanu anonimowego nie można stworzyć nowego. Przy
      próbie podłączenia do nieistniejącego anonimowego stanu
      <command>dtrace</command> wydrukuje błąd podobny do poniższego:</para>

      <screen>dtrace: could not enable tracing: No anonymous tracing state</screen>

      <para>Komenda <command>dtrace</command> drukuje komunikaty o błędzie
      przy wystąpieniu błędów i zrzutów podczas podłączania do stanu
      anonimowego. Komunikaty te są takie same dla śledzenia anonimowego jak i
      nieanonimowego. </para>
    </sect2>

    <sect2 xml:id="gcgki">
      <title>Przykłady śledznia anonimowego</title>

      <para><indexterm xml:id="indexterm-40">
          <primary>examples</primary>

          <secondary>anonymous tracing</secondary>
        </indexterm> <indexterm xml:id="indexterm-41">
          <primary>anonymous tracing</primary>

          <secondary>example of use</secondary>
        </indexterm>Poniższy przykład ilustruje anonimowe śledzenie każdej
      sondy w module <olink remap="external" targetdoc="816-5177"
      targetptr="iprb-7d"> <citerefentry>
          <refentrytitle>iprb</refentrytitle>

          <manvolnum>7D</manvolnum>
        </citerefentry> </olink>:</para>

      <screen># <userinput>dtrace -A -m iprb</userinput>
dtrace: saved anonymous enabling in /kernel/drv/dtrace.conf
dtrace: added forceload directives to /etc/system
dtrace: run update_drv(1M) or reboot to enable changes
# <userinput>reboot</userinput>
</screen>

      <para>Po restarcie systemu sterownik <filename>dtrace</filename> drukuje
      na konsoli wiadomość wskazującą, że sterownik uruchamia wskazane
      sondy:</para>

      <screen>  ...
  Copyright 1983-2003 Sun Microsystems, Inc.  All rights reserved.
  Use is subject to license terms.
  NOTICE: enabling probe 0 (:iprb::)
  NOTICE: enabling probe 1 (dtrace:::ERROR)
  configuring IPv4 interfaces: iprb0.
  ...</screen>

      <para>Podanie komendzie <command>dtrace</command> opcji
      <option>a</option> spowoduje konsumpcję anonimowego stanu:</para>

      <screen>
<userinput># dtrace -a</userinput>
  CPU     ID                    FUNCTION:NAME
    0  22954                      _init:entry 
    0  22955                     _init:return 
    0  22800                  iprbprobe:entry 
    0  22934          iprb_get_dev_type:entry 
    0  22935         iprb_get_dev_type:return 
    0  22801                 iprbprobe:return 
    0  22802                 iprbattach:entry 
    0  22874               iprb_getprop:entry 
    0  22875              iprb_getprop:return 
    0  22934          iprb_get_dev_type:entry 
    0  22935         iprb_get_dev_type:return 
    0  22870             iprb_self_test:entry 
    0  22871            iprb_self_test:return 
    0  22958            iprb_hard_reset:entry 
    0  22959           iprb_hard_reset:return 
    0  22862       iprb_get_eeprom_size:entry 
    0  22826              iprb_shiftout:entry 
    0  22828            iprb_raiseclock:entry 
    0  22829           iprb_raiseclock:return 
  ...</screen>

      <para>Poniższy D-skrypt skupia się na funkcjach wywoływanych z
      <function>iprbattach </function>.</para>

      <programlisting>fbt::iprbattach:entry
{
	self-&gt;trace = 1;
}

fbt:::
/self-&gt;trace/
{}

fbt::iprbattach:return
{
	self-&gt;trace = 0;
}</programlisting>

      <para>Wydrukowane niżej kroki spowodują wyczyszczenie poprzednich
      ustawień w pliku konfiguracyjnym sterownika, zainstalują noe żądanie
      anonimowego śledzenia i zrestartują system:</para>

      <screen># <userinput>dtrace -AFs iprb.d</userinput>
dtrace: cleaned up old anonymous enabling in /kernel/drv/dtrace.conf
dtrace: cleaned up forceload directives in /etc/system
dtrace: saved anonymous enabling in /kernel/drv/dtrace.conf
dtrace: added forceload directives to /etc/system
dtrace: run update_drv(1M) or reboot to enable changes
# <userinput>reboot</userinput>
</screen>

      <para>Po restarcie systemu sterownik <command>dtrace</command> drukuje
      wiadomość wskazującą inny zestaw uruchomionych sond:</para>

      <screen>  ...
  Copyright 1983-2003 Sun Microsystems, Inc.  All rights reserved.
  Use is subject to license terms.
  NOTICE: enabling probe 0 (fbt::iprbattach:entry)
  NOTICE: enabling probe 1 (fbt:::)
  NOTICE: enabling probe 2 (fbt::iprbattach:return)
  NOTICE: enabling probe 3 (dtrace:::ERROR)
  configuring IPv4 interfaces: iprb0.
  ...</screen>

      <para>Po zakończonym procesie startu systemu należy uruchomić komendę
      <command>dtrace</command> z opcjami<option> a</option> i<option>
      e</option>, aby skonsumować dane i wyłączyć śledzenie.</para>

      <screen>
<userinput># dtrace -ae</userinput>
  CPU FUNCTION                                 
    0  -&gt; iprbattach                            
    0    -&gt; gld_mac_alloc                       
    0      -&gt; kmem_zalloc                       
    0        -&gt; kmem_cache_alloc                
    0          -&gt; kmem_cache_alloc_debug        
    0            -&gt; verify_and_copy_pattern     
    0            &lt;- verify_and_copy_pattern     
    0            -&gt; tsc_gethrtime               
    0            &lt;- tsc_gethrtime               
    0            -&gt; getpcstack                  
    0            &lt;- getpcstack                  
    0            -&gt; kmem_log_enter              
    0            &lt;- kmem_log_enter              
    0          &lt;- kmem_cache_alloc_debug        
    0        &lt;- kmem_cache_alloc                
    0      &lt;- kmem_zalloc                       
    0    &lt;- gld_mac_alloc                       
    0    -&gt; kmem_zalloc                         
    0      -&gt; kmem_alloc                        
    0        -&gt; vmem_alloc                      
    0          -&gt; highbit                       
    0          &lt;- highbit                       
    0          -&gt; lowbit                        
    0          &lt;- lowbit                        
    0          -&gt; vmem_xalloc                   
    0            -&gt; highbit                     
    0            &lt;- highbit                     
    0            -&gt; lowbit                      
    0            &lt;- lowbit                      
    0            -&gt; segkmem_alloc               
    0              -&gt; segkmem_xalloc            
    0                -&gt; vmem_alloc              
    0                  -&gt; highbit               
    0                  &lt;- highbit               
    0                  -&gt; lowbit                
    0                  &lt;- lowbit                
    0                  -&gt; vmem_seg_alloc        
    0                    -&gt; highbit             
    0                    &lt;- highbit             
    0                    -&gt; highbit             
    0                    &lt;- highbit             
    0                    -&gt; vmem_seg_create     
  ...</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="gbxxu">
    <title>Śledzenie spekulatywne</title>

    <para>W tym podrozdziale omówiono <firstterm>śledzenie
    spekulatywne</firstterm> DTrace. Jest to możliwość śledzenia danych z
    odsunięciem w czasie decyzji o dołączeniu wyników do buforu śledzenia.
    Podstawowym mechanizmem filtrowania nieinteresujących zdarzeń są
    predykaty. Są jednak przydatne tylko w sytuacji, gdy wiadomo z góry, które
    sondy należy śledzić, nie nadają się jednak w sytuacji, gdy nie można z
    góry ustalić, czy zdarzenie powiązane z odpaleniem danej sondy ma
    znaczenie, czy też nie. </para>

    <para>Jeśli zdarza się co jakiś czas, że wywołanie systemowe zwraca ten
    sam błąd, można prześledzić ścieżkę wykonania wiodącą do tego błędu. Przy
    pomocy śledzenia spekulatywnego można prześledzić dane w kliku miejscach
    próbkowania, a póżniej zdecydować, które dołączyć do buforu głównego. W
    rezultacie ślad zawiera tylko interesujące z tego punktu widzenia dane i
    nie wymaga póżniejszego przetwarzania.</para>

    <sect2 xml:id="gcgmb">
      <title>Interfejsy spekulacyjne</title>

      <para><indexterm xml:id="indexterm-42">
          <primary>speculation</primary>
        </indexterm>W poniższej tabeli przedstawiono funkcje spekulacyjne
      DTrace.</para>

      <table frame="topbot" xml:id="gcglj">
        <title>DTrace Speculation Functions</title>

        <tgroup cols="3" colsep="0" rowsep="0">
          <colspec colwidth="1.14in" />

          <colspec colwidth="1.00in" />

          <colspec colwidth="2.38in" />

          <thead>
            <row rowsep="1">
              <entry><para>Function Name</para></entry>

              <entry><para>Arguments</para></entry>

              <entry><para>Description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para> <literal>speculation</literal> </para></entry>

              <entry><para>None</para></entry>

              <entry><para>Returns an identifier for a new speculative
              buffer</para></entry>
            </row>

            <row>
              <entry><para> <literal>speculate</literal> </para></entry>

              <entry><para>ID</para></entry>

              <entry><para>Denotes that the remainder of the clause should be
              traced to the speculative buffer specified by ID</para></entry>
            </row>

            <row>
              <entry><para> <literal>commit</literal> </para></entry>

              <entry><para>ID</para></entry>

              <entry><para>Commits the speculative buffer that is associated
              with ID</para></entry>
            </row>

            <row>
              <entry><para> <literal>discard</literal> </para></entry>

              <entry><para>ID</para></entry>

              <entry><para>Discards the speculative buffer associated with
              ID</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 xml:id="gcgkl">
      <title>Tworzenie spekulacji</title>

      <para><indexterm xml:id="indexterm-43">
          <primary>speculation</primary>

          <secondary>creating</secondary>
        </indexterm> <indexterm xml:id="indexterm-44">
          <primary><function>speculation </function> function</primary>
        </indexterm>Funkcja <function>speculation</function> alokuje bufor
      spekulacyjny i zwraca identyfikator spekulacji. W póżniejszych
      wywołaniach funkcji <function>speculate</function> należy posługiwać się
      tym identyfikatorem. Zerowy identyfikator jest zawsze nieprawidołowy,
      ale można go przekazać do <function>speculate</function>,
      <function>commit </function> lub <function>discard</function>. Jeśli
      wywołanie <function>speculation </function>nie powiedzie się, komenda
      <command>dtrace</command> wydrukuje błąd podobny do poniższego:</para>

      <screen>dtrace: 2 failed speculations (no speculative buffer space available)</screen>
    </sect2>

    <sect2 xml:id="gcgli">
      <title>Używanie spekulacji</title>

      <para><indexterm xml:id="indexterm-45">
          <primary>speculation</primary>

          <secondary>use</secondary>
        </indexterm>Aby wykonać śledzenie spekulatywne należy, przed
      wykonaniem akcji zapisujących dane, przekazać funkcji
      <function>speculate</function> identyfikator zwrócony przez
      <function>speculation</function>. Wszelkie akcje zapisujące dane w
      klauzuli zawierającej <function>speculate </function>są śledzone
      oddzielnie. Kompilator D zwróci komunikat o błędzie w trakcie
      kompilacji, jeśli wywołanie <function>speculate</function> wykonane jest
      w klauzuli D po akcjach zapisujących dane. Klauzula może zawierać albo
      spekulatywne śledzenie albo niespekulatywne, ale nie oba naraz.</para>

      <para>Akcje agregujące, niszczycielskie i <literal>exit</literal> nie
      mogą być spekulatywne. Dowolna próba użycia ich w klauzuli zawierającej
      <function>speculate</function> spowoduje błąd kompilacji. Funkcja
      <function>speculate </function>nie może być wywołania po innej funkcji
      <function>speculate</function>. Dozwolona jest tylko jedna spekulacja w
      klauzuli. Klauzula zawierająca tylko funkcję <function>speculate
      </function>będzie śledziła domyślną akcję, która śledzi tylko ID
      włączonej sondy.</para>

      <para>The typical use of the <function>speculation </function> function
      is to assign the result of the <function>speculation </function>
      function to a thread-local variable. That thread-local variable acts as
      a subsequent predicate to other probes, as well as an argument to
      <function>speculate </function>.</para>

      <example xml:id="gcgmg">
        <title>Typical Use of The <function>speculation </function>
        Function</title>

        <programlisting>syscall::open:entry
{
	self-&gt;spec = speculation();
}

syscall:::
/self-&gt;spec/
{
	speculate(self-&gt;spec);
	printf("this is speculative");
}</programlisting>
      </example>
    </sect2>

    <sect2 xml:id="gcglw">
      <title>Committing a Speculation</title>

      <para><indexterm xml:id="indexterm-46">
          <primary>speculation</primary>

          <secondary>committing</secondary>
        </indexterm>Commit speculations by using the <function>commit
      </function> function. When you commit a speculative buffer the buffer's
      data is copied into the principal buffer. If the data in the speculative
      buffer exceeds the available space in the principal buffer, no data is
      copied and the drop count for the buffer increments. If the buffer has
      been speculatively traced on more than one CPU, the speculative data on
      the committing CPU is copied immediately, while speculative data on
      other CPUs is copied after the <function>commit </function>.</para>

      <para>A speculative buffer that is being committed is not available to
      subsequent <function>speculation </function> calls until each per-CPU
      speculative buffer is completely copied into its corresponding per-CPU
      principal buffer. Subsequent attempts to write the results of a
      <function>speculate </function> function call to the committing buffer
      discard the data without generating an error. Subsequent calls to
      <function>commit </function> or <function>discard </function> also fail
      without generating an error. A clause that contains a <function>commit
      </function> function cannot contain a data recording action, but a
      clause can contain multiple <function>commit </function> calls to commit
      disjoint buffers.</para>
    </sect2>

    <sect2 xml:id="gcgkq">
      <title>Discarding a Speculation</title>

      <para><indexterm xml:id="indexterm-47">
          <primary>speculation</primary>

          <secondary>discarding</secondary>
        </indexterm>Discard speculations by using the <function>discard
      </function> function. If the speculation has only been active on the CPU
      that is calling the <function>discard </function> function, the buffer
      is immediately available for subsequent calls to the
      <function>speculation </function> function. If the speculation has been
      active on more than one CPU, the discarded buffer will be available for
      subsequent calls to the <function>speculation </function> function after
      the call to <function>discard </function>. If no speculative buffers are
      available at the time that the <function>speculation </function>
      function is called a<command>dtrace</command> message that is similar to
      the following example is generated:</para>

      <screen>dtrace: 905 failed speculations (available buffer(s) still busy)</screen>
    </sect2>

    <sect2 xml:id="gcglc">
      <title>Przykład spekulacji</title>

      <para><indexterm xml:id="indexterm-48">
          <primary>speculation</primary>

          <secondary>example of use</secondary>
        </indexterm> <indexterm xml:id="indexterm-49">
          <primary>examples</primary>

          <secondary>speculation</secondary>
        </indexterm>Jednym z przykładowych użyć spekulacji jest prześledzenie
      jednej konkretnej ścieżki wykonania. Poniższy wydruk pokazuje kompleną
      ścieżkę wykonania dla wywołania systemowego <olink remap="external"
      targetdoc="816-5167" targetptr="open-2"> <citerefentry>
          <refentrytitle>open</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> </olink>, w której <function>open </function>nie udaje
      się.</para>

      <example xml:id="gcgkt">
        <title><filename>specopen.d</filename>: Code Flow for Failed
        <function>open </function></title>

        <programlisting>#!/usr/sbin/dtrace -Fs

syscall::open:entry,
syscall::open64:entry
{
	/*
	 * The call to speculation() creates a new speculation.  If this fails,
	 * dtrace(1M) will generate an error message indicating the reason for
	 * the failed speculation(), but subsequent speculative tracing will be
	 * silently discarded.
	 */
	self-&gt;spec = speculation();
	speculate(self-&gt;spec);

	/*
	 * Because this printf() follows the speculate(), it is being 
	 * speculatively traced; it will only appear in the data buffer if the
	 * speculation is subsequently commited.
	 */
	printf("%s", stringof(copyinstr(arg0)));
}

fbt:::
/self-&gt;spec/
{
	/*
	 * A speculate() with no other actions speculates the default action:
	 * tracing the EPID.
	 */
	speculate(self-&gt;spec);
}

syscall::open:return,
syscall::open64:return
/self-&gt;spec/
{
	/*
	 * To balance the output with the -F option, we want to be sure that
	 * every entry has a matching return.  Because we speculated the
	 * open entry above, we want to also speculate the open return.
	 * This is also a convenient time to trace the errno value.
	 */
	speculate(self-&gt;spec);
	trace(errno);
}

syscall::open:return,
syscall::open64:return
/self-&gt;spec &amp;&amp; errno != 0/
{
	/*
	 * If errno is non-zero, we want to commit the speculation.
	 */
	commit(self-&gt;spec);
	self-&gt;spec = 0;
}

syscall::open:return,
syscall::open64:return
/self-&gt;spec &amp;&amp; errno == 0/
{
	/*
	 * If errno is not set, we discard the speculation.
	 */
	discard(self-&gt;spec);
	self-&gt;spec = 0;
}</programlisting>
      </example>

      <para>Powyższy skrypt wydrukuje wynik podobny do poniższego:</para>

      <screen># <userinput>./specopen.d</userinput>
dtrace: script './specopen.d' matched 24282 probes
CPU FUNCTION                                 
  1  =&gt; open                                  /var/ld/ld.config
  1    -&gt; open                                
  1      -&gt; copen                             
  1        -&gt; falloc                          
  1          -&gt; ufalloc                       
  1            -&gt; fd_find                     
  1              -&gt; mutex_owned               
  1              &lt;- mutex_owned               
  1            &lt;- fd_find                     
  1            -&gt; fd_reserve                  
  1              -&gt; mutex_owned               
  1              &lt;- mutex_owned               
  1              -&gt; mutex_owned               
  1              &lt;- mutex_owned               
  1            &lt;- fd_reserve                  
  1          &lt;- ufalloc                       
  1          -&gt; kmem_cache_alloc              
  1            -&gt; kmem_cache_alloc_debug      
  1              -&gt; verify_and_copy_pattern   
  1              &lt;- verify_and_copy_pattern   
  1              -&gt; file_cache_constructor    
  1                -&gt; mutex_init              
  1                &lt;- mutex_init              
  1              &lt;- file_cache_constructor    
  1              -&gt; tsc_gethrtime             
  1              &lt;- tsc_gethrtime             
  1              -&gt; getpcstack                
  1              &lt;- getpcstack                
  1              -&gt; kmem_log_enter            
  1              &lt;- kmem_log_enter            
  1            &lt;- kmem_cache_alloc_debug      
  1          &lt;- kmem_cache_alloc              
  1          -&gt; crhold                        
  1          &lt;- crhold                        
  1        &lt;- falloc                          
  1        -&gt; vn_openat                       
  1          -&gt; lookupnameat                  
  1            -&gt; copyinstr                   
  1            &lt;- copyinstr                   
  1            -&gt; lookuppnat                  
  1              -&gt; lookuppnvp                
  1                -&gt; pn_fixslash             
  1                &lt;- pn_fixslash             
  1                -&gt; pn_getcomponent         
  1                &lt;- pn_getcomponent         
  1                -&gt; ufs_lookup              
  1                  -&gt; dnlc_lookup           
  1                    -&gt; bcmp                
  1                    &lt;- bcmp                
  1                  &lt;- dnlc_lookup           
  1                  -&gt; ufs_iaccess           
  1                    -&gt; crgetuid            
  1                    &lt;- crgetuid            
  1                    -&gt; groupmember         
  1                      -&gt; supgroupmember    
  1                      &lt;- supgroupmember
  1                    &lt;- groupmember         
  1                  &lt;- ufs_iaccess           
  1                &lt;- ufs_lookup              
  1                -&gt; vn_rele                 
  1                &lt;- vn_rele                 
  1                -&gt; pn_getcomponent         
  1                &lt;- pn_getcomponent         
  1                -&gt; ufs_lookup              
  1                  -&gt; dnlc_lookup           
  1                    -&gt; bcmp                
  1                    &lt;- bcmp                
  1                  &lt;- dnlc_lookup           
  1                  -&gt; ufs_iaccess           
  1                    -&gt; crgetuid            
  1                    &lt;- crgetuid            
  1                  &lt;- ufs_iaccess           
  1                &lt;- ufs_lookup              
  1                -&gt; vn_rele                 
  1                &lt;- vn_rele                 
  1                -&gt; pn_getcomponent         
  1                &lt;- pn_getcomponent         
  1                -&gt; ufs_lookup              
  1                  -&gt; dnlc_lookup           
  1                    -&gt; bcmp                
  1                    &lt;- bcmp                
  1                  &lt;- dnlc_lookup           
  1                  -&gt; ufs_iaccess           
  1                    -&gt; crgetuid            
  1                    &lt;- crgetuid            
  1                  &lt;- ufs_iaccess           
  1                  -&gt; vn_rele               
  1                  &lt;- vn_rele               
  1                &lt;- ufs_lookup              
  1                -&gt; vn_rele                 
  1                &lt;- vn_rele                 
  1              &lt;- lookuppnvp                
  1            &lt;- lookuppnat                  
  1          &lt;- lookupnameat                  
  1        &lt;- vn_openat                       
  1        -&gt; setf                            
  1          -&gt; fd_reserve                    
  1            -&gt; mutex_owned                 
  1            &lt;- mutex_owned                 
  1            -&gt; mutex_owned                 
  1            &lt;- mutex_owned                 
  1          &lt;- fd_reserve                    
  1          -&gt; cv_broadcast                  
  1          &lt;- cv_broadcast                  
  1        &lt;- setf                            
  1        -&gt; unfalloc                        
  1          -&gt; mutex_owned                   
  1          &lt;- mutex_owned                   
  1          -&gt; crfree                        
  1          &lt;- crfree                        
  1          -&gt; kmem_cache_free               
  1            -&gt; kmem_cache_free_debug       
  1              -&gt; kmem_log_enter            
  1              &lt;- kmem_log_enter            
  1              -&gt; tsc_gethrtime             
  1              &lt;- tsc_gethrtime             
  1              -&gt; getpcstack                
  1              &lt;- getpcstack                
  1              -&gt; kmem_log_enter            
  1              &lt;- kmem_log_enter
  1              -&gt; file_cache_destructor     
  1                -&gt; mutex_destroy           
  1                &lt;- mutex_destroy           
  1              &lt;- file_cache_destructor     
  1              -&gt; copy_pattern              
  1              &lt;- copy_pattern              
  1            &lt;- kmem_cache_free_debug       
  1          &lt;- kmem_cache_free               
  1        &lt;- unfalloc                        
  1        -&gt; set_errno                       
  1        &lt;- set_errno                       
  1      &lt;- copen                             
  1    &lt;- open                                
  1  &lt;= open                                          2</screen>
    </sect2>
  </sect1>
</chapter>