<?xml version="1.0" encoding="UTF-8"?>
<chapter id="chp-intro">
  <title>Introduction</title>

  <highlights>
    <para>Oto dynamiczne śledzenie w systemie operacyjnym Solaris! Jeśli
    kiedykolwiek chciałeś zrozumieć zachowanie swojego systemu, DTrace jest
    dla Ciebie. Jesto to kompletne i spójne środowisko do dynamicznego
    śledzenia wbudowane w system operacyjny Solaris, przeznaczone dla
    administratorów i deweloperów na systemach produkcyjnych, pozwalające na
    śledzenie zachowania zarówno programów użytkownych jak i systemu
    operacyjnego. DTrace pozwala na zgłębianie systemu operacyjnego i zasad
    jego działania, szukanie problemów wydajnościowych w poprzek różnych
    warstw oprogramowania i szukanie przyczyn nieprawidłowego zachowania. Jak
    się okaże, DTrace umożliwia tworzenie własnych programów do dynamicznej
    instrumentalizacji systemu i udzielenie natychmiastowej, dokładnej
    odpowiedzi na konkretne pytania, które możńa zadać za pomocą języka
    skryptowego D. Pierwszy podrozdział jest szybkim wprowadzeniem do DTrace'a
    i pokazuje jak napisać pierwszy d-program. Reszta rozdziału przedstawia
    kompletny zestaw reguł programowania w języku D oraz wskazówki i techniki
    wykonywania dogłebnej analizy systemu. Swoimi doświadczeniami z DTrace
    można podzielić się na stronie społeczności DTrace <ulink type="text"
    url="http://www.sun.com/bigadmin/content/dtrace/">http://www.sun.com/bigadmin/content/dtrace/</ulink>.
    Wszystkie prezentowane w podręczniku skrypty można znaleźć w katalogu
    <filename>/usr/demo/dtrace</filename>.</para>
  </highlights>

  <sect1 id="chp-intro-1">
    <title>Getting Started</title>

    <para>DTrace pomaga zrozumieć system przez umożliwienie dynamicznego
    modyfikowania jądra systemu operacyjnego i procesów użytkownika tak, aby
    zapisywały dodatkowe wskazane dane w wybranych miejscach zwanych
    <firstterm>sondami (ang. probes)</firstterm>. Sonda jest miejscem lub
    działaniem, do którego DTrace może podpiąć żądanie wyknania zestawu
    <firstterm>akcji (ang. actions)</firstterm>, na przykład zapisanie śladu
    stosu (ang. stack trace), znacznika czasu (ang. timestamp) lub argumentu
    funkcji. Sondy są niczym programowalne czujniki rozmieszczone w całym
    systemie operacyjnym Solaris. Jeśli trzeba dowiedzieć się, co się dzieje,
    można użyć DTrace'a do zaprogramowania odpowiedniej sondy aby zapisała
    interesujące informacje. Kiedy sonda <firstterm>odpala
    (ang. fires)</firstterm> DTrace zbiera dane z sondy i zwraca do skryptu.
    Jeśli dla sondy nie zdefiniowano akcji, DTrace po prostu zanotuje czas
    odpalenia sondy.</para>

    <para>Każda sonda w DTrace ma dwie nazwy: inukalny identyfikator
    numeryczny oraz łatwą do zapamiętania dla ludzi nazwę literową. Nauka
    DTrace'a rozpocznie się od pisania prostych żądań za pomocą sondy o nazwie
    <literal>BEGIN</literal>, która odpali za każdym razem gdy rozpocznie się
    nowe żądanie śledzenia. Aby użyć sondy z jej imieniem należy wykonać
    komendę <olink remap="external" targetdoc="refman1m"
    targetptr="dtrace-1m"><citerefentry>
        <refentrytitle>dtrace</refentrytitle>

        <manvolnum>1M</manvolnum>
      </citerefentry></olink> z opcją <option>n</option>. Na przykład:</para>

    <screen><userinput># dtrace -n BEGIN</userinput></screen>

    <para>Po krótkim oczekiwaniu DTrace napisze, że jedna sonda została
    włączona a za chwilę pojawi się linia informująca, że sonda
    <literal>BEGIN</literal> odpaliła. Po wydrukowaniu tej linii
    <command>dtrace</command> oczekuje na odpalenie następnej sondy.
    Uruchomiona została tylko sonda <literal>BEGIN</literal>, a ona odpala
    tylko raz, należy więc wcisnąć Control-C w powłoce
    <command>dtrace</command> aby powrócić do linii poleceń:</para>

    <screen><userinput># dtrace -n BEGIN</userinput>
dtrace: description 'BEGIN' matched 1 probe
CPU     ID		      FUNCTION:NAME
  0      1                  :BEGIN
<userinput>^C</userinput>
#</screen>

    <para>Wydruk informuje, że sonda <literal>BEGIN</literal> odpaliła raz,
    podaje także nazwę sondy oraz jej indentyfikator liczbowy 1. Należy
    zauważyć, że domyślnie drukowany jest identyfikator liczbowy procesora, na
    któreym odpaliła sonda. W powyższym przykładzie komenda
    <command>dtrace</command> wykonywała się na procesorze 0 w momencie
    odpalenia sondy.</para>

    <para>Żądania DTrace można konstruować z dowolnej liczby sond i akcji.
    Poniżej skonstruowane jest żądanie składające się z dwóch sond, przez
    dodanie sondy <literal>END</literal> do poprzedniego przykłądu. Sonda
    <literal>END</literal> odpala raz, kiedy śledzenie skończy się. Poniższe
    należy wpisać w linii poleceń, a po wydrukowaniu linii informującej o
    odpaleniu <literal>BEGIN</literal>, należy wcisnąć Control-C:</para>

    <screen><userinput># dtrace -n BEGIN -n END</userinput>
dtrace: description 'BEGIN' matched 1 probe
dtrace: description 'END' matched 1 probe
CPU     ID		      FUNCTION:NAME
  0      1                  :BEGIN
<userinput>^C</userinput>
  0      2                    :END
#</screen>

    <para>Jak widać, wyjście z <command>dtrace</command> przez Control-C
    odpala sondę <literal>END</literal>. <command>dtrace</command> informuje o
    odpaleniu tej sondy zaraz przed zakończeniem działania.</para>

    <para>Po wprowadzeniu do nazewnictwa i włączania sond nadszedł czas na
    DTrace'ową wersję pierwszego programu w każdym języku programowania,
    “Hello, World.” Oprócz tworzenia wyrażeń w linii poleceń, można umieszczać
    je w pliku tesktowym z użyciem języka skryptowego D. W edytorze tekstowym
    należy stworzyć nowy plik nazwany <filename>hello.d</filename> i uzupełnić
    treścią:</para>

    <example id="ex-hello.d">
      <title><filename>hello.d</filename>: Hello, World from the D Programming
      Language</title>

      <programlisting>BEGIN
{
	trace("hello, world");
	exit(0);
}</programlisting>
    </example>

    <para>Po zapisaniu pliku ze skryptem można go wykonać za pomocą komendy
    <command>dtrace</command> <option>s</option>:</para>

    <screen><userinput># dtrace -s hello.d</userinput>
dtrace: script 'hello.d' matched 1 probe
CPU     ID		      FUNCTION:NAME
  0	    1                  :BEGIN   hello, world
#</screen>

    <para>Jak widać, <command>dtrace</command> wydrukwał takie samo wyjście
    jak poprzednio a zaraz później tekst “<computeroutput>hello,
    world</computeroutput>”. W przeciwieństwie do poprzedniego przykładu, tym
    razem nie trzeba czekać a później wydawać komendy Control-C. Wynikło to z
    faktu wskazania <firstterm>actions</firstterm> sondzie
    <literal>BEGIN</literal> w <filename>hello.d</filename>. Czas zapoznać się
    ze strukturą d-programu, aby lepiej zrozumieć, co się stało.</para>

    <para>Każdy d-program składa się z serii <firstterm>klauzul
    (ang. clauses)</firstterm>, a każda klauzula definiuje jedną lub więcej
    sond do włączenia oraz ewentualne akcje do podjęcia w momencie odpalenia
    sondy. Akcje są definiowane w postaci listy wyrażeń zamkniętych w klamrach
    <literal>{ }</literal> po nazwie sondy. Każde wyrażenie zakończone jest
    średnikiem (<literal>;</literal>). Pierwsze wyrażenie używa funkcji
    <function>trace</function> w celu nakazania DTrace'owi zapisywanie
    wystąpnienia wskazanego wyrażenia “<literal>hello, world</literal>” po
    odpaleniu sondy <literal>BEGIN</literal> i wydrukowanie wyniku na
    standardowe wyjście. Drugie wyrażenie używa funkcji
    <function>exit</function> do powiadomienia DTrace'a, że powinien przerwać
    śledzenie i zakończyć wykonywanie komendy <command>dtrace</command>.
    DTrace zawiera zestaw przydatnych funkcji, takich jak
    <function>trace</function> i <function>exit</function>, które można
    wywoływać z d-programu. Funkcję wywołuje się przez podanie jej nazwy i
    listy argumentów w nawiasach okrągłych. Kompletna lista funkcji DTrace'a
    jest przedstawiona w <olink remap="internal"
    targetptr="chp-actsub">Chapter 10, Actions and Subroutines</olink>.</para>

    <para>Najwyższy czas na spostrzeżenie oparte o nazwy funkcji z powyższych
    akapitów, że język D jest bardzo podobny do C. Faktycznie, D wywodzi się z
    dużego podzbioru C powiązanego ze specjalnymi funkcjami i zmiennymi, które
    ułatwiają śledzenie. W następnych rozdziałach dokładniej przedstawiono te
    funkcje i zmienne. Nawet osoba, która nigdy nie programowała w C powinna z
    łatwościa nauczyć się pisać programy w D. Pod koniec rozdziału czytelnik
    powinien opanować całą składnię. Najpierw jednak trzeba cofnąć się o krok
    i przyjrzeć działaniu DTrace'a. Na naukę bardziej interesujących
    d-programów przyjdzie jeszcze czas.</para>
  </sect1>

  <sect1 id="chp-intro-2">
    <title>Providers and Probes</title>

    <para>W poprzednich przykładach przedstawiono użycie sond
    <literal>BEGIN</literal> i <literal>END</literal>. Skąd pochodzą te sondy?
    Sondy DTrace'a pochodzą z zestawu modułów jądra nazywanych
    <firstterm>dostawcami (ang. providers)</firstterm>, każdy z nich wykonuje
    pewną instrumentalizację w celu stworzenia sond. Podczas używania DTrace'a
    każdy dostawca ma okazję opublikować sondy dla DTrace'a. Użytkownik może
    wtedy wiązać akcje śledzące do dowolnej opublikowanej sondy. Kompletną
    listę sond dostępnych w systemie można uzyskać komendą:</para>

    <screen><userinput># dtrace -l</userinput>
  ID   PROVIDER            MODULE          FUNCTION NAME
   1     dtrace                                     BEGIN
   2     dtrace                                     END
   3     dtrace                                     ERROR
   4   lockstat           genunix       mutex_enter adaptive-acquire
   5   lockstat           genunix       mutex_enter adaptive-block
   6   lockstat           genunix       mutex_enter adaptive-spin
   7   lockstat           genunix       mutex_exit  adaptive-release

   <phrase>... many lines of output omitted ...</phrase>

#</screen>

    <para>Wydrukowanie pełnej listy może zająć trochę czasu. Podliczenie
    wszystkich sond można wykonać komendą:</para>

    <screen><userinput># dtrace -l | wc -l</userinput>
        30122</screen>

    <para>Liczba ta może różnić się, ponieważ zależy od platformy sprzętowej i
    zainstalowanego oprogramowania. Widać jednak z powyższego, że dostępna
    jest spora liczba sond, dzięki którym można zajrzeć we wszystkie,
    wcześniej niedostępne, zakamarki systemu. Nawet ta lista nie jest
    kompletna, ponieważ, jak się okaże później, niekórzy dostawcy umożliwiają
    tworzenie własnych sond w trakcie wykonywania programu, opartych o wyniki
    śledzenia, co sprawia, że liczba sond jest praktycznie
    nieograniczona.</para>

    <para>Przyjrzyjmy się wydrukowi komendy <userinput>dtrace -l</userinput>.
    Każda sonda ma dwie nazwy, o czym wcześniej wspominano, identyfikator
    liczbowy oraz łatwą do zapamiętania nazwę. Ta druga nazwa składa się z
    czterech elementów pokazanych jako cztery kolumny w wydruku
    <command>dtrace</command>. Ta czwórka to:</para>

    <informaltable frame="none">
      <tgroup cols="2" colsep="0" rowsep="0">
        <colspec colwidth="1.00in" />

        <colspec colwidth="4.00in" />

        <tbody>
          <row>
            <entry><para>Dostawca (ang. provider)</para></entry>

            <entry><para>Nazwa dostawcy DTrace publikującego sondę. Zazwyczaj
            nazwa dostawcy odnosi się do nazwy modułu jądra wykonującego
            instrumentalizację na rzecz sondy.</para></entry>
          </row>

          <row>
            <entry><para>Moduł (ang. module)</para></entry>

            <entry><para>Jeśli sonda odpowiada konkretnemu miejscu w
            programie, jest to nazwa modułu, w którym znajduje się sonda. Jest
            to albo nazwa modułu jądra, albo nazwa biblioteki
            użytkowej.</para></entry>
          </row>

          <row>
            <entry><para>Funkcja (ang. function)</para></entry>

            <entry><para>Jeśli sonda odpowiada konkretnemu miejscu w
            programie, jest to nazwa funkcji, w której znajduje się
            sonda.</para></entry>
          </row>

          <row>
            <entry><para>Nazwa (ang. name)</para></entry>

            <entry><para>Ostatnim elementem nazwy jest nazwa sondy wsjazująca
            na jej zastosowanie, na przykład <literal>BEGIN</literal> albo
            <literal>END</literal>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Łatwą do zapamiętania nazwę zapisuje się podając całą
    czwórkę:</para>

    <para><replaceable>dostawca</replaceable>:<replaceable>moduł</replaceable>:<replaceable>funkcja</replaceable>:<replaceable>nazwa</replaceable></para>

    <para>Niektóre nazwy sond na liście nie mają części modułu i funkcji, na
    przykład <literal>BEGIN</literal> i <literal>END</literal>. Dla niektórych
    sond te dwa pola są puste, ponieważ sondy te nie odpowiadają żadnemu
    konkretnemu modułowi ani funkcji. Odpowiadają natomiast bardziej
    abstrakcyjnym pojęciom, jak koniec żądania śledzenia. Sonda z pełną nazwą
    określana jest jako <firstterm>sonda osadzona (ang. anchored
    probe)</firstterm> a sonda bez tych elementów nazwy określana jest
    jako<firstterm> sonda nieosadzona (ang. unanchored)</firstterm>.</para>

    <para>Zwyczajowo, jeśli któreś z pól nazwy nie zostanie podane, wtedy
    DTrace dopasowuje żądanie do <emphasis>wszystkich</emphasis> sond, które
    pasują do wyrażenia. Innymi słowy używając nazwy <literal>BEGIN</literal>
    instruuje się DTrace, aby dopasował każdą sondę, której pole nazwy równe
    jest <literal>BEGIN</literal>, niezależnie od zawartości pól dostawcy,
    modułu i funkcji. W tym przypadku tylko jedna sonda pasuje do żądania,
    więc wynik jest jeden. Warto jednak wiedzieć, że właściwa nazwa sondy
    <literal>BEGIN</literal> brzmi <literal>dtrace:::BEGIN</literal>, co
    wskazuje, że sonda dostarczona jest bezpośrednio prze DTrace'a i nie jest
    osadzona w żadnej funkcji. Stąd program <filename>hello.d</filename> można
    by zapisać jak poniżej bez zmiany wyniku działania:</para>

    <programlisting>dtrace:::BEGIN
{
	trace("hello, world");
	exit(0);
}</programlisting>

    <para>Po tym wprowadzeniu do nazewnictwa sond oraz ich pochodzenia czas
    przejść do omówienia uruchamiania sond i wykonywania zdań przez DTrace.
    Później przyjdzie czas na przegląd języka D.</para>
  </sect1>

  <sect1 id="chp-intro-3">
    <title>Compilation and Instrumentation</title>

    <para>Przy pisaniu tradycyjnych programów w Solarisie, kod źródłowy
    przekształca się do postaci wykonywalnej za pomocą kompilatora. Komenda
    <command>dtrace</command> jest takim kompilatorem dla języka D użytego do
    napisania programu <filename>hello.d</filename>. Po skompilowaniu program
    przekazywany jest jądru systemu operacyjnego do wykonania przez DTrace. W
    jądrze sondy nazwane w programie zostają włączone a odpowiedni dostawca
    wykonuje wszelką instrumentację konieczną do ich uruchomienia.</para>

    <para>Wszelka instrumentacja DTrace jest całkowicie dynamiczna: sondy są
    dyskretnie włączane tylko wtedy, kiedy są używane. Dla niekatywnych sond
    nie ma żadnego załadowanego kodu, więc gdy DTrace nie jest używany, system
    nie podlega żadnemu obniżeniu wydajności. Po zakończeniu eksperymentu,
    kiedy komenda <command>dtrace</command> zakończy działanie, wszystkie
    używane sondy są wyłączane, ich instrumentacja jest usuwana a system wraca
    do swojego stanu sprzed instrumentacji. Nie ma żadnej różnicy między
    systemami, na których DTrace nie jest używany a takimi, na których nie
    został zainstalowany.</para>

    <para>Instrumentacja dla każdej sondy wykonywana jest dynamicznie na żywym
    systemie lub wybranym procesie użytkownika. System nie jest w żaden sposób
    zatrzymywany na ten czas, a kod instrumentacyjny dodawany jest tylko dla
    wskazanych sond. Dzięki temu wpływ sond DTrace jest ograniczony ściśle do
    obszarów wskazanych w d-skrypcie: nie są śledzone żadne dodatkowe dane,
    nie jest przełączany żaden globalny "przełącznik śledzenia" a cały kod
    instrumentacji jest zaprojektowany aby był maksymalnie wydajny. Pozwala to
    na używanie DTrace'a w systemach produkcyjnych do rozwiązywania
    prawdziwych problemów w czasie ich występowania.</para>

    <para>DTrace umie obsłużyć nieograniczoną liczbę wirtualnych klientów.
    Ilość wykonywanych równocześnie eksperymentów i komend DTrace'a
    ograniczona jest wyłącznie przez ilość pamięci w systemie, a wszystkie
    komendy pracują niezależnie na tej samej instrumentacji. Pozwala to na
    równoczesne używanie DTrace'a przez nieograniczoną liczbę użytkowników:
    administratorzy, programiści, obsługa systemu mogą pracować równocześnie
    nad tym samym lub odrębnymi problemami na tym samym systemie bez
    wchodzenia sobie wzajemnie w drogę.</para>

    <para>Inaczej niż programy napisane w C lub C++ i podobnie jak programy
    napisane w <trademark>Javie</trademark>, d-skrytpy DTrace kompilowane są
    do bezpiecznego pośredniego kodu wykonywanego kiedy sonda odpala. Ten
    pośredni kod jest sprawdzany pod względem bezpieczeństwa kiedy
    oprogramowanie DTrace jądra po raz pierwszy ocenia program. Środowisko
    wykonywania DTrace obsługuje również wszystkie błędy czasu wykonania,
    które mogą się pojawić podczas wykonywania programu, takie jak dzielenie
    przez zero, dereferencja niepoprawnego adresu pamięci i tak dalej a także
    przekazuje je użytkownikowi. Dzięki temu napisanie niebezpiecznego
    programu zdolnego nieodwracalnie uszkodzić jądro lub proces jest
    niemożliwe. Takie zabezpieczenia pozwalają na swoibidne korzystanie z
    DTrace'a w środowiskach produkcyjnych bez ryzyka zatrzymania systemu lub
    jego uszkodzenia. Jeśli program zawiera bład, DTrace zwróci informację o
    błędzie i zatrzyma wykonywanie skryptu, co pozwoli poprawić go przed
    ponowną próbą. Opcje raportowania błędów i debuggowania DTrace są opisane
    w późniejszych rozdziałach.</para>

    <para>Poniższy diagram pokazuje różne elementy architektury DTrace,
    włączając w to dostawców, sondy, oprogramownie DTrace w jądrze i komendę
    <command>dtrace</command>.</para>

    <figure id="chapter1-fig-1">
      <title>Overview of the DTrace Architecture and Components</title>

      <mediaobject>
        <imageobject>
          <imagedata entityref="architecture" />
        </imageobject>

        <textobject>
          <simpara>Architektura DTrace: warstwa w jądrze, dostawcy, interfejs
          sterownika jądra dla biblioteki i biblioteka zawierająca zestaw
          komend.</simpara>
        </textobject>
      </mediaobject>
    </figure>

    <para>Po wyjaśnieniach dotyczących działania DTrace nadszedł czas na
    dalszy ciąg nauki języka D i pisanie ciekawszych niż poprzednio
    programów.</para>
  </sect1>

  <sect1 id="chp-intro-4">
    <title>Variables and Arithmetic Expressions</title>

    <para>Następny przykład skorzysta z dostawcy DTrace
    <literal>profile</literal> do implementacji prostego licznika opartego o
    czas. Dostawca profile umie tworzyć nowe sondy z opisu zawartego w
    d-skrypcie. Jeśli stworzona zostanie sonda
    <literal>profile:::tick-</literal><replaceable>n</replaceable><literal>sec</literal>
    dla jakiejś liczby całkowitej <replaceable>n</replaceable>, deostawca
    profile stworzy sondę, która będzie odpalana co
    <replaceable>n</replaceable> sekund. Poniższy kod pochodzi z pliku
    <filename>counter.d</filename>:</para>

    <programlisting>/*
 * Count off and report the number of seconds elapsed
 */
dtrace:::BEGIN
{
	i = 0;
}

profile:::tick-1sec
{
	i = i + 1;
	trace(i);
}

dtrace:::END
{
	trace(i);
}</programlisting>

    <para>Podczas wykonywania program odlicza mijające sekundy aż do
    naciśnięcia Control-C, wtedy zaś kończy działanie i drukuje końcową
    wartość licznika:</para>

    <screen><userinput># dtrace -s counter.d</userinput>
dtrace: script 'counter.d' matched 3 probes
CPU     ID                    FUNCTION:NAME
  0  25499                       :tick-1sec         1
  0  25499                       :tick-1sec         2
  0  25499                       :tick-1sec         3
  0  25499                       :tick-1sec         4
  0  25499                       :tick-1sec         5
  0  25499                       :tick-1sec         6
<userinput>^C</userinput>
  0      2                             :END         6
#</screen>

    <para>Pierwsze trzy linijki programu to komentarz wyjaśniający
    przeznaczenie programu. Podobnie jak w językach C, C++ i Java kompilator D
    ignoruje znaki między symbolami <literal>/*</literal> i
    <literal>*/</literal>. Komentarzy można używać w dowolnym miejscu w
    programie D, zarówno wewnątrz i na zewnątrz klauzul z sondami.</para>

    <para>Sonda <literal>BEGIN</literal> definiuje zmienną nazwaną
    <literal>i</literal> i przypisuje jej wartość całkowitą zero w poniższym
    wyrażeniu:</para>

    <programlisting>i = 0;</programlisting>

    <para>Inaczej niż w językach C, C++ i Java zmienne D można tworzyć po
    prostu przez użycie ich w wyrażeniu w programie; nie są wymagane wyrażenia
    służące bezpośrednio deklaracji zmiennych. Kiedy zmienna zostaje po raz
    pierwszy użyta w programie, jej typ jest określany na podstawie pierwszego
    przypisania wartości. Każda zmienna może mieć tylko jeden typ przez cały
    czas trwania programu, dlatego następne wykorzystania muszą być zgodne z
    typem pierwszego przypisania. W <filename>counter.d</filename> zmienna
    <literal>i</literal> jest inicjowana wartością zero, zatem jej typ
    ustalony jest na <literal>int</literal>. Język D ma te same typy
    podstawowe, co język C, włącznie z:</para>

    <informaltable frame="none">
      <tgroup cols="2" colsep="0" rowsep="0">
        <colspec colname="colspec0" colwidth="0.57*" />

        <colspec colname="colspec1" colwidth="1.43*" />

        <tbody>
          <row>
            <entry><para><literal>char</literal></para></entry>

            <entry><para>Character or single byte integer</para></entry>
          </row>

          <row>
            <entry><para><literal>int</literal></para></entry>

            <entry><para>Default integer</para></entry>
          </row>

          <row>
            <entry
            colname="colspec0"><para><literal>short</literal></para></entry>

            <entry colname="colspec1"><para>Short integer</para></entry>
          </row>

          <row>
            <entry><para><literal>long</literal></para></entry>

            <entry><para>Long integer</para></entry>
          </row>

          <row>
            <entry><para><literal>long long</literal></para></entry>

            <entry><para>Extended long integer</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Wielkości tych typów zależą od modelu danych w jądrze, co opisano w
    <olink remap="internal" targetptr="chp-typeopexpr">Chapter 2, Types,
    Operators, and Expressions</olink>. D obsługuje też wbudowane przyjazne
    nazwy dla różnych wielokości typów całkowitych ze znakiem i bez znaku oraz
    tysiące innych typów definiowanych przez system oepracyjny.</para>

    <para>Centralnym elementem skryptu <filename>counter.d</filename> jest
    klauzla sondy zwiększająca wartość <literal>i</literal>:</para>

    <programlisting>profile:::tick-1sec
{
	i = i + 1;
	trace(i);
}</programlisting>

    <para>Klauzula nazywa sondę <literal>profile:::tick-1sec</literal>, dzięki
    czemu dostawca <literal>profile</literal> wie, że ma stworzyć nową sondę
    odpalającą raz na sekundę na dostęonym procesorze. Klauza zawiera dwa
    wyrażenia, pierwsze przypisujące zmiennej <literal>i</literal> jej
    poprzednią wartość zwiększoną o jeden, a drugie rozpoczynające śledzenie
    nowej wartości zmiennej <literal>i</literal>. Wszystkie typowe operatory
    arytmetyczne z języka C dostępne są w języku D; kompletna lista
    przedstawiona jest w <olink remap="internal"
    targetptr="chp-typeopexpr">Chapter 2, Types, Operators, and
    Expressions</olink>. Tak samo jak w C do zwiększenia wartości zmiennej o
    jeden można użyć operatora <literal>++</literal>. Funkcja
    <function>trace</function> przyjmuje jako argument dowolne wyrażenie D,
    można więc zwięźlej zapisać <filename>counter.d</filename> jak
    poniżej:</para>

    <programlisting>profile:::tick-1sec
{
	trace(++i);
}</programlisting>

    <para>Jeśli wymagana jest ścisła kontrola typu zmiennej
    <literal>i</literal>, jej pożądany typ można ująć w nawias okrągły i w ten
    spoób <firstterm>rzutować (ang. cast)</firstterm> na typ całkowity zero
    inny typ danych. Na przykład, gdyby chcieć określic maksymalny rozmiar
    typu <literal>char</literal> w języku D, można zmienić klauzulę
    <literal>BEGIN</literal> w następujący sposób:</para>

    <programlisting>dtrace:::BEGIN
{
	i = (char)0;
}</programlisting>

    <para>Po jakimś czasie wykonywania programu <filename>counter.d</filename>
    śledzona zmienna powinna osiągnąć maksymalną wartość i zostać przekręcona
    do zera. Jeśli zwiększanie wartości zmiennej trwa za długo, można nazwać
    sondę dostawcy <literal>profile</literal> na
    <literal>profile:::tick-100msec</literal>, co spowoduje zwiększanie
    wartości o jeden co 100 milisekund, czyli 10 razy na sekundę.</para>
  </sect1>

  <sect1 id="chp-intro-5">
    <title>Predicates</title>

    <para>Jedną sporą różnicą między językami C, C++ i Java a językiem D jest
    brak instrukcji kontroli przepływu, takich jak if i pętle. D-programy są
    liniowym zapisem wyrażeń, które śledzą ewentualne opcjonalne i określone
    ilości danych. Język D pozwala na warunkowe śledzenie danych i kontrolę
    przepływu danych przy użyciu wyrażeń logicznych nazwanych
    <firstterm>predykatami (ang. predicates)</firstterm>, którymi można
    poprzedzać kaluzule programu. Wynik wyrażenia predykatywnego jest
    sprawdzany w momencie odpalania sondy przed wykonaniem jakichkolwiek
    wyrażeń związanych z odpowiednią sondą. Jeśli wyrażenie jest prawdziwe (w
    reprezentacji liczbowej wartość niezerowa), to lista wyrażeń związanych z
    sondą jest wykonywana. Jeśli wynik predykatu jest nieprawdą (w
    reprezentacji liczbowej wartość zerowa), to odpalenie sondy jest
    ignorowane i żadne z jej wyrażeń nie jest wykonywane.</para>

    <para>Poniższy kod źródłowy pochodzi z pliku
    <filename>countdown.d</filename>:</para>

    <programlisting>dtrace:::BEGIN
{
	i = 10;
}

profile:::tick-1sec
/i &gt; 0/
{
	trace(i--);
}

profile:::tick-1sec
/i == 0/
{
	trace("blastoff!");
	exit(0);
}</programlisting>

    <para>Ten d-program implementuje licznik dziesięciosekundowy za pomocą
    predykatów. Podczas wykonania skrypt <filename>countdown.d</filename>
    zlicza sekundy aż do 10, drukuje wiadmość i kończy działanie:</para>

    <programlisting># dtrace -s countdown.d
dtrace: script 'countdown.d' matched 3 probes
CPU     ID                    FUNCTION:NAME
	0  25499                       :tick-1sec        10
	0  25499                       :tick-1sec         9
	0  25499                       :tick-1sec         8
	0  25499                       :tick-1sec         7
	0  25499                       :tick-1sec         6
	0  25499                       :tick-1sec         5
	0  25499                       :tick-1sec         4
	0  25499                       :tick-1sec         3
	0  25499                       :tick-1sec         2
	0  25499                       :tick-1sec         1
	0  25499                       :tick-1sec   blastoff!
# </programlisting>

    <para>W tym przykładzie wykorzystano sondę <literal>BEGIN</literal> do
    zainicjalizowania zmiennej całkowitej <literal>i</literal> wartością 10 w
    celu rozpoczęcia odliczania. Następnie, jak poprzednio, w programie
    zaimplementowane licznik cosekundowy za pomocą sondy
    <literal>tick-1sec</literal>. Należy zauważyć, że w
    <filename>countdown.d</filename> sonda <literal>tick-1sec</literal>
    pojawia się w dwóch klauzulach, z których każda ma swój predykat i listę
    akcji. Predykat jest wyrażeniem logicznym zamkniętym w linie ukośne
    <literal>/ /</literal> i pojawia się po nazwie sondy, ale przed klamrą
    <literal>{ }</literal> zamykającą klauzulę z listą wyrażeń.</para>

    <para>Pierwszy predykat sprawdza, czy <literal>i</literal> jest większe od
    zera, co oznacza, że licznik wciąż odlicza:</para>

    <programlisting>profile:::tick-1sec
/i &gt; 0/
{
	trace(i--);
}</programlisting>

    <para>Operator <literal>&gt;</literal> oznacza <emphasis>większe
    niż</emphasis> i zwraca zero dla nieprawdzy i jeden dla prawdy. Język D
    zawiera wszystki operatory relacyjne z języka C; kompletną listę
    wydrukowano w <olink remap="internal"
    targetptr="chp-typeopexpr">Chapter 2, Types, Operators, and
    Expressions</olink>. Jeśli <literal>i</literal> nie jest jeszcze równe
    zero, skrypt śledzi wartość zmiennej <literal>i</literal> i zmniejsza ją o
    jeden używając operatora <literal>--</literal>.</para>

    <para>Drugi predykat używa oepratora <literal>==</literal> zwraicającego
    prawdę, jeśli <literal>i</literal> jest równa zero, co oznacza, że
    odliczanie zostało zakończone:</para>

    <programlisting>profile:::tick-1sec
/i == 0/
{
	trace("blastoff!");
	exit(0);
}</programlisting>

    <para>Podobnie jak w pierwszym przykładzie skrypt
    <filename>countdown.d</filename> używa sekwencji znaków zamkniętych w
    cudzysłowie, zwnacych stałą łańcuchową, do drukowania wiadomości o
    zakończeniu odliczania. Funkcja <function>exit</function> powoduje wyjście
    z <command>dtrace</command> i powrót do powłoki.</para>

    <para>Po przyjdrzeniu się skryptowi <filename>countdown.d</filename> łatwo
    zauważyć, że zapisując dwie klauzule z tą samą sondą ale z innymi
    predykatami i akcjami, stworzono następujący przepływ logiczny:</para>

    <literallayout>i = 10
raz na sekundę,
	jeśli i jest większe niż zeo
		trace(i--);
	innym przypadku jeśli i równe jest zero
		trace("blastoff!");
		exit(0);</literallayout>

    <para>Podczas pisania skomplikowanmych programów z użyciem predykatów
    wskazane jest takie właśnie zwizualizowanie algorytmu i późniejsze
    przekształcenie fragmentów w osobne klauzule i predykaty.</para>

    <para>Nadszedł czas na połączenie predykatów z nowym dostawcą
    <literal>syscall</literal> i stworzenie pierwszego prawdziwego programu
    wykonującego śledzenie. Dostyawca <literal>syscall</literal> umożliwia
    odpalenie sond podczas wchodzenia i wychodzenia z dowolnego wywołania
    systemowego systemu operacyjnego Solaris. W następnym przykładzie użyto
    DTrace'a do obserwacji każdego wywołania <olink remap="external"
    targetdoc="refman2" targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i <olink remap="external" targetdoc="refman2"
    targetptr="write-2"><citerefentry>
        <refentrytitle>write</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> przez powłoke użytkownika. Najpierw należy
    otworzyć dwa okna terminala; jedno posłuży do wykonywania skyrptu
    DTrace'a, drugie do wykonania śledzonego procesu. W drugim oknie należy
    wykonać następującą komendę w celu uzyskania PID (numeru procesu)
    powłoki:</para>

    <screen><userinput># echo $$</userinput>
12345</screen>

    <para>W pierwszym oknie należy wpisać do pliku <filename>rw.d</filename>
    następujący skrypt. Podczas wpisywania programu ciąg cyfr
    <literal>12345</literal> należy zamianić na PID procesu powłoki uzyskany
    wcześniej komendą <command>echo</command>.</para>

    <programlisting>syscall::read:entry,
syscall::write:entry
/pid == 12345/
{

}</programlisting>

    <para>Ciało klauzuli sondy <filename>rw.d</filename> jest puste, ponieważ
    skrypt ma tylko śledzić tylko odpalanie sond i nie śledzi żadnych
    dodatkowych danych. Po zapisaniu skryptu w pliku <filename>rw.d</filename>
    należy wywołać go komendą <command>dtrace</command> i w drugim oknie
    wykonać kilka komend. Podczas wykonywania komend <command>dtrace</command>
    będzie informował w pierwszym oknie o każdym odpaleniu sondy, jak w
    przykładzie poniżej:</para>

    <screen><userinput># dtrace -s rw.d</userinput>
dtrace: script 'rw.d' matched 2 probes
CPU     ID                    FUNCTION:NAME
	0     34                      write:entry 
	0     32                       read:entry 
	0     34                      write:entry 
	0     32                       read:entry 
	0     34                      write:entry 
	0     32                       read:entry 
	0     34                      write:entry 
	0     32                       read:entry 
...</screen>

    <para>W tym momencie obserwowane są wywołania systemowe <olink
    remap="external" targetdoc="refman2" targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i <olink remap="external" targetdoc="refman2"
    targetptr="write-2"><citerefentry>
        <refentrytitle>write</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> służące odczytowi znaków z okna terminala i
    drukowania wyników działania wpisywanych komend! Przykład ten wykorzystuje
    wiele opisanych wcześniej elementów języka D oraz kilka nowych. Do
    instrumentalizacji wywołań <olink remap="external" targetdoc="refman2"
    targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i <olink remap="external" targetdoc="refman2"
    targetptr="write-2"><citerefentry>
        <refentrytitle>write</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> w ten sam spoób skrypt używa jednej klauzuli
    sondy z wieloma opisami sond oddzielonymi przecinkami, jak poniżej:</para>

    <programlisting>syscall::read:entry,
syscall::write:entry</programlisting>

    <para>W trosce o czytelność każdą sondę umieszczono w odrębnym wierszu.
    Nie jest to wymóg, ale poprawia czytelność kodu. Następnie skrypt
    definiuje predykat dopasowujący tylko te wywołania systemowe, ktorę są
    wykonywane przez proces powłoki użytkownika:</para>

    <programlisting>/pid == 12345/</programlisting>

    <para>W predykacie użyto wbudowanej w język zmiennej
    <literal>pid</literal>, która zawsze zawiera PID wątku, dla którego
    odpaliła sonda. DTrace zawiera wiele wbudowanych zmiennych służących
    uzyskaniu pożytecznych informacji, jak na przykład numer identyfikacyjny
    procesu. Poniżej przedstawiono listę kilku takich zmiennych do
    wykorzystania w d-skryptach:</para>

    <informaltable frame="topbot">
      <tgroup cols="3" colsep="0" rowsep="1">
        <colspec colname="colspec2" colwidth="27.37*" />

        <colspec colname="colspec3" colwidth="21.16*" />

        <colspec colname="colspec4" colwidth="50.47*" />

        <thead>
          <row>
            <entry rowsep="1"><para>Nazwa zmiennej</para></entry>

            <entry rowsep="1"><para>Typ danych</para></entry>

            <entry rowsep="1"><para>Znaczenie</para></entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry rowsep="0"><para><literal>errno</literal></para></entry>

            <entry rowsep="0"><para><literal>int</literal></para></entry>

            <entry rowsep="0"><para>Aktualna wartość <literal>errno</literal>
            dla wywołań systemowych</para></entry>
          </row>

          <row>
            <entry rowsep="0"><para><literal>execname</literal></para></entry>

            <entry rowsep="0"><para><literal>string</literal></para></entry>

            <entry rowsep="0"><para>Nazwa aktualnego pliku wykonywalnego dla
            procesu</para></entry>
          </row>

          <row>
            <entry rowsep="0"><para><literal>pid</literal></para></entry>

            <entry rowsep="0"><para><literal>pid_t</literal></para></entry>

            <entry rowsep="0"><para>PID aktualnego procesu</para></entry>
          </row>

          <row>
            <entry rowsep="0"><para><literal>tid</literal></para></entry>

            <entry rowsep="0"><para><literal>id_t</literal></para></entry>

            <entry rowsep="0"><para>Identyfikator aktualnego
            wątku</para></entry>
          </row>

          <row>
            <entry
            rowsep="0"><para><literal>probeprov</literal></para></entry>

            <entry rowsep="0"><para><literal>string</literal></para></entry>

            <entry rowsep="0"><para>Pole dostawcy aktualnej
            sondy</para></entry>
          </row>

          <row>
            <entry rowsep="0"><para><literal>probemod</literal></para></entry>

            <entry rowsep="0"><para><literal>string</literal></para></entry>

            <entry rowsep="0"><para>Pole modułu aktualnej sondy</para></entry>
          </row>

          <row>
            <entry
            rowsep="0"><para><literal>probefunc</literal></para></entry>

            <entry rowsep="0"><para><literal>string</literal></para></entry>

            <entry rowsep="0"><para>Pole funkcji aktualnej
            sondy</para></entry>
          </row>

          <row>
            <entry colname="colspec2"
            rowsep="0"><para><literal>probename</literal></para></entry>

            <entry colname="colspec3"
            rowsep="0"><para><literal>string</literal></para></entry>

            <entry colname="colspec4" rowsep="0"><para>Pole nazwy aktualnej
            sondy</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Czas na kilka eksperymentów z właśnie napisanym skryptem; można
    zmieniać PID lub sondy wywołań systemowych. Jedna dodatkowa zmiana pozwoli
    na przekształcenie skryptu w bardzo prostą wersję narzędzia do śledzenia
    wywołań systemowych w rodzaju <olink remap="external" targetdoc="refman1"
    targetptr="truss-1"><citerefentry>
        <refentrytitle>truss</refentrytitle>

        <manvolnum>1</manvolnum>
      </citerefentry></olink>. Puste pole sondy w opisie sondy pozwoli na
    śledzenie dowolnego wywołania systemowego związanego ze śledzonym
    procesem:</para>

    <programlisting>syscall:::entry
/pid == 12345/
{

}</programlisting>

    <para>W przypadku skryptu z PID powłoki, należy wykonać po kolei kilka
    komend, na przykład <command>cd</command>, <command>ls</command> i
    <command>date</command>, co pozwoli w oknie DTrace'a obserwować wyniki
    śledzenia.</para>
  </sect1>

  <sect1 id="chp-intro-6">
    <title>Output Formatting</title>

    <para>Śledzenie wywołań systemowych jest wszechstronnym narzędziem
    obserwacji większości procesów przestrzeni użytkownika. Każdy kto miał
    okazję używać Solarisowego narzędzia <olink remap="external"
    targetdoc="refman1" targetptr="truss-1"><citerefentry>
        <refentrytitle>truss</refentrytitle>

        <manvolnum>1</manvolnum>
      </citerefentry></olink> jako administrator albo programista, z pewnością
    wie, że jest to cenne narzędzie i warto zawsze mieć je pod ręką. Warto
    zaznajomić się z nim i wpisać w linii poleceń:</para>

    <screen><userinput>$ truss date</userinput></screen>

    <para>Wydruk stanowi sformatowany wynik śledzenia wywołań systemowych
    wykonywanych przez <olink remap="external" targetdoc="refman1"
    targetptr="date-1"><citerefentry>
        <refentrytitle>date</refentrytitle>

        <manvolnum>1</manvolnum>
      </citerefentry></olink> oraz na końcu jedną linijkę wydruku z samego
    komendy <command>date</command>. Poniższy przykład poprawia program
    <filename>rw.d</filename> wprowadzając formatowanie wydruku w sposób
    podobny jak robi to <olink remap="external" targetdoc="refman1"
    targetptr="truss-1"><citerefentry>
        <refentrytitle>truss</refentrytitle>

        <manvolnum>1</manvolnum>
      </citerefentry></olink>, co ułatwi jego zrozumienie. Poniższy kod
    pochodzi z pliku <filename>trussrw.d</filename>:</para>

    <example id="ex-trussrw.d">
      <title><filename>trussrw.d</filename>: Trace System Calls with
      <citerefentry>
          <refentrytitle>truss</refentrytitle>

          <manvolnum>1</manvolnum>
        </citerefentry> Output Format</title>

      <programlisting>syscall::read:entry,
syscall::write:entry
/pid == $1/
{
	printf("%s(%d, 0x%x, %4d)", probefunc, arg0, arg1, arg2);
}

syscall::read:return,
syscall::write:return
/pid == $1/
{
	printf("\t\t = %d\n", arg1);
}</programlisting>
    </example>

    <para>W tym przykładzie stałą <literal>12345</literal> zastąpiono w każdym
    predykacie etykietą <literal>$1</literal>. Pozwala ona na wskazanie numeru
    procesu jako <emphasis>argument</emphasis> wywołania skryptu:
    <literal>$1</literal> jest podmieniana na wartość pierwszego argumentu
    podczas kompilacji skryptu. Do wykonania skryptu
    <filename>trussrw.d</filename> należy użyć komendy
    <command>dtrace</command> z opcjami <option>q</option> i
    <option>s</option> oraz numerem PID procesu jako ostatni argument. Opcja
    <option>q</option> instruuje <command>dtrace</command> aby nie podawał
    linii nagłówkowej oraz kolumn CPU i ID w poniższych przykładach. Skrypt w
    związku z tym wydrukuje tylko dane, które nakazano mu śledzić. Poniźszą
    komendę należy wprowdzić w linii poleceń (zamieniając
    <literal>12345</literal> na prawdziwy numer procesu powłoki) i nacisnąć
    przycisk return we wskazanym skryptowi procesie powłoki:</para>

    <screen><userinput># dtrace -q -s trussrw.d 12345</userinput>
	                 = 1
write(2, 0x8089e48,    1)                = 1
read(63, 0x8090a38, 1024)                = 0
read(63, 0x8090a38, 1024)                = 0
write(2, 0x8089e48,   52)                = 52
read(0, 0x8089878,    1)                 = 1
write(2, 0x8089e48,    1)                = 1
read(63, 0x8090a38, 1024)                = 0
read(63, 0x8090a38, 1024)                = 0
write(2, 0x8089e48,   52)                = 52
read(0, 0x8089878,    1)                 = 1
write(2, 0x8089e48,    1)                = 1
read(63, 0x8090a38, 1024)                = 0
read(63, 0x8090a38, 1024)                = 0
write(2, 0x8089e48,   52)                = 52
read(0, 0x8089878,    1)<userinput>^C</userinput>
#</screen>

    <para>Czas na bardziej szczegółową analizę d-programu. Podobnie jak w
    poprzednim programie klauzula nakazuje śledzenie wywołań systemowych
    <olink remap="external" targetdoc="refman2"
    targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i <olink remap="external" targetdoc="refman2"
    targetptr="write-2"><citerefentry>
        <refentrytitle>write</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> z poziomu powłoki. Ale w tym przykładzie użyto
    nowej funkcji, <function>printf</function>, w celu sformatowanego
    wydrukowania śledzonych danych:</para>

    <programlisting>syscall::read:entry,
syscall::write:entry
/pid == $1/
{
	printf("%s(%d, 0x%x, %4d)", probefunc, arg0, arg1, arg2);
}</programlisting>

    <para>Funkcja <function>printf</function> pozwala na jednoczesne śledzenie
    danych, jak w funkcji <function>trace</function> użytej wcześniej, a także
    na sformatowane drukowanie danych i innego tekstu. Funkcja
    <function>printf</function> instruuje DTrace, aby śledził dane związane z
    każdym argumentem po pierwszym argumencie, a potem aby wydrukował wyniki w
    formacie opisanym w pierwszym argumencie funkcji
    <function>printf</function> zwanym <firstterm>łańcuchem formatującym (ang.
    format string)</firstterm>.</para>

    <para>Łańcuch formatujący jest zwykłym łańcuchem zawierającym dowolną
    liczbę konwersji formatowania, z których każda zaczyna się od znaku
    <literal>%</literal>, opisujących sposób formatowania odpowiadających im
    argumentów. Pierwsza konwersja w łańcuchu formatującym odnosi się do
    drugiego argumentu funkcji <function>printf</function>, druga do trzeciego
    argumentu i tak dalej. Tekst pomiędzy konwersjami drukowany jest bez
    zmian. Znak następujący po znaku konwersji <literal>%</literal> opisuje
    format użyty podczas drukowania odpowiedniego argumentu. Poniższa tabela
    określa znaczenie poszczególnych konwersji użytych w
    <filename>trussrw.d</filename>:</para>

    <informaltable frame="none">
      <tgroup cols="2" colsep="0" rowsep="0">
        <colspec colwidth="0.50in" />

        <colspec colwidth="4.00in" />

        <tbody>
          <row>
            <entry><para><literal>%d</literal></para></entry>

            <entry><para>Drukuj jako całkowitą liczbę
            dziesiętną</para></entry>
          </row>

          <row>
            <entry><para><literal>%s</literal></para></entry>

            <entry><para>Drukuj jako łańcuch znaków</para></entry>
          </row>

          <row>
            <entry><para><literal>%x</literal></para></entry>

            <entry><para>Drukuj jako całkowitą liczbę
            szesnastkową</para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Funkcja <function>printf</function> z bibliteki DTrace działa tak
    samo jak <olink remap="external" targetdoc="refman3a"
    targetptr="printf-3c"><citerefentry>
        <refentrytitle>printf</refentrytitle>

        <manvolnum>3C</manvolnum>
      </citerefentry></olink> z biblioteki języka C lub narzędzie
    powłoki<olink remap="external" targetdoc="refman1"
    targetptr="printf-1"><citerefentry>
        <refentrytitle>printf</refentrytitle>

        <manvolnum>1</manvolnum>
      </citerefentry></olink>. Dla osób, które nigdy wcześniej nie korzystały
    z funkcji <function>printf</function>, podsumowanie przedstawiono w <olink
    remap="internal" targetptr="chp-fmt">Chapter 12, Output
    Formatting</olink>. Dokładną lekturę tego rozdziału poleca się nawet tym
    osobom, które znają już funkcję <function>printf</function> z innego
    języka. W D <function>printf</function> jest funkcją wbudowaną i pozwala
    na pewne nowe formatowania zaprojektowane specjalnie dla DTrace.</para>

    <para>Pomocne przy pisaniu prawidłowych programów jest sprawdzanie przez
    kompilator DTrace każdego łańcuhca formatującego
    <function>printf</function> w odniesieniu do arumentów tej funkcji. Jeśli
    spróbować uruchomić skrypt zamieniając <literal>probefunc</literal> na
    liczbę <literal>123</literal>, wydrukowany zostanie komunikat, że
    konwersja <literal>%s</literal> jest niewłaściwa dla argumentu w postaci
    liczby całkowitej:</para>

    <screen><userinput># dtrace -q -s trussrw.d</userinput>
dtrace: failed to compile script trussrw.d: line 4: printf( )
	   argument #2 is incompatible with conversion #1 prototype:
	        conversion: %s
	         prototype: char [] or string (or use stringof)
	          argument: int
#</screen>

    <para>Do wydrukowania wywołania systemowego read i write oraz ich
    argumentów może posłużyć poniższa postać funkcji
    <function>printf</function>:</para>

    <programlisting>printf("%s(%d, 0x%x, %4d)", probefunc, arg0, arg1, arg2);</programlisting>

    <para>Powoduje ona śledzenie nazwy aktualnej funkcji sondy oraz pierwszych
    trzech argumentów całkowitoliczbowych przekazanych do wywołania
    systemowego, dostępnych jako zmienne DTrace <literal>arg0</literal>,
    <literal>arg1</literal> i <literal>arg2</literal>. Więcej informacji o
    argumentach sond w <olink remap="internal"
    targetptr="chp-variables">Chapter 3, Variables</olink>. Pierwszy argument
    wywołania <olink remap="external" targetdoc="refman2"
    targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i <olink remap="external" targetdoc="refman2"
    targetptr="write-2"><citerefentry>
        <refentrytitle>write</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> to deskryptor pliku drukowany jako liczba
    dziesiętna. Drugi argument to adres buforu wydrukowany jako liczba
    szesnastkowa. Ostatni argument to wielkość buforu drukowana jako liczba
    dziesiętna. Do wydrukowania trzeciego argumentu użyto formatu
    <literal>%4d</literal>, który powoduje drukowanie liczby dziesiętnej z
    najmniejszą długością czterech znaków. Jesli liczba do wydrukowania jest
    krótsza, funkcja <function>printf</function> poprzedzi ją odpowiednią
    liczbą pustych znaków, aby wyrównać wydruk.</para>

    <para>Drukowanie wyniku każdego wywołania systemowego oraz zamknięcie
    każdej linii wydruku wykonuje się w poniższej klauzuli:</para>

    <programlisting>syscall::read:return,
syscall::write:return
/pid == $1/
{
	printf("\t\t = %d\n", arg1);
}</programlisting>

    <para>Należy zauważyć, że dostawca <literal>syscall</literal> dodatkowo
    dostarcza dla każdego wywołania systemowego sondę
    <literal>return</literal> jako uzupełnienie sondy
    <literal>entry</literal>. Zmienna DTrace <literal>arg1</literal> dla sond
    <literal>return</literal> otrzymuje wartość zwracaną przez wywołanie
    systemowe. Wartość ta jest drukowana jako całkowita liczba dziesiętna.
    Łańcuchy znakowe zaczynające się od ukośników oznaczają wcięcie
    (<literal>\t</literal>) oraz przejście do nowej linii
    (<literal>\n</literal>). Są to tak zwane <firstterm>sekwencje ucieczki
    (ang. escape sequences)</firstterm> i pozwalają drukować znaki, które są
    trudne do wprowadzania z kalwiatury. Język D pozwala na wykorzystanie tych
    samych sekwencji ucieczki jak język C, C++ i Java. Kompletna lista
    sekwencji ucieczki wydrukowana została w <olink remap="internal"
    targetptr="chp-typeopexpr">Chapter 2, Types, Operators, and
    Expressions</olink>.</para>
  </sect1>

  <sect1 id="chp-intro-7">
    <title>Arrays</title>

    <para>Język D pozwala definiowac zmienne do reprezentacji liczb
    całkowitych oraz innych typów, na przykład łańcuchów znaków lub typów
    złożonych, takich jak <firstterm>struktury</firstterm> i
    <firstterm>unie</firstterm>. Programistów języka C pownno ucieszyć, że w
    języku D mogą używać takich samych typów zmiennych jak w C. Dla
    niezaznajomionych z językiem C zamieszczono dokładny opis wszystkich typów
    danych w <olink remap="internal" targetptr="chp-typeopexpr">Chapter 2,
    Types, Operators, and Expressions</olink>. D obsługuje także doatkowy
    specjalny typ danych nazywany <firstterm>tablicą asocjacyjną
    (ang. associative array</firstterm>). Tablica asocjacyjna jest podobna do
    zwykłej tablicy, z tym że do roli indeksu można użyć innych typów danych
    niż całkowite liczbe dzisiętne.</para>

    <para>Tablice asocjacyjne w D można indeksować za pomocą listy jednej lub
    więcej wartości dowolnego typu. Indywidualne klucze tworzą tak zwane
    <firstterm>dwójki (ang. tuple)</firstterm> lub pary, które służą do
    indeksowania tablicy i sięgania lub zmiany wartości wskazywanej przez ten
    klucz. Typ wszystkich par użytych do indeksowania tablicy musi mieć tę
    samą sygnaturę, czyli każdy klucz pary musi mieć tę samą długość i musi
    mieć te same kluczowe typy danych w tej samej kolejności. Wartość związana
    z każdym elementem danej tablicy asocjacyjnej musi być także tego samego
    typu dla całej tablicy. Poniższe wyrażenie D definiuje tablicę asocjacyjną
    <literal>a</literal> z typem wartości <literal>int</literal>, sygnaturą
    pary <literal>[ string, int ]</literal> i przechowująca liczbę dzisiętną
    456:</para>

    <programlisting>a["hello", 123] = 456;</programlisting>

    <para>Po zdefiniowaniu tablicy po jej elementy mozna sięgać w taki sam
    sposób jak po inne zmienne D. Poniższe wyrażenie D zmienia wartość
    poprzednio zapisanego elementu tablicy przez zwiększenie jego wartości z
    456 do 457:</para>

    <programlisting>a["hello", 123]++;</programlisting>

    <para>Wartości dowolnych elementów tablicy, którym nie nadano wartości,
    zostały zainicjowane wartością zero. Czas na użycie tablicy w d-srypcie.
    Poniższy kod pochodzi z pliku <filename>rwtime.d</filename>:</para>

    <example id="ex-rwtime.d">
      <title><filename>rwtime.d</filename>: Time <citerefentry>
          <refentrytitle>read</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> and <citerefentry>
          <refentrytitle>write</refentrytitle>

          <manvolnum>2</manvolnum>
        </citerefentry> Calls</title>

      <programlisting>syscall::read:entry,
syscall::write:entry
/pid == $1/
{
	ts[probefunc] = timestamp;
}

syscall::read:return,
syscall::write:return
/pid == $1 &amp;&amp; ts[probefunc] != 0/
{
	printf("%d nsecs", timestamp - ts[probefunc]);
}</programlisting>
    </example>

    <para>Tak jak w przypadku <filename>trussrw.d</filename> podczas
    wywoływania <filename>rwtime.d</filename> należy podać PID procesu
    powłoki. Podczas wykonywania komend w oknie śledzonej powłoki, skrypt
    powinien drukować czas poświęcony na każde wywołanie systemowe. W oknie
    powłoki należy wpisac poniższą komendę i kilka razy nacisnąć
    return:</para>

    <screen><userinput># dtrace -s rwtime.d `pgrep -n ksh`</userinput>
dtrace: script 'rwtime.d' matched 4 probes
CPU     ID                    FUNCTION:NAME
  0     33                      read:return 22644 nsecs
  0     33                      read:return 3382 nsecs
  0     35                     write:return 25952 nsecs
  0     33                      read:return 916875239 nsecs
  0     35                     write:return 27320 nsecs
  0     33                      read:return 9022 nsecs
  0     33                      read:return 3776 nsecs
  0     35                     write:return 17164 nsecs
...
<userinput>^C</userinput>
#</screen>

    <para>Aby prześledzić czas poświęcony na każde wywołanie systemowe, należy
    instrumentować zarówno moment wejścia jak i moment wyjścia z wywołania
    systemowego <olink remap="external" targetdoc="refman2"
    targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i <olink remap="external" targetdoc="refman2"
    targetptr="write-2"><citerefentry>
        <refentrytitle>write</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i pobrać czas w każdym z tych punktów. Podczas
    wychodzenia z wywołania należy obliczyć różnicę między pierwszym i drugim
    czasem. Można użyć odrębnych zmiennych dla każdego wywołania, ale
    utrudniałoby to dodawanie do programu kolejnych wywołań. Łatwiej jest użyć
    tablicy asocjacyjnej indeksowanej nazwą funkcji sondy. Oto klauzula
    pierwszej sondy:</para>

    <programlisting>syscall::read:entry,
syscall::write:entry
/pid == $1/
{
	ts[probefunc] = timestamp;
}</programlisting>

    <para>Klauzula ta definiuje tablicę nazwaną <literal>ts</literal> i
    przypisuje odpowiednim elementom wartości zmiennej DTrace'a
    <literal>timestamp</literal>. Zmienna ta zwraca wartość ciągle
    zwiększanego licznika nanosekundowego, podobnie do finkcji biblitoecznej
    Solarisa <olink remap="external" targetdoc="refman3a"
    targetptr="gethrtime-3c"><citerefentry>
        <refentrytitle>gethrtime</refentrytitle>

        <manvolnum>3C</manvolnum>
      </citerefentry></olink>. Po zapisaniu znacznika czasu wejścia w
    wywołanie systemowe, odpowiednia sonda <literal>return</literal> ponownie
    tworzy znacznik czasu i zwraca różnicę między aktualnym czasem a zapisaną
    wartością:</para>

    <programlisting>syscall::read:return,
syscall::write:return
/pid == $1 &amp;&amp; ts[probefunc] != 0/
{
	printf("%d nsecs", timestamp - ts[probefunc]);
}</programlisting>

    <para>Predykat dla sondy return wymaga od DTrace śledzenia właściwego
    procesu, dla którego odpaliła sonda <literal>entry</literal> i zapisała
    odpowiednią niezerową wartość do tablicy <literal>ts[probefunc]</literal>.
    Ta sztuczka pozwala na uniknięcie pojawienia się niewłaściwych wartości
    zaraz po uruchomieniu DTrace. Jeśli śledzona powłoka właśnie oczekuje w
    wywołaniu <olink remap="external" targetdoc="refman2"
    targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> podczas wykonania komendy
    <command>dtrace</command>, to sonda <literal>read:return</literal> odpali
    przed odpowiednią sondą <literal>read:entry</literal> dla pierwszego
    wywołania systmowego <olink remap="external" targetdoc="refman2"
    targetptr="read-2"><citerefentry>
        <refentrytitle>read</refentrytitle>

        <manvolnum>2</manvolnum>
      </citerefentry></olink> i <literal>ts[probefunc]</literal> będzie
    zawierała wartość zero, ponieważ nie otrzymała jeszcze wartości od
    skryptu.</para>
  </sect1>

  <sect1 id="chp-intro-8">
    <title>External Symbols and Types</title>

    <para>Instrumentacja DTrace wykonywana jest wewnątrz jądra systemu
    oepracyjnego Solaris, zatem oprócz specjalnych zmiennych i argumentów
    sond, można sięgać także po struktury danych, symbole i typy jądra.
    Umozliwia to zaawansowanym użytkownikom DTrace'a śledzenie
    niskopoziomowego zachowania jądra systemu i sterowników urządzeń.
    Bibliografia na początku książki zawiera pozycje, które mogą okazać sie
    pomocne podczas nauki wewnętrznych mechanizmów systemu operacyjnego
    Solaris.</para>

    <para>Język D używa znaku <literal>`</literal> jako specjalnego opeartora
    zasięgu podczas sięgania do symboli zdefiniowanych w systemie operacyjnym,
    a nie w d-programie. Na przykład jądro Solarisa zawiera deklaracje w C
    parametru systemowego <literal>kmem_flags</literal> pozwalającego na
    włączenie debuggowania alokatora pamięci. Więcej informacji o
    <literal>kmem_flags</literal> w <olink remap="external"
    targetdoc="soltuneparamref"><citetitle remap="book">Solaris Tunable
    Parameters Reference Manual</citetitle></olink>. Deklaracja tego parametru
    w C wygląda następująco:</para>

    <programlisting>int kmem_flags;</programlisting>

    <para>Śledzenie wartości tej zmiennej w d-programie można wykonać w
    nastepujący sposób:</para>

    <programlisting>trace(`kmem_flags);</programlisting>

    <para>DTrace wiąże każdy symbol jądra z typem danych użytym dla symbolu w
    kodzie C, co pozwala na łatwy dostęp na poziomie kodu źródłowego do
    struktur danych jądra. Nazwy symboli jądra przechowywane są w odrębnej
    przestrzeni nazw niż zmienne i identyfikatory funkcji D, stąd nie trzeba
    martwić się o konflikty nazw.</para>

    <para>Na tym kończy się szybki przegląd DTrace'a, podczas którego
    przedstawiono wiele podstawowych elementów DTrace'a, niezbędnych do
    budowania większych d-programów. Nastę pne rozdziały opisują kompletny
    zestaw reguł D i demonstrują jak uprościć skomplikowane pomiary wydajności
    i analizy funkcjonalnej. Później zaprezentowane będzie w jaki użyć
    Dtrace'a do połączenia zachowania aplikacji przestrzeni użytkownika z
    zachowaniem systemu, pozwalając na analizę wszystkich warstw
    oprogramowania.</para>

    <para>A to dopiero początek!</para>
  </sect1>
</chapter>